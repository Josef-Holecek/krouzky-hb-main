"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./node_modules/@firebase/storage/dist/index.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/@firebase/storage/dist/index.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageError: () => (/* binding */ StorageError),\n/* harmony export */   StorageErrorCode: () => (/* binding */ StorageErrorCode),\n/* harmony export */   StringFormat: () => (/* binding */ StringFormat),\n/* harmony export */   _FbsBlob: () => (/* binding */ FbsBlob),\n/* harmony export */   _Location: () => (/* binding */ Location),\n/* harmony export */   _TaskEvent: () => (/* binding */ TaskEvent),\n/* harmony export */   _TaskState: () => (/* binding */ TaskState),\n/* harmony export */   _UploadTask: () => (/* binding */ UploadTask),\n/* harmony export */   _dataFromString: () => (/* binding */ dataFromString),\n/* harmony export */   _getChild: () => (/* binding */ _getChild),\n/* harmony export */   _invalidArgument: () => (/* binding */ invalidArgument),\n/* harmony export */   _invalidRootOperation: () => (/* binding */ invalidRootOperation),\n/* harmony export */   connectStorageEmulator: () => (/* binding */ connectStorageEmulator),\n/* harmony export */   deleteObject: () => (/* binding */ deleteObject),\n/* harmony export */   getBlob: () => (/* binding */ getBlob),\n/* harmony export */   getBytes: () => (/* binding */ getBytes),\n/* harmony export */   getDownloadURL: () => (/* binding */ getDownloadURL),\n/* harmony export */   getMetadata: () => (/* binding */ getMetadata),\n/* harmony export */   getStorage: () => (/* binding */ getStorage),\n/* harmony export */   getStream: () => (/* binding */ getStream),\n/* harmony export */   list: () => (/* binding */ list),\n/* harmony export */   listAll: () => (/* binding */ listAll),\n/* harmony export */   ref: () => (/* binding */ ref),\n/* harmony export */   updateMetadata: () => (/* binding */ updateMetadata),\n/* harmony export */   uploadBytes: () => (/* binding */ uploadBytes),\n/* harmony export */   uploadBytesResumable: () => (/* binding */ uploadBytesResumable),\n/* harmony export */   uploadString: () => (/* binding */ uploadString)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(app-pages-browser)/./node_modules/@firebase/app/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ \"(app-pages-browser)/./node_modules/@firebase/util/dist/index.esm.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/component */ \"(app-pages-browser)/./node_modules/@firebase/component/dist/esm/index.esm.js\");\n\n\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Constants used in the Firebase Storage library.\n */\n/**\n * Domain name for firebase storage.\n */\nconst DEFAULT_HOST = 'firebasestorage.googleapis.com';\n/**\n * The key in Firebase config json for the storage bucket.\n */\nconst CONFIG_STORAGE_BUCKET_KEY = 'storageBucket';\n/**\n * 2 minutes\n *\n * The timeout for all operations except upload.\n */\nconst DEFAULT_MAX_OPERATION_RETRY_TIME = 2 * 60 * 1000;\n/**\n * 10 minutes\n *\n * The timeout for upload.\n */\nconst DEFAULT_MAX_UPLOAD_RETRY_TIME = 10 * 60 * 1000;\n/**\n * 1 second\n */\nconst DEFAULT_MIN_SLEEP_TIME_MILLIS = 1000;\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An error returned by the Firebase Storage SDK.\n * @public\n */\nclass StorageError extends _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError {\n    /**\n     * @param code - A `StorageErrorCode` string to be prefixed with 'storage/' and\n     *  added to the end of the message.\n     * @param message  - Error message.\n     * @param status_ - Corresponding HTTP Status Code\n     */\n    constructor(code, message, status_ = 0) {\n        super(prependCode(code), `Firebase Storage: ${message} (${prependCode(code)})`);\n        this.status_ = status_;\n        /**\n         * Stores custom error data unique to the `StorageError`.\n         */\n        this.customData = { serverResponse: null };\n        this._baseMessage = this.message;\n        // Without this, `instanceof StorageError`, in tests for example,\n        // returns false.\n        Object.setPrototypeOf(this, StorageError.prototype);\n    }\n    get status() {\n        return this.status_;\n    }\n    set status(status) {\n        this.status_ = status;\n    }\n    /**\n     * Compares a `StorageErrorCode` against this error's code, filtering out the prefix.\n     */\n    _codeEquals(code) {\n        return prependCode(code) === this.code;\n    }\n    /**\n     * Optional response message that was added by the server.\n     */\n    get serverResponse() {\n        return this.customData.serverResponse;\n    }\n    set serverResponse(serverResponse) {\n        this.customData.serverResponse = serverResponse;\n        if (this.customData.serverResponse) {\n            this.message = `${this._baseMessage}\\n${this.customData.serverResponse}`;\n        }\n        else {\n            this.message = this._baseMessage;\n        }\n    }\n}\n/**\n * @public\n * Error codes that can be attached to `StorageError` objects.\n */\nvar StorageErrorCode;\n(function (StorageErrorCode) {\n    // Shared between all platforms\n    StorageErrorCode[\"UNKNOWN\"] = \"unknown\";\n    StorageErrorCode[\"OBJECT_NOT_FOUND\"] = \"object-not-found\";\n    StorageErrorCode[\"BUCKET_NOT_FOUND\"] = \"bucket-not-found\";\n    StorageErrorCode[\"PROJECT_NOT_FOUND\"] = \"project-not-found\";\n    StorageErrorCode[\"QUOTA_EXCEEDED\"] = \"quota-exceeded\";\n    StorageErrorCode[\"UNAUTHENTICATED\"] = \"unauthenticated\";\n    StorageErrorCode[\"UNAUTHORIZED\"] = \"unauthorized\";\n    StorageErrorCode[\"UNAUTHORIZED_APP\"] = \"unauthorized-app\";\n    StorageErrorCode[\"RETRY_LIMIT_EXCEEDED\"] = \"retry-limit-exceeded\";\n    StorageErrorCode[\"INVALID_CHECKSUM\"] = \"invalid-checksum\";\n    StorageErrorCode[\"CANCELED\"] = \"canceled\";\n    // JS specific\n    StorageErrorCode[\"INVALID_EVENT_NAME\"] = \"invalid-event-name\";\n    StorageErrorCode[\"INVALID_URL\"] = \"invalid-url\";\n    StorageErrorCode[\"INVALID_DEFAULT_BUCKET\"] = \"invalid-default-bucket\";\n    StorageErrorCode[\"NO_DEFAULT_BUCKET\"] = \"no-default-bucket\";\n    StorageErrorCode[\"CANNOT_SLICE_BLOB\"] = \"cannot-slice-blob\";\n    StorageErrorCode[\"SERVER_FILE_WRONG_SIZE\"] = \"server-file-wrong-size\";\n    StorageErrorCode[\"NO_DOWNLOAD_URL\"] = \"no-download-url\";\n    StorageErrorCode[\"INVALID_ARGUMENT\"] = \"invalid-argument\";\n    StorageErrorCode[\"INVALID_ARGUMENT_COUNT\"] = \"invalid-argument-count\";\n    StorageErrorCode[\"APP_DELETED\"] = \"app-deleted\";\n    StorageErrorCode[\"INVALID_ROOT_OPERATION\"] = \"invalid-root-operation\";\n    StorageErrorCode[\"INVALID_FORMAT\"] = \"invalid-format\";\n    StorageErrorCode[\"INTERNAL_ERROR\"] = \"internal-error\";\n    StorageErrorCode[\"UNSUPPORTED_ENVIRONMENT\"] = \"unsupported-environment\";\n})(StorageErrorCode || (StorageErrorCode = {}));\nfunction prependCode(code) {\n    return 'storage/' + code;\n}\nfunction unknown() {\n    const message = 'An unknown error occurred, please check the error payload for ' +\n        'server response.';\n    return new StorageError(StorageErrorCode.UNKNOWN, message);\n}\nfunction objectNotFound(path) {\n    return new StorageError(StorageErrorCode.OBJECT_NOT_FOUND, \"Object '\" + path + \"' does not exist.\");\n}\nfunction quotaExceeded(bucket) {\n    return new StorageError(StorageErrorCode.QUOTA_EXCEEDED, \"Quota for bucket '\" +\n        bucket +\n        \"' exceeded, please view quota on \" +\n        'https://firebase.google.com/pricing/.');\n}\nfunction unauthenticated() {\n    const message = 'User is not authenticated, please authenticate using Firebase ' +\n        'Authentication and try again.';\n    return new StorageError(StorageErrorCode.UNAUTHENTICATED, message);\n}\nfunction unauthorizedApp() {\n    return new StorageError(StorageErrorCode.UNAUTHORIZED_APP, 'This app does not have permission to access Firebase Storage on this project.');\n}\nfunction unauthorized(path) {\n    return new StorageError(StorageErrorCode.UNAUTHORIZED, \"User does not have permission to access '\" + path + \"'.\");\n}\nfunction retryLimitExceeded() {\n    return new StorageError(StorageErrorCode.RETRY_LIMIT_EXCEEDED, 'Max retry time for operation exceeded, please try again.');\n}\nfunction canceled() {\n    return new StorageError(StorageErrorCode.CANCELED, 'User canceled the upload/download.');\n}\nfunction invalidUrl(url) {\n    return new StorageError(StorageErrorCode.INVALID_URL, \"Invalid URL '\" + url + \"'.\");\n}\nfunction invalidDefaultBucket(bucket) {\n    return new StorageError(StorageErrorCode.INVALID_DEFAULT_BUCKET, \"Invalid default bucket '\" + bucket + \"'.\");\n}\nfunction noDefaultBucket() {\n    return new StorageError(StorageErrorCode.NO_DEFAULT_BUCKET, 'No default bucket ' +\n        \"found. Did you set the '\" +\n        CONFIG_STORAGE_BUCKET_KEY +\n        \"' property when initializing the app?\");\n}\nfunction cannotSliceBlob() {\n    return new StorageError(StorageErrorCode.CANNOT_SLICE_BLOB, 'Cannot slice blob for upload. Please retry the upload.');\n}\nfunction serverFileWrongSize() {\n    return new StorageError(StorageErrorCode.SERVER_FILE_WRONG_SIZE, 'Server recorded incorrect upload file size, please retry the upload.');\n}\nfunction noDownloadURL() {\n    return new StorageError(StorageErrorCode.NO_DOWNLOAD_URL, 'The given file does not have any download URLs.');\n}\nfunction missingPolyFill(polyFill) {\n    return new StorageError(StorageErrorCode.UNSUPPORTED_ENVIRONMENT, `${polyFill} is missing. Make sure to install the required polyfills. See https://firebase.google.com/docs/web/environments-js-sdk#polyfills for more information.`);\n}\n/**\n * @internal\n */\nfunction invalidArgument(message) {\n    return new StorageError(StorageErrorCode.INVALID_ARGUMENT, message);\n}\nfunction appDeleted() {\n    return new StorageError(StorageErrorCode.APP_DELETED, 'The Firebase app was deleted.');\n}\n/**\n * @param name - The name of the operation that was invalid.\n *\n * @internal\n */\nfunction invalidRootOperation(name) {\n    return new StorageError(StorageErrorCode.INVALID_ROOT_OPERATION, \"The operation '\" +\n        name +\n        \"' cannot be performed on a root reference, create a non-root \" +\n        \"reference using child, such as .child('file.png').\");\n}\n/**\n * @param format - The format that was not valid.\n * @param message - A message describing the format violation.\n */\nfunction invalidFormat(format, message) {\n    return new StorageError(StorageErrorCode.INVALID_FORMAT, \"String does not match format '\" + format + \"': \" + message);\n}\n/**\n * @param message - A message describing the internal error.\n */\nfunction internalError(message) {\n    throw new StorageError(StorageErrorCode.INTERNAL_ERROR, 'Internal error: ' + message);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Firebase Storage location data.\n *\n * @internal\n */\nclass Location {\n    constructor(bucket, path) {\n        this.bucket = bucket;\n        this.path_ = path;\n    }\n    get path() {\n        return this.path_;\n    }\n    get isRoot() {\n        return this.path.length === 0;\n    }\n    fullServerUrl() {\n        const encode = encodeURIComponent;\n        return '/b/' + encode(this.bucket) + '/o/' + encode(this.path);\n    }\n    bucketOnlyServerUrl() {\n        const encode = encodeURIComponent;\n        return '/b/' + encode(this.bucket) + '/o';\n    }\n    static makeFromBucketSpec(bucketString, host) {\n        let bucketLocation;\n        try {\n            bucketLocation = Location.makeFromUrl(bucketString, host);\n        }\n        catch (e) {\n            // Not valid URL, use as-is. This lets you put bare bucket names in\n            // config.\n            return new Location(bucketString, '');\n        }\n        if (bucketLocation.path === '') {\n            return bucketLocation;\n        }\n        else {\n            throw invalidDefaultBucket(bucketString);\n        }\n    }\n    static makeFromUrl(url, host) {\n        let location = null;\n        const bucketDomain = '([A-Za-z0-9.\\\\-_]+)';\n        function gsModify(loc) {\n            if (loc.path.charAt(loc.path.length - 1) === '/') {\n                loc.path_ = loc.path_.slice(0, -1);\n            }\n        }\n        const gsPath = '(/(.*))?$';\n        const gsRegex = new RegExp('^gs://' + bucketDomain + gsPath, 'i');\n        const gsIndices = { bucket: 1, path: 3 };\n        function httpModify(loc) {\n            loc.path_ = decodeURIComponent(loc.path);\n        }\n        const version = 'v[A-Za-z0-9_]+';\n        const firebaseStorageHost = host.replace(/[.]/g, '\\\\.');\n        const firebaseStoragePath = '(/([^?#]*).*)?$';\n        const firebaseStorageRegExp = new RegExp(`^https?://${firebaseStorageHost}/${version}/b/${bucketDomain}/o${firebaseStoragePath}`, 'i');\n        const firebaseStorageIndices = { bucket: 1, path: 3 };\n        const cloudStorageHost = host === DEFAULT_HOST\n            ? '(?:storage.googleapis.com|storage.cloud.google.com)'\n            : host;\n        const cloudStoragePath = '([^?#]*)';\n        const cloudStorageRegExp = new RegExp(`^https?://${cloudStorageHost}/${bucketDomain}/${cloudStoragePath}`, 'i');\n        const cloudStorageIndices = { bucket: 1, path: 2 };\n        const groups = [\n            { regex: gsRegex, indices: gsIndices, postModify: gsModify },\n            {\n                regex: firebaseStorageRegExp,\n                indices: firebaseStorageIndices,\n                postModify: httpModify\n            },\n            {\n                regex: cloudStorageRegExp,\n                indices: cloudStorageIndices,\n                postModify: httpModify\n            }\n        ];\n        for (let i = 0; i < groups.length; i++) {\n            const group = groups[i];\n            const captures = group.regex.exec(url);\n            if (captures) {\n                const bucketValue = captures[group.indices.bucket];\n                let pathValue = captures[group.indices.path];\n                if (!pathValue) {\n                    pathValue = '';\n                }\n                location = new Location(bucketValue, pathValue);\n                group.postModify(location);\n                break;\n            }\n        }\n        if (location == null) {\n            throw invalidUrl(url);\n        }\n        return location;\n    }\n}\n\n/**\n * A request whose promise always fails.\n */\nclass FailRequest {\n    constructor(error) {\n        this.promise_ = Promise.reject(error);\n    }\n    /** @inheritDoc */\n    getPromise() {\n        return this.promise_;\n    }\n    /** @inheritDoc */\n    cancel(_appDelete = false) { }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Accepts a callback for an action to perform (`doRequest`),\n * and then a callback for when the backoff has completed (`backoffCompleteCb`).\n * The callback sent to start requires an argument to call (`onRequestComplete`).\n * When `start` calls `doRequest`, it passes a callback for when the request has\n * completed, `onRequestComplete`. Based on this, the backoff continues, with\n * another call to `doRequest` and the above loop continues until the timeout\n * is hit, or a successful response occurs.\n * @description\n * @param doRequest Callback to perform request\n * @param backoffCompleteCb Callback to call when backoff has been completed\n */\nfunction start(doRequest, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nbackoffCompleteCb, timeout) {\n    // TODO(andysoto): make this code cleaner (probably refactor into an actual\n    // type instead of a bunch of functions with state shared in the closure)\n    let waitSeconds = 1;\n    // Would type this as \"number\" but that doesn't work for Node so ¯\\_(ツ)_/¯\n    // TODO: find a way to exclude Node type definition for storage because storage only works in browser\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let retryTimeoutId = null;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let globalTimeoutId = null;\n    let hitTimeout = false;\n    let cancelState = 0;\n    function canceled() {\n        return cancelState === 2;\n    }\n    let triggeredCallback = false;\n    function triggerCallback(...args) {\n        if (!triggeredCallback) {\n            triggeredCallback = true;\n            backoffCompleteCb.apply(null, args);\n        }\n    }\n    function callWithDelay(millis) {\n        retryTimeoutId = setTimeout(() => {\n            retryTimeoutId = null;\n            doRequest(responseHandler, canceled());\n        }, millis);\n    }\n    function clearGlobalTimeout() {\n        if (globalTimeoutId) {\n            clearTimeout(globalTimeoutId);\n        }\n    }\n    function responseHandler(success, ...args) {\n        if (triggeredCallback) {\n            clearGlobalTimeout();\n            return;\n        }\n        if (success) {\n            clearGlobalTimeout();\n            triggerCallback.call(null, success, ...args);\n            return;\n        }\n        const mustStop = canceled() || hitTimeout;\n        if (mustStop) {\n            clearGlobalTimeout();\n            triggerCallback.call(null, success, ...args);\n            return;\n        }\n        if (waitSeconds < 64) {\n            /* TODO(andysoto): don't back off so quickly if we know we're offline. */\n            waitSeconds *= 2;\n        }\n        let waitMillis;\n        if (cancelState === 1) {\n            cancelState = 2;\n            waitMillis = 0;\n        }\n        else {\n            waitMillis = (waitSeconds + Math.random()) * 1000;\n        }\n        callWithDelay(waitMillis);\n    }\n    let stopped = false;\n    function stop(wasTimeout) {\n        if (stopped) {\n            return;\n        }\n        stopped = true;\n        clearGlobalTimeout();\n        if (triggeredCallback) {\n            return;\n        }\n        if (retryTimeoutId !== null) {\n            if (!wasTimeout) {\n                cancelState = 2;\n            }\n            clearTimeout(retryTimeoutId);\n            callWithDelay(0);\n        }\n        else {\n            if (!wasTimeout) {\n                cancelState = 1;\n            }\n        }\n    }\n    callWithDelay(0);\n    globalTimeoutId = setTimeout(() => {\n        hitTimeout = true;\n        stop(true);\n    }, timeout);\n    return stop;\n}\n/**\n * Stops the retry loop from repeating.\n * If the function is currently \"in between\" retries, it is invoked immediately\n * with the second parameter as \"true\". Otherwise, it will be invoked once more\n * after the current invocation finishes iff the current invocation would have\n * triggered another retry.\n */\nfunction stop(id) {\n    id(false);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isJustDef(p) {\n    return p !== void 0;\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isFunction(p) {\n    return typeof p === 'function';\n}\nfunction isNonArrayObject(p) {\n    return typeof p === 'object' && !Array.isArray(p);\n}\nfunction isString(p) {\n    return typeof p === 'string' || p instanceof String;\n}\nfunction isNativeBlob(p) {\n    return isNativeBlobDefined() && p instanceof Blob;\n}\nfunction isNativeBlobDefined() {\n    return typeof Blob !== 'undefined';\n}\nfunction validateNumber(argument, minValue, maxValue, value) {\n    if (value < minValue) {\n        throw invalidArgument(`Invalid value for '${argument}'. Expected ${minValue} or greater.`);\n    }\n    if (value > maxValue) {\n        throw invalidArgument(`Invalid value for '${argument}'. Expected ${maxValue} or less.`);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction makeUrl(urlPart, host, protocol) {\n    let origin = host;\n    if (protocol == null) {\n        origin = `https://${host}`;\n    }\n    return `${protocol}://${origin}/v0${urlPart}`;\n}\nfunction makeQueryString(params) {\n    const encode = encodeURIComponent;\n    let queryPart = '?';\n    for (const key in params) {\n        if (params.hasOwnProperty(key)) {\n            const nextPart = encode(key) + '=' + encode(params[key]);\n            queryPart = queryPart + nextPart + '&';\n        }\n    }\n    // Chop off the extra '&' or '?' on the end\n    queryPart = queryPart.slice(0, -1);\n    return queryPart;\n}\n\n/**\n * Error codes for requests made by the XhrIo wrapper.\n */\nvar ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[ErrorCode[\"NO_ERROR\"] = 0] = \"NO_ERROR\";\n    ErrorCode[ErrorCode[\"NETWORK_ERROR\"] = 1] = \"NETWORK_ERROR\";\n    ErrorCode[ErrorCode[\"ABORT\"] = 2] = \"ABORT\";\n})(ErrorCode || (ErrorCode = {}));\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Checks the status code to see if the action should be retried.\n *\n * @param status Current HTTP status code returned by server.\n * @param additionalRetryCodes additional retry codes to check against\n */\nfunction isRetryStatusCode(status, additionalRetryCodes) {\n    // The codes for which to retry came from this page:\n    // https://cloud.google.com/storage/docs/exponential-backoff\n    const isFiveHundredCode = status >= 500 && status < 600;\n    const extraRetryCodes = [\n        // Request Timeout: web server didn't receive full request in time.\n        408,\n        // Too Many Requests: you're getting rate-limited, basically.\n        429\n    ];\n    const isExtraRetryCode = extraRetryCodes.indexOf(status) !== -1;\n    const isAdditionalRetryCode = additionalRetryCodes.indexOf(status) !== -1;\n    return isFiveHundredCode || isExtraRetryCode || isAdditionalRetryCode;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Handles network logic for all Storage Requests, including error reporting and\n * retries with backoff.\n *\n * @param I - the type of the backend's network response.\n * @param - O the output type used by the rest of the SDK. The conversion\n * happens in the specified `callback_`.\n */\nclass NetworkRequest {\n    constructor(url_, method_, headers_, body_, successCodes_, additionalRetryCodes_, callback_, errorCallback_, timeout_, progressCallback_, connectionFactory_, retry = true, isUsingEmulator = false) {\n        this.url_ = url_;\n        this.method_ = method_;\n        this.headers_ = headers_;\n        this.body_ = body_;\n        this.successCodes_ = successCodes_;\n        this.additionalRetryCodes_ = additionalRetryCodes_;\n        this.callback_ = callback_;\n        this.errorCallback_ = errorCallback_;\n        this.timeout_ = timeout_;\n        this.progressCallback_ = progressCallback_;\n        this.connectionFactory_ = connectionFactory_;\n        this.retry = retry;\n        this.isUsingEmulator = isUsingEmulator;\n        this.pendingConnection_ = null;\n        this.backoffId_ = null;\n        this.canceled_ = false;\n        this.appDelete_ = false;\n        this.promise_ = new Promise((resolve, reject) => {\n            this.resolve_ = resolve;\n            this.reject_ = reject;\n            this.start_();\n        });\n    }\n    /**\n     * Actually starts the retry loop.\n     */\n    start_() {\n        const doTheRequest = (backoffCallback, canceled) => {\n            if (canceled) {\n                backoffCallback(false, new RequestEndStatus(false, null, true));\n                return;\n            }\n            const connection = this.connectionFactory_();\n            this.pendingConnection_ = connection;\n            const progressListener = progressEvent => {\n                const loaded = progressEvent.loaded;\n                const total = progressEvent.lengthComputable ? progressEvent.total : -1;\n                if (this.progressCallback_ !== null) {\n                    this.progressCallback_(loaded, total);\n                }\n            };\n            if (this.progressCallback_ !== null) {\n                connection.addUploadProgressListener(progressListener);\n            }\n            // connection.send() never rejects, so we don't need to have a error handler or use catch on the returned promise.\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            connection\n                .send(this.url_, this.method_, this.isUsingEmulator, this.body_, this.headers_)\n                .then(() => {\n                if (this.progressCallback_ !== null) {\n                    connection.removeUploadProgressListener(progressListener);\n                }\n                this.pendingConnection_ = null;\n                const hitServer = connection.getErrorCode() === ErrorCode.NO_ERROR;\n                const status = connection.getStatus();\n                if (!hitServer ||\n                    (isRetryStatusCode(status, this.additionalRetryCodes_) &&\n                        this.retry)) {\n                    const wasCanceled = connection.getErrorCode() === ErrorCode.ABORT;\n                    backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));\n                    return;\n                }\n                const successCode = this.successCodes_.indexOf(status) !== -1;\n                backoffCallback(true, new RequestEndStatus(successCode, connection));\n            });\n        };\n        /**\n         * @param requestWentThrough - True if the request eventually went\n         *     through, false if it hit the retry limit or was canceled.\n         */\n        const backoffDone = (requestWentThrough, status) => {\n            const resolve = this.resolve_;\n            const reject = this.reject_;\n            const connection = status.connection;\n            if (status.wasSuccessCode) {\n                try {\n                    const result = this.callback_(connection, connection.getResponse());\n                    if (isJustDef(result)) {\n                        resolve(result);\n                    }\n                    else {\n                        resolve();\n                    }\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }\n            else {\n                if (connection !== null) {\n                    const err = unknown();\n                    err.serverResponse = connection.getErrorText();\n                    if (this.errorCallback_) {\n                        reject(this.errorCallback_(connection, err));\n                    }\n                    else {\n                        reject(err);\n                    }\n                }\n                else {\n                    if (status.canceled) {\n                        const err = this.appDelete_ ? appDeleted() : canceled();\n                        reject(err);\n                    }\n                    else {\n                        const err = retryLimitExceeded();\n                        reject(err);\n                    }\n                }\n            }\n        };\n        if (this.canceled_) {\n            backoffDone(false, new RequestEndStatus(false, null, true));\n        }\n        else {\n            this.backoffId_ = start(doTheRequest, backoffDone, this.timeout_);\n        }\n    }\n    /** @inheritDoc */\n    getPromise() {\n        return this.promise_;\n    }\n    /** @inheritDoc */\n    cancel(appDelete) {\n        this.canceled_ = true;\n        this.appDelete_ = appDelete || false;\n        if (this.backoffId_ !== null) {\n            stop(this.backoffId_);\n        }\n        if (this.pendingConnection_ !== null) {\n            this.pendingConnection_.abort();\n        }\n    }\n}\n/**\n * A collection of information about the result of a network request.\n * @param opt_canceled - Defaults to false.\n */\nclass RequestEndStatus {\n    constructor(wasSuccessCode, connection, canceled) {\n        this.wasSuccessCode = wasSuccessCode;\n        this.connection = connection;\n        this.canceled = !!canceled;\n    }\n}\nfunction addAuthHeader_(headers, authToken) {\n    if (authToken !== null && authToken.length > 0) {\n        headers['Authorization'] = 'Firebase ' + authToken;\n    }\n}\nfunction addVersionHeader_(headers, firebaseVersion) {\n    headers['X-Firebase-Storage-Version'] =\n        'webjs/' + (firebaseVersion ?? 'AppManager');\n}\nfunction addGmpidHeader_(headers, appId) {\n    if (appId) {\n        headers['X-Firebase-GMPID'] = appId;\n    }\n}\nfunction addAppCheckHeader_(headers, appCheckToken) {\n    if (appCheckToken !== null) {\n        headers['X-Firebase-AppCheck'] = appCheckToken;\n    }\n}\nfunction makeRequest(requestInfo, appId, authToken, appCheckToken, requestFactory, firebaseVersion, retry = true, isUsingEmulator = false) {\n    const queryPart = makeQueryString(requestInfo.urlParams);\n    const url = requestInfo.url + queryPart;\n    const headers = Object.assign({}, requestInfo.headers);\n    addGmpidHeader_(headers, appId);\n    addAuthHeader_(headers, authToken);\n    addVersionHeader_(headers, firebaseVersion);\n    addAppCheckHeader_(headers, appCheckToken);\n    return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, requestFactory, retry, isUsingEmulator);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getBlobBuilder() {\n    if (typeof BlobBuilder !== 'undefined') {\n        return BlobBuilder;\n    }\n    else if (typeof WebKitBlobBuilder !== 'undefined') {\n        return WebKitBlobBuilder;\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * Concatenates one or more values together and converts them to a Blob.\n *\n * @param args The values that will make up the resulting blob.\n * @return The blob.\n */\nfunction getBlob$1(...args) {\n    const BlobBuilder = getBlobBuilder();\n    if (BlobBuilder !== undefined) {\n        const bb = new BlobBuilder();\n        for (let i = 0; i < args.length; i++) {\n            bb.append(args[i]);\n        }\n        return bb.getBlob();\n    }\n    else {\n        if (isNativeBlobDefined()) {\n            return new Blob(args);\n        }\n        else {\n            throw new StorageError(StorageErrorCode.UNSUPPORTED_ENVIRONMENT, \"This browser doesn't seem to support creating Blobs\");\n        }\n    }\n}\n/**\n * Slices the blob. The returned blob contains data from the start byte\n * (inclusive) till the end byte (exclusive). Negative indices cannot be used.\n *\n * @param blob The blob to be sliced.\n * @param start Index of the starting byte.\n * @param end Index of the ending byte.\n * @return The blob slice or null if not supported.\n */\nfunction sliceBlob(blob, start, end) {\n    if (blob.webkitSlice) {\n        return blob.webkitSlice(start, end);\n    }\n    else if (blob.mozSlice) {\n        return blob.mozSlice(start, end);\n    }\n    else if (blob.slice) {\n        return blob.slice(start, end);\n    }\n    return null;\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Converts a Base64 encoded string to a binary string. */\nfunction decodeBase64(encoded) {\n    if (typeof atob === 'undefined') {\n        throw missingPolyFill('base-64');\n    }\n    return atob(encoded);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An enumeration of the possible string formats for upload.\n * @public\n */\nconst StringFormat = {\n    /**\n     * Indicates the string should be interpreted \"raw\", that is, as normal text.\n     * The string will be interpreted as UTF-16, then uploaded as a UTF-8 byte\n     * sequence.\n     * Example: The string 'Hello! \\\\ud83d\\\\ude0a' becomes the byte sequence\n     * 48 65 6c 6c 6f 21 20 f0 9f 98 8a\n     */\n    RAW: 'raw',\n    /**\n     * Indicates the string should be interpreted as base64-encoded data.\n     * Padding characters (trailing '='s) are optional.\n     * Example: The string 'rWmO++E6t7/rlw==' becomes the byte sequence\n     * ad 69 8e fb e1 3a b7 bf eb 97\n     */\n    BASE64: 'base64',\n    /**\n     * Indicates the string should be interpreted as base64url-encoded data.\n     * Padding characters (trailing '='s) are optional.\n     * Example: The string 'rWmO--E6t7_rlw==' becomes the byte sequence\n     * ad 69 8e fb e1 3a b7 bf eb 97\n     */\n    BASE64URL: 'base64url',\n    /**\n     * Indicates the string is a data URL, such as one obtained from\n     * canvas.toDataURL().\n     * Example: the string 'data:application/octet-stream;base64,aaaa'\n     * becomes the byte sequence\n     * 69 a6 9a\n     * (the content-type \"application/octet-stream\" is also applied, but can\n     * be overridden in the metadata object).\n     */\n    DATA_URL: 'data_url'\n};\nclass StringData {\n    constructor(data, contentType) {\n        this.data = data;\n        this.contentType = contentType || null;\n    }\n}\n/**\n * @internal\n */\nfunction dataFromString(format, stringData) {\n    switch (format) {\n        case StringFormat.RAW:\n            return new StringData(utf8Bytes_(stringData));\n        case StringFormat.BASE64:\n        case StringFormat.BASE64URL:\n            return new StringData(base64Bytes_(format, stringData));\n        case StringFormat.DATA_URL:\n            return new StringData(dataURLBytes_(stringData), dataURLContentType_(stringData));\n        // do nothing\n    }\n    // assert(false);\n    throw unknown();\n}\nfunction utf8Bytes_(value) {\n    const b = [];\n    for (let i = 0; i < value.length; i++) {\n        let c = value.charCodeAt(i);\n        if (c <= 127) {\n            b.push(c);\n        }\n        else {\n            if (c <= 2047) {\n                b.push(192 | (c >> 6), 128 | (c & 63));\n            }\n            else {\n                if ((c & 64512) === 55296) {\n                    // The start of a surrogate pair.\n                    const valid = i < value.length - 1 && (value.charCodeAt(i + 1) & 64512) === 56320;\n                    if (!valid) {\n                        // The second surrogate wasn't there.\n                        b.push(239, 191, 189);\n                    }\n                    else {\n                        const hi = c;\n                        const lo = value.charCodeAt(++i);\n                        c = 65536 | ((hi & 1023) << 10) | (lo & 1023);\n                        b.push(240 | (c >> 18), 128 | ((c >> 12) & 63), 128 | ((c >> 6) & 63), 128 | (c & 63));\n                    }\n                }\n                else {\n                    if ((c & 64512) === 56320) {\n                        // Invalid low surrogate.\n                        b.push(239, 191, 189);\n                    }\n                    else {\n                        b.push(224 | (c >> 12), 128 | ((c >> 6) & 63), 128 | (c & 63));\n                    }\n                }\n            }\n        }\n    }\n    return new Uint8Array(b);\n}\nfunction percentEncodedBytes_(value) {\n    let decoded;\n    try {\n        decoded = decodeURIComponent(value);\n    }\n    catch (e) {\n        throw invalidFormat(StringFormat.DATA_URL, 'Malformed data URL.');\n    }\n    return utf8Bytes_(decoded);\n}\nfunction base64Bytes_(format, value) {\n    switch (format) {\n        case StringFormat.BASE64: {\n            const hasMinus = value.indexOf('-') !== -1;\n            const hasUnder = value.indexOf('_') !== -1;\n            if (hasMinus || hasUnder) {\n                const invalidChar = hasMinus ? '-' : '_';\n                throw invalidFormat(format, \"Invalid character '\" +\n                    invalidChar +\n                    \"' found: is it base64url encoded?\");\n            }\n            break;\n        }\n        case StringFormat.BASE64URL: {\n            const hasPlus = value.indexOf('+') !== -1;\n            const hasSlash = value.indexOf('/') !== -1;\n            if (hasPlus || hasSlash) {\n                const invalidChar = hasPlus ? '+' : '/';\n                throw invalidFormat(format, \"Invalid character '\" + invalidChar + \"' found: is it base64 encoded?\");\n            }\n            value = value.replace(/-/g, '+').replace(/_/g, '/');\n            break;\n        }\n        // do nothing\n    }\n    let bytes;\n    try {\n        bytes = decodeBase64(value);\n    }\n    catch (e) {\n        if (e.message.includes('polyfill')) {\n            throw e;\n        }\n        throw invalidFormat(format, 'Invalid character found');\n    }\n    const array = new Uint8Array(bytes.length);\n    for (let i = 0; i < bytes.length; i++) {\n        array[i] = bytes.charCodeAt(i);\n    }\n    return array;\n}\nclass DataURLParts {\n    constructor(dataURL) {\n        this.base64 = false;\n        this.contentType = null;\n        const matches = dataURL.match(/^data:([^,]+)?,/);\n        if (matches === null) {\n            throw invalidFormat(StringFormat.DATA_URL, \"Must be formatted 'data:[<mediatype>][;base64],<data>\");\n        }\n        const middle = matches[1] || null;\n        if (middle != null) {\n            this.base64 = endsWith(middle, ';base64');\n            this.contentType = this.base64\n                ? middle.substring(0, middle.length - ';base64'.length)\n                : middle;\n        }\n        this.rest = dataURL.substring(dataURL.indexOf(',') + 1);\n    }\n}\nfunction dataURLBytes_(dataUrl) {\n    const parts = new DataURLParts(dataUrl);\n    if (parts.base64) {\n        return base64Bytes_(StringFormat.BASE64, parts.rest);\n    }\n    else {\n        return percentEncodedBytes_(parts.rest);\n    }\n}\nfunction dataURLContentType_(dataUrl) {\n    const parts = new DataURLParts(dataUrl);\n    return parts.contentType;\n}\nfunction endsWith(s, end) {\n    const longEnough = s.length >= end.length;\n    if (!longEnough) {\n        return false;\n    }\n    return s.substring(s.length - end.length) === end;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param opt_elideCopy - If true, doesn't copy mutable input data\n *     (e.g. Uint8Arrays). Pass true only if you know the objects will not be\n *     modified after this blob's construction.\n *\n * @internal\n */\nclass FbsBlob {\n    constructor(data, elideCopy) {\n        let size = 0;\n        let blobType = '';\n        if (isNativeBlob(data)) {\n            this.data_ = data;\n            size = data.size;\n            blobType = data.type;\n        }\n        else if (data instanceof ArrayBuffer) {\n            if (elideCopy) {\n                this.data_ = new Uint8Array(data);\n            }\n            else {\n                this.data_ = new Uint8Array(data.byteLength);\n                this.data_.set(new Uint8Array(data));\n            }\n            size = this.data_.length;\n        }\n        else if (data instanceof Uint8Array) {\n            if (elideCopy) {\n                this.data_ = data;\n            }\n            else {\n                this.data_ = new Uint8Array(data.length);\n                this.data_.set(data);\n            }\n            size = data.length;\n        }\n        this.size_ = size;\n        this.type_ = blobType;\n    }\n    size() {\n        return this.size_;\n    }\n    type() {\n        return this.type_;\n    }\n    slice(startByte, endByte) {\n        if (isNativeBlob(this.data_)) {\n            const realBlob = this.data_;\n            const sliced = sliceBlob(realBlob, startByte, endByte);\n            if (sliced === null) {\n                return null;\n            }\n            return new FbsBlob(sliced);\n        }\n        else {\n            const slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);\n            return new FbsBlob(slice, true);\n        }\n    }\n    static getBlob(...args) {\n        if (isNativeBlobDefined()) {\n            const blobby = args.map((val) => {\n                if (val instanceof FbsBlob) {\n                    return val.data_;\n                }\n                else {\n                    return val;\n                }\n            });\n            return new FbsBlob(getBlob$1.apply(null, blobby));\n        }\n        else {\n            const uint8Arrays = args.map((val) => {\n                if (isString(val)) {\n                    return dataFromString(StringFormat.RAW, val).data;\n                }\n                else {\n                    // Blobs don't exist, so this has to be a Uint8Array.\n                    return val.data_;\n                }\n            });\n            let finalLength = 0;\n            uint8Arrays.forEach((array) => {\n                finalLength += array.byteLength;\n            });\n            const merged = new Uint8Array(finalLength);\n            let index = 0;\n            uint8Arrays.forEach((array) => {\n                for (let i = 0; i < array.length; i++) {\n                    merged[index++] = array[i];\n                }\n            });\n            return new FbsBlob(merged, true);\n        }\n    }\n    uploadData() {\n        return this.data_;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns the Object resulting from parsing the given JSON, or null if the\n * given string does not represent a JSON object.\n */\nfunction jsonObjectOrNull(s) {\n    let obj;\n    try {\n        obj = JSON.parse(s);\n    }\n    catch (e) {\n        return null;\n    }\n    if (isNonArrayObject(obj)) {\n        return obj;\n    }\n    else {\n        return null;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Contains helper methods for manipulating paths.\n */\n/**\n * @return Null if the path is already at the root.\n */\nfunction parent(path) {\n    if (path.length === 0) {\n        return null;\n    }\n    const index = path.lastIndexOf('/');\n    if (index === -1) {\n        return '';\n    }\n    const newPath = path.slice(0, index);\n    return newPath;\n}\nfunction child(path, childPath) {\n    const canonicalChildPath = childPath\n        .split('/')\n        .filter(component => component.length > 0)\n        .join('/');\n    if (path.length === 0) {\n        return canonicalChildPath;\n    }\n    else {\n        return path + '/' + canonicalChildPath;\n    }\n}\n/**\n * Returns the last component of a path.\n * '/foo/bar' -> 'bar'\n * '/foo/bar/baz/' -> 'baz/'\n * '/a' -> 'a'\n */\nfunction lastComponent(path) {\n    const index = path.lastIndexOf('/', path.length - 2);\n    if (index === -1) {\n        return path;\n    }\n    else {\n        return path.slice(index + 1);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction noXform_(metadata, value) {\n    return value;\n}\nclass Mapping {\n    constructor(server, local, writable, xform) {\n        this.server = server;\n        this.local = local || server;\n        this.writable = !!writable;\n        this.xform = xform || noXform_;\n    }\n}\nlet mappings_ = null;\nfunction xformPath(fullPath) {\n    if (!isString(fullPath) || fullPath.length < 2) {\n        return fullPath;\n    }\n    else {\n        return lastComponent(fullPath);\n    }\n}\nfunction getMappings() {\n    if (mappings_) {\n        return mappings_;\n    }\n    const mappings = [];\n    mappings.push(new Mapping('bucket'));\n    mappings.push(new Mapping('generation'));\n    mappings.push(new Mapping('metageneration'));\n    mappings.push(new Mapping('name', 'fullPath', true));\n    function mappingsXformPath(_metadata, fullPath) {\n        return xformPath(fullPath);\n    }\n    const nameMapping = new Mapping('name');\n    nameMapping.xform = mappingsXformPath;\n    mappings.push(nameMapping);\n    /**\n     * Coerces the second param to a number, if it is defined.\n     */\n    function xformSize(_metadata, size) {\n        if (size !== undefined) {\n            return Number(size);\n        }\n        else {\n            return size;\n        }\n    }\n    const sizeMapping = new Mapping('size');\n    sizeMapping.xform = xformSize;\n    mappings.push(sizeMapping);\n    mappings.push(new Mapping('timeCreated'));\n    mappings.push(new Mapping('updated'));\n    mappings.push(new Mapping('md5Hash', null, true));\n    mappings.push(new Mapping('cacheControl', null, true));\n    mappings.push(new Mapping('contentDisposition', null, true));\n    mappings.push(new Mapping('contentEncoding', null, true));\n    mappings.push(new Mapping('contentLanguage', null, true));\n    mappings.push(new Mapping('contentType', null, true));\n    mappings.push(new Mapping('metadata', 'customMetadata', true));\n    mappings_ = mappings;\n    return mappings_;\n}\nfunction addRef(metadata, service) {\n    function generateRef() {\n        const bucket = metadata['bucket'];\n        const path = metadata['fullPath'];\n        const loc = new Location(bucket, path);\n        return service._makeStorageReference(loc);\n    }\n    Object.defineProperty(metadata, 'ref', { get: generateRef });\n}\nfunction fromResource(service, resource, mappings) {\n    const metadata = {};\n    metadata['type'] = 'file';\n    const len = mappings.length;\n    for (let i = 0; i < len; i++) {\n        const mapping = mappings[i];\n        metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);\n    }\n    addRef(metadata, service);\n    return metadata;\n}\nfunction fromResourceString(service, resourceString, mappings) {\n    const obj = jsonObjectOrNull(resourceString);\n    if (obj === null) {\n        return null;\n    }\n    const resource = obj;\n    return fromResource(service, resource, mappings);\n}\nfunction downloadUrlFromResourceString(metadata, resourceString, host, protocol) {\n    const obj = jsonObjectOrNull(resourceString);\n    if (obj === null) {\n        return null;\n    }\n    if (!isString(obj['downloadTokens'])) {\n        // This can happen if objects are uploaded through GCS and retrieved\n        // through list, so we don't want to throw an Error.\n        return null;\n    }\n    const tokens = obj['downloadTokens'];\n    if (tokens.length === 0) {\n        return null;\n    }\n    const encode = encodeURIComponent;\n    const tokensList = tokens.split(',');\n    const urls = tokensList.map((token) => {\n        const bucket = metadata['bucket'];\n        const path = metadata['fullPath'];\n        const urlPart = '/b/' + encode(bucket) + '/o/' + encode(path);\n        const base = makeUrl(urlPart, host, protocol);\n        const queryString = makeQueryString({\n            alt: 'media',\n            token\n        });\n        return base + queryString;\n    });\n    return urls[0];\n}\nfunction toResourceString(metadata, mappings) {\n    const resource = {};\n    const len = mappings.length;\n    for (let i = 0; i < len; i++) {\n        const mapping = mappings[i];\n        if (mapping.writable) {\n            resource[mapping.server] = metadata[mapping.local];\n        }\n    }\n    return JSON.stringify(resource);\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst PREFIXES_KEY = 'prefixes';\nconst ITEMS_KEY = 'items';\nfunction fromBackendResponse(service, bucket, resource) {\n    const listResult = {\n        prefixes: [],\n        items: [],\n        nextPageToken: resource['nextPageToken']\n    };\n    if (resource[PREFIXES_KEY]) {\n        for (const path of resource[PREFIXES_KEY]) {\n            const pathWithoutTrailingSlash = path.replace(/\\/$/, '');\n            const reference = service._makeStorageReference(new Location(bucket, pathWithoutTrailingSlash));\n            listResult.prefixes.push(reference);\n        }\n    }\n    if (resource[ITEMS_KEY]) {\n        for (const item of resource[ITEMS_KEY]) {\n            const reference = service._makeStorageReference(new Location(bucket, item['name']));\n            listResult.items.push(reference);\n        }\n    }\n    return listResult;\n}\nfunction fromResponseString(service, bucket, resourceString) {\n    const obj = jsonObjectOrNull(resourceString);\n    if (obj === null) {\n        return null;\n    }\n    const resource = obj;\n    return fromBackendResponse(service, bucket, resource);\n}\n\n/**\n * Contains a fully specified request.\n *\n * @param I - the type of the backend's network response.\n * @param O - the output response type used by the rest of the SDK.\n */\nclass RequestInfo {\n    constructor(url, method, \n    /**\n     * Returns the value with which to resolve the request's promise. Only called\n     * if the request is successful. Throw from this function to reject the\n     * returned Request's promise with the thrown error.\n     * Note: The XhrIo passed to this function may be reused after this callback\n     * returns. Do not keep a reference to it in any way.\n     */\n    handler, timeout) {\n        this.url = url;\n        this.method = method;\n        this.handler = handler;\n        this.timeout = timeout;\n        this.urlParams = {};\n        this.headers = {};\n        this.body = null;\n        this.errorHandler = null;\n        /**\n         * Called with the current number of bytes uploaded and total size (-1 if not\n         * computable) of the request body (i.e. used to report upload progress).\n         */\n        this.progressCallback = null;\n        this.successCodes = [200];\n        this.additionalRetryCodes = [];\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Throws the UNKNOWN StorageError if cndn is false.\n */\nfunction handlerCheck(cndn) {\n    if (!cndn) {\n        throw unknown();\n    }\n}\nfunction metadataHandler(service, mappings) {\n    function handler(xhr, text) {\n        const metadata = fromResourceString(service, text, mappings);\n        handlerCheck(metadata !== null);\n        return metadata;\n    }\n    return handler;\n}\nfunction listHandler(service, bucket) {\n    function handler(xhr, text) {\n        const listResult = fromResponseString(service, bucket, text);\n        handlerCheck(listResult !== null);\n        return listResult;\n    }\n    return handler;\n}\nfunction downloadUrlHandler(service, mappings) {\n    function handler(xhr, text) {\n        const metadata = fromResourceString(service, text, mappings);\n        handlerCheck(metadata !== null);\n        return downloadUrlFromResourceString(metadata, text, service.host, service._protocol);\n    }\n    return handler;\n}\nfunction sharedErrorHandler(location) {\n    function errorHandler(xhr, err) {\n        let newErr;\n        if (xhr.getStatus() === 401) {\n            if (\n            // This exact message string is the only consistent part of the\n            // server's error response that identifies it as an App Check error.\n            xhr.getErrorText().includes('Firebase App Check token is invalid')) {\n                newErr = unauthorizedApp();\n            }\n            else {\n                newErr = unauthenticated();\n            }\n        }\n        else {\n            if (xhr.getStatus() === 402) {\n                newErr = quotaExceeded(location.bucket);\n            }\n            else {\n                if (xhr.getStatus() === 403) {\n                    newErr = unauthorized(location.path);\n                }\n                else {\n                    newErr = err;\n                }\n            }\n        }\n        newErr.status = xhr.getStatus();\n        newErr.serverResponse = err.serverResponse;\n        return newErr;\n    }\n    return errorHandler;\n}\nfunction objectErrorHandler(location) {\n    const shared = sharedErrorHandler(location);\n    function errorHandler(xhr, err) {\n        let newErr = shared(xhr, err);\n        if (xhr.getStatus() === 404) {\n            newErr = objectNotFound(location.path);\n        }\n        newErr.serverResponse = err.serverResponse;\n        return newErr;\n    }\n    return errorHandler;\n}\nfunction getMetadata$2(service, location, mappings) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'GET';\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nfunction list$2(service, location, delimiter, pageToken, maxResults) {\n    const urlParams = {};\n    if (location.isRoot) {\n        urlParams['prefix'] = '';\n    }\n    else {\n        urlParams['prefix'] = location.path + '/';\n    }\n    if (delimiter && delimiter.length > 0) {\n        urlParams['delimiter'] = delimiter;\n    }\n    if (pageToken) {\n        urlParams['pageToken'] = pageToken;\n    }\n    if (maxResults) {\n        urlParams['maxResults'] = maxResults;\n    }\n    const urlPart = location.bucketOnlyServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'GET';\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, listHandler(service, location.bucket), timeout);\n    requestInfo.urlParams = urlParams;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\nfunction getBytes$1(service, location, maxDownloadSizeBytes) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol) + '?alt=media';\n    const method = 'GET';\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, (_, data) => data, timeout);\n    requestInfo.errorHandler = objectErrorHandler(location);\n    if (maxDownloadSizeBytes !== undefined) {\n        requestInfo.headers['Range'] = `bytes=0-${maxDownloadSizeBytes}`;\n        requestInfo.successCodes = [200 /* OK */, 206 /* Partial Content */];\n    }\n    return requestInfo;\n}\nfunction getDownloadUrl(service, location, mappings) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'GET';\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, downloadUrlHandler(service, mappings), timeout);\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nfunction updateMetadata$2(service, location, metadata, mappings) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'PATCH';\n    const body = toResourceString(metadata, mappings);\n    const headers = { 'Content-Type': 'application/json; charset=utf-8' };\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);\n    requestInfo.headers = headers;\n    requestInfo.body = body;\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nfunction deleteObject$2(service, location) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'DELETE';\n    const timeout = service.maxOperationRetryTime;\n    function handler(_xhr, _text) { }\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.successCodes = [200, 204];\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nfunction determineContentType_(metadata, blob) {\n    return ((metadata && metadata['contentType']) ||\n        (blob && blob.type()) ||\n        'application/octet-stream');\n}\nfunction metadataForUpload_(location, blob, metadata) {\n    const metadataClone = Object.assign({}, metadata);\n    metadataClone['fullPath'] = location.path;\n    metadataClone['size'] = blob.size();\n    if (!metadataClone['contentType']) {\n        metadataClone['contentType'] = determineContentType_(null, blob);\n    }\n    return metadataClone;\n}\n/**\n * Prepare RequestInfo for uploads as Content-Type: multipart.\n */\nfunction multipartUpload(service, location, mappings, blob, metadata) {\n    const urlPart = location.bucketOnlyServerUrl();\n    const headers = {\n        'X-Goog-Upload-Protocol': 'multipart'\n    };\n    function genBoundary() {\n        let str = '';\n        for (let i = 0; i < 2; i++) {\n            str = str + Math.random().toString().slice(2);\n        }\n        return str;\n    }\n    const boundary = genBoundary();\n    headers['Content-Type'] = 'multipart/related; boundary=' + boundary;\n    const metadata_ = metadataForUpload_(location, blob, metadata);\n    const metadataString = toResourceString(metadata_, mappings);\n    const preBlobPart = '--' +\n        boundary +\n        '\\r\\n' +\n        'Content-Type: application/json; charset=utf-8\\r\\n\\r\\n' +\n        metadataString +\n        '\\r\\n--' +\n        boundary +\n        '\\r\\n' +\n        'Content-Type: ' +\n        metadata_['contentType'] +\n        '\\r\\n\\r\\n';\n    const postBlobPart = '\\r\\n--' + boundary + '--';\n    const body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);\n    if (body === null) {\n        throw cannotSliceBlob();\n    }\n    const urlParams = { name: metadata_['fullPath'] };\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'POST';\n    const timeout = service.maxUploadRetryTime;\n    const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);\n    requestInfo.urlParams = urlParams;\n    requestInfo.headers = headers;\n    requestInfo.body = body.uploadData();\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\n * @param current The number of bytes that have been uploaded so far.\n * @param total The total number of bytes in the upload.\n * @param opt_finalized True if the server has finished the upload.\n * @param opt_metadata The upload metadata, should\n *     only be passed if opt_finalized is true.\n */\nclass ResumableUploadStatus {\n    constructor(current, total, finalized, metadata) {\n        this.current = current;\n        this.total = total;\n        this.finalized = !!finalized;\n        this.metadata = metadata || null;\n    }\n}\nfunction checkResumeHeader_(xhr, allowed) {\n    let status = null;\n    try {\n        status = xhr.getResponseHeader('X-Goog-Upload-Status');\n    }\n    catch (e) {\n        handlerCheck(false);\n    }\n    const allowedStatus = allowed || ['active'];\n    handlerCheck(!!status && allowedStatus.indexOf(status) !== -1);\n    return status;\n}\nfunction createResumableUpload(service, location, mappings, blob, metadata) {\n    const urlPart = location.bucketOnlyServerUrl();\n    const metadataForUpload = metadataForUpload_(location, blob, metadata);\n    const urlParams = { name: metadataForUpload['fullPath'] };\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'POST';\n    const headers = {\n        'X-Goog-Upload-Protocol': 'resumable',\n        'X-Goog-Upload-Command': 'start',\n        'X-Goog-Upload-Header-Content-Length': `${blob.size()}`,\n        'X-Goog-Upload-Header-Content-Type': metadataForUpload['contentType'],\n        'Content-Type': 'application/json; charset=utf-8'\n    };\n    const body = toResourceString(metadataForUpload, mappings);\n    const timeout = service.maxUploadRetryTime;\n    function handler(xhr) {\n        checkResumeHeader_(xhr);\n        let url;\n        try {\n            url = xhr.getResponseHeader('X-Goog-Upload-URL');\n        }\n        catch (e) {\n            handlerCheck(false);\n        }\n        handlerCheck(isString(url));\n        return url;\n    }\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.urlParams = urlParams;\n    requestInfo.headers = headers;\n    requestInfo.body = body;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n */\nfunction getResumableUploadStatus(service, location, url, blob) {\n    const headers = { 'X-Goog-Upload-Command': 'query' };\n    function handler(xhr) {\n        const status = checkResumeHeader_(xhr, ['active', 'final']);\n        let sizeString = null;\n        try {\n            sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');\n        }\n        catch (e) {\n            handlerCheck(false);\n        }\n        if (!sizeString) {\n            // null or empty string\n            handlerCheck(false);\n        }\n        const size = Number(sizeString);\n        handlerCheck(!isNaN(size));\n        return new ResumableUploadStatus(size, blob.size(), status === 'final');\n    }\n    const method = 'POST';\n    const timeout = service.maxUploadRetryTime;\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.headers = headers;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\n * Any uploads via the resumable upload API must transfer a number of bytes\n * that is a multiple of this number.\n */\nconst RESUMABLE_UPLOAD_CHUNK_SIZE = 256 * 1024;\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n * @param chunkSize Number of bytes to upload.\n * @param status The previous status.\n *     If not passed or null, we start from the beginning.\n * @throws fbs.Error If the upload is already complete, the passed in status\n *     has a final size inconsistent with the blob, or the blob cannot be sliced\n *     for upload.\n */\nfunction continueResumableUpload(location, service, url, blob, chunkSize, mappings, status, progressCallback) {\n    // TODO(andysoto): standardize on internal asserts\n    // assert(!(opt_status && opt_status.finalized));\n    const status_ = new ResumableUploadStatus(0, 0);\n    if (status) {\n        status_.current = status.current;\n        status_.total = status.total;\n    }\n    else {\n        status_.current = 0;\n        status_.total = blob.size();\n    }\n    if (blob.size() !== status_.total) {\n        throw serverFileWrongSize();\n    }\n    const bytesLeft = status_.total - status_.current;\n    let bytesToUpload = bytesLeft;\n    if (chunkSize > 0) {\n        bytesToUpload = Math.min(bytesToUpload, chunkSize);\n    }\n    const startByte = status_.current;\n    const endByte = startByte + bytesToUpload;\n    let uploadCommand = '';\n    if (bytesToUpload === 0) {\n        uploadCommand = 'finalize';\n    }\n    else if (bytesLeft === bytesToUpload) {\n        uploadCommand = 'upload, finalize';\n    }\n    else {\n        uploadCommand = 'upload';\n    }\n    const headers = {\n        'X-Goog-Upload-Command': uploadCommand,\n        'X-Goog-Upload-Offset': `${status_.current}`\n    };\n    const body = blob.slice(startByte, endByte);\n    if (body === null) {\n        throw cannotSliceBlob();\n    }\n    function handler(xhr, text) {\n        // TODO(andysoto): Verify the MD5 of each uploaded range:\n        // the 'x-range-md5' header comes back with status code 308 responses.\n        // We'll only be able to bail out though, because you can't re-upload a\n        // range that you previously uploaded.\n        const uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);\n        const newCurrent = status_.current + bytesToUpload;\n        const size = blob.size();\n        let metadata;\n        if (uploadStatus === 'final') {\n            metadata = metadataHandler(service, mappings)(xhr, text);\n        }\n        else {\n            metadata = null;\n        }\n        return new ResumableUploadStatus(newCurrent, size, uploadStatus === 'final', metadata);\n    }\n    const method = 'POST';\n    const timeout = service.maxUploadRetryTime;\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.headers = headers;\n    requestInfo.body = body.uploadData();\n    requestInfo.progressCallback = progressCallback || null;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An event that is triggered on a task.\n * @internal\n */\nconst TaskEvent = {\n    /**\n     * For this event,\n     * <ul>\n     *   <li>The `next` function is triggered on progress updates and when the\n     *       task is paused/resumed with an `UploadTaskSnapshot` as the first\n     *       argument.</li>\n     *   <li>The `error` function is triggered if the upload is canceled or fails\n     *       for another reason.</li>\n     *   <li>The `complete` function is triggered if the upload completes\n     *       successfully.</li>\n     * </ul>\n     */\n    STATE_CHANGED: 'state_changed'\n};\n// type keys = keyof TaskState\n/**\n * Represents the current state of a running upload.\n * @internal\n */\nconst TaskState = {\n    /** The task is currently transferring data. */\n    RUNNING: 'running',\n    /** The task was paused by the user. */\n    PAUSED: 'paused',\n    /** The task completed successfully. */\n    SUCCESS: 'success',\n    /** The task was canceled. */\n    CANCELED: 'canceled',\n    /** The task failed with an error. */\n    ERROR: 'error'\n};\nfunction taskStateFromInternalTaskState(state) {\n    switch (state) {\n        case \"running\" /* InternalTaskState.RUNNING */:\n        case \"pausing\" /* InternalTaskState.PAUSING */:\n        case \"canceling\" /* InternalTaskState.CANCELING */:\n            return TaskState.RUNNING;\n        case \"paused\" /* InternalTaskState.PAUSED */:\n            return TaskState.PAUSED;\n        case \"success\" /* InternalTaskState.SUCCESS */:\n            return TaskState.SUCCESS;\n        case \"canceled\" /* InternalTaskState.CANCELED */:\n            return TaskState.CANCELED;\n        case \"error\" /* InternalTaskState.ERROR */:\n            return TaskState.ERROR;\n        default:\n            // TODO(andysoto): assert(false);\n            return TaskState.ERROR;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Observer {\n    constructor(nextOrObserver, error, complete) {\n        const asFunctions = isFunction(nextOrObserver) || error != null || complete != null;\n        if (asFunctions) {\n            this.next = nextOrObserver;\n            this.error = error ?? undefined;\n            this.complete = complete ?? undefined;\n        }\n        else {\n            const observer = nextOrObserver;\n            this.next = observer.next;\n            this.error = observer.error;\n            this.complete = observer.complete;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a function that invokes f with its arguments asynchronously as a\n * microtask, i.e. as soon as possible after the current script returns back\n * into browser code.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction async(f) {\n    return (...argsToForward) => {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        Promise.resolve().then(() => f(...argsToForward));\n    };\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** An override for the text-based Connection. Used in tests. */\nlet textFactoryOverride = null;\n/**\n * Network layer for browsers. We use this instead of goog.net.XhrIo because\n * goog.net.XhrIo is hyuuuuge and doesn't work in React Native on Android.\n */\nclass XhrConnection {\n    constructor() {\n        this.sent_ = false;\n        this.xhr_ = new XMLHttpRequest();\n        this.initXhr();\n        this.errorCode_ = ErrorCode.NO_ERROR;\n        this.sendPromise_ = new Promise(resolve => {\n            this.xhr_.addEventListener('abort', () => {\n                this.errorCode_ = ErrorCode.ABORT;\n                resolve();\n            });\n            this.xhr_.addEventListener('error', () => {\n                this.errorCode_ = ErrorCode.NETWORK_ERROR;\n                resolve();\n            });\n            this.xhr_.addEventListener('load', () => {\n                resolve();\n            });\n        });\n    }\n    send(url, method, isUsingEmulator, body, headers) {\n        if (this.sent_) {\n            throw internalError('cannot .send() more than once');\n        }\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isCloudWorkstation)(url) && isUsingEmulator) {\n            this.xhr_.withCredentials = true;\n        }\n        this.sent_ = true;\n        this.xhr_.open(method, url, true);\n        if (headers !== undefined) {\n            for (const key in headers) {\n                if (headers.hasOwnProperty(key)) {\n                    this.xhr_.setRequestHeader(key, headers[key].toString());\n                }\n            }\n        }\n        if (body !== undefined) {\n            this.xhr_.send(body);\n        }\n        else {\n            this.xhr_.send();\n        }\n        return this.sendPromise_;\n    }\n    getErrorCode() {\n        if (!this.sent_) {\n            throw internalError('cannot .getErrorCode() before sending');\n        }\n        return this.errorCode_;\n    }\n    getStatus() {\n        if (!this.sent_) {\n            throw internalError('cannot .getStatus() before sending');\n        }\n        try {\n            return this.xhr_.status;\n        }\n        catch (e) {\n            return -1;\n        }\n    }\n    getResponse() {\n        if (!this.sent_) {\n            throw internalError('cannot .getResponse() before sending');\n        }\n        return this.xhr_.response;\n    }\n    getErrorText() {\n        if (!this.sent_) {\n            throw internalError('cannot .getErrorText() before sending');\n        }\n        return this.xhr_.statusText;\n    }\n    /** Aborts the request. */\n    abort() {\n        this.xhr_.abort();\n    }\n    getResponseHeader(header) {\n        return this.xhr_.getResponseHeader(header);\n    }\n    addUploadProgressListener(listener) {\n        if (this.xhr_.upload != null) {\n            this.xhr_.upload.addEventListener('progress', listener);\n        }\n    }\n    removeUploadProgressListener(listener) {\n        if (this.xhr_.upload != null) {\n            this.xhr_.upload.removeEventListener('progress', listener);\n        }\n    }\n}\nclass XhrTextConnection extends XhrConnection {\n    initXhr() {\n        this.xhr_.responseType = 'text';\n    }\n}\nfunction newTextConnection() {\n    return textFactoryOverride ? textFactoryOverride() : new XhrTextConnection();\n}\nclass XhrBytesConnection extends XhrConnection {\n    initXhr() {\n        this.xhr_.responseType = 'arraybuffer';\n    }\n}\nfunction newBytesConnection() {\n    return new XhrBytesConnection();\n}\nclass XhrBlobConnection extends XhrConnection {\n    initXhr() {\n        this.xhr_.responseType = 'blob';\n    }\n}\nfunction newBlobConnection() {\n    return new XhrBlobConnection();\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a blob being uploaded. Can be used to pause/resume/cancel the\n * upload and manage callbacks for various events.\n * @internal\n */\nclass UploadTask {\n    isExponentialBackoffExpired() {\n        return this.sleepTime > this.maxSleepTime;\n    }\n    /**\n     * @param ref - The firebaseStorage.Reference object this task came\n     *     from, untyped to avoid cyclic dependencies.\n     * @param blob - The blob to upload.\n     */\n    constructor(ref, blob, metadata = null) {\n        /**\n         * Number of bytes transferred so far.\n         */\n        this._transferred = 0;\n        this._needToFetchStatus = false;\n        this._needToFetchMetadata = false;\n        this._observers = [];\n        this._error = undefined;\n        this._uploadUrl = undefined;\n        this._request = undefined;\n        this._chunkMultiplier = 1;\n        this._resolve = undefined;\n        this._reject = undefined;\n        this._ref = ref;\n        this._blob = blob;\n        this._metadata = metadata;\n        this._mappings = getMappings();\n        this._resumable = this._shouldDoResumable(this._blob);\n        this._state = \"running\" /* InternalTaskState.RUNNING */;\n        this._errorHandler = error => {\n            this._request = undefined;\n            this._chunkMultiplier = 1;\n            if (error._codeEquals(StorageErrorCode.CANCELED)) {\n                this._needToFetchStatus = true;\n                this.completeTransitions_();\n            }\n            else {\n                const backoffExpired = this.isExponentialBackoffExpired();\n                if (isRetryStatusCode(error.status, [])) {\n                    if (backoffExpired) {\n                        error = retryLimitExceeded();\n                    }\n                    else {\n                        this.sleepTime = Math.max(this.sleepTime * 2, DEFAULT_MIN_SLEEP_TIME_MILLIS);\n                        this._needToFetchStatus = true;\n                        this.completeTransitions_();\n                        return;\n                    }\n                }\n                this._error = error;\n                this._transition(\"error\" /* InternalTaskState.ERROR */);\n            }\n        };\n        this._metadataErrorHandler = error => {\n            this._request = undefined;\n            if (error._codeEquals(StorageErrorCode.CANCELED)) {\n                this.completeTransitions_();\n            }\n            else {\n                this._error = error;\n                this._transition(\"error\" /* InternalTaskState.ERROR */);\n            }\n        };\n        this.sleepTime = 0;\n        this.maxSleepTime = this._ref.storage.maxUploadRetryTime;\n        this._promise = new Promise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n            this._start();\n        });\n        // Prevent uncaught rejections on the internal promise from bubbling out\n        // to the top level with a dummy handler.\n        this._promise.then(null, () => { });\n    }\n    _makeProgressCallback() {\n        const sizeBefore = this._transferred;\n        return loaded => this._updateProgress(sizeBefore + loaded);\n    }\n    _shouldDoResumable(blob) {\n        return blob.size() > 256 * 1024;\n    }\n    _start() {\n        if (this._state !== \"running\" /* InternalTaskState.RUNNING */) {\n            // This can happen if someone pauses us in a resume callback, for example.\n            return;\n        }\n        if (this._request !== undefined) {\n            return;\n        }\n        if (this._resumable) {\n            if (this._uploadUrl === undefined) {\n                this._createResumable();\n            }\n            else {\n                if (this._needToFetchStatus) {\n                    this._fetchStatus();\n                }\n                else {\n                    if (this._needToFetchMetadata) {\n                        // Happens if we miss the metadata on upload completion.\n                        this._fetchMetadata();\n                    }\n                    else {\n                        this.pendingTimeout = setTimeout(() => {\n                            this.pendingTimeout = undefined;\n                            this._continueUpload();\n                        }, this.sleepTime);\n                    }\n                }\n            }\n        }\n        else {\n            this._oneShotUpload();\n        }\n    }\n    _resolveToken(callback) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        Promise.all([\n            this._ref.storage._getAuthToken(),\n            this._ref.storage._getAppCheckToken()\n        ]).then(([authToken, appCheckToken]) => {\n            switch (this._state) {\n                case \"running\" /* InternalTaskState.RUNNING */:\n                    callback(authToken, appCheckToken);\n                    break;\n                case \"canceling\" /* InternalTaskState.CANCELING */:\n                    this._transition(\"canceled\" /* InternalTaskState.CANCELED */);\n                    break;\n                case \"pausing\" /* InternalTaskState.PAUSING */:\n                    this._transition(\"paused\" /* InternalTaskState.PAUSED */);\n                    break;\n            }\n        });\n    }\n    // TODO(andysoto): assert false\n    _createResumable() {\n        this._resolveToken((authToken, appCheckToken) => {\n            const requestInfo = createResumableUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);\n            const createRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\n            this._request = createRequest;\n            createRequest.getPromise().then((url) => {\n                this._request = undefined;\n                this._uploadUrl = url;\n                this._needToFetchStatus = false;\n                this.completeTransitions_();\n            }, this._errorHandler);\n        });\n    }\n    _fetchStatus() {\n        // TODO(andysoto): assert(this.uploadUrl_ !== null);\n        const url = this._uploadUrl;\n        this._resolveToken((authToken, appCheckToken) => {\n            const requestInfo = getResumableUploadStatus(this._ref.storage, this._ref._location, url, this._blob);\n            const statusRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\n            this._request = statusRequest;\n            statusRequest.getPromise().then(status => {\n                status = status;\n                this._request = undefined;\n                this._updateProgress(status.current);\n                this._needToFetchStatus = false;\n                if (status.finalized) {\n                    this._needToFetchMetadata = true;\n                }\n                this.completeTransitions_();\n            }, this._errorHandler);\n        });\n    }\n    _continueUpload() {\n        const chunkSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;\n        const status = new ResumableUploadStatus(this._transferred, this._blob.size());\n        // TODO(andysoto): assert(this.uploadUrl_ !== null);\n        const url = this._uploadUrl;\n        this._resolveToken((authToken, appCheckToken) => {\n            let requestInfo;\n            try {\n                requestInfo = continueResumableUpload(this._ref._location, this._ref.storage, url, this._blob, chunkSize, this._mappings, status, this._makeProgressCallback());\n            }\n            catch (e) {\n                this._error = e;\n                this._transition(\"error\" /* InternalTaskState.ERROR */);\n                return;\n            }\n            const uploadRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken, \n            /*retry=*/ false // Upload requests should not be retried as each retry should be preceded by another query request. Which is handled in this file.\n            );\n            this._request = uploadRequest;\n            uploadRequest.getPromise().then((newStatus) => {\n                this._increaseMultiplier();\n                this._request = undefined;\n                this._updateProgress(newStatus.current);\n                if (newStatus.finalized) {\n                    this._metadata = newStatus.metadata;\n                    this._transition(\"success\" /* InternalTaskState.SUCCESS */);\n                }\n                else {\n                    this.completeTransitions_();\n                }\n            }, this._errorHandler);\n        });\n    }\n    _increaseMultiplier() {\n        const currentSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;\n        // Max chunk size is 32M.\n        if (currentSize * 2 < 32 * 1024 * 1024) {\n            this._chunkMultiplier *= 2;\n        }\n    }\n    _fetchMetadata() {\n        this._resolveToken((authToken, appCheckToken) => {\n            const requestInfo = getMetadata$2(this._ref.storage, this._ref._location, this._mappings);\n            const metadataRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\n            this._request = metadataRequest;\n            metadataRequest.getPromise().then(metadata => {\n                this._request = undefined;\n                this._metadata = metadata;\n                this._transition(\"success\" /* InternalTaskState.SUCCESS */);\n            }, this._metadataErrorHandler);\n        });\n    }\n    _oneShotUpload() {\n        this._resolveToken((authToken, appCheckToken) => {\n            const requestInfo = multipartUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);\n            const multipartRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\n            this._request = multipartRequest;\n            multipartRequest.getPromise().then(metadata => {\n                this._request = undefined;\n                this._metadata = metadata;\n                this._updateProgress(this._blob.size());\n                this._transition(\"success\" /* InternalTaskState.SUCCESS */);\n            }, this._errorHandler);\n        });\n    }\n    _updateProgress(transferred) {\n        const old = this._transferred;\n        this._transferred = transferred;\n        // A progress update can make the \"transferred\" value smaller (e.g. a\n        // partial upload not completed by server, after which the \"transferred\"\n        // value may reset to the value at the beginning of the request).\n        if (this._transferred !== old) {\n            this._notifyObservers();\n        }\n    }\n    _transition(state) {\n        if (this._state === state) {\n            return;\n        }\n        switch (state) {\n            case \"canceling\" /* InternalTaskState.CANCELING */:\n            case \"pausing\" /* InternalTaskState.PAUSING */:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING ||\n                //        this.state_ === InternalTaskState.PAUSING);\n                this._state = state;\n                if (this._request !== undefined) {\n                    this._request.cancel();\n                }\n                else if (this.pendingTimeout) {\n                    clearTimeout(this.pendingTimeout);\n                    this.pendingTimeout = undefined;\n                    this.completeTransitions_();\n                }\n                break;\n            case \"running\" /* InternalTaskState.RUNNING */:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.PAUSED ||\n                //        this.state_ === InternalTaskState.PAUSING);\n                const wasPaused = this._state === \"paused\" /* InternalTaskState.PAUSED */;\n                this._state = state;\n                if (wasPaused) {\n                    this._notifyObservers();\n                    this._start();\n                }\n                break;\n            case \"paused\" /* InternalTaskState.PAUSED */:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.PAUSING);\n                this._state = state;\n                this._notifyObservers();\n                break;\n            case \"canceled\" /* InternalTaskState.CANCELED */:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.PAUSED ||\n                //        this.state_ === InternalTaskState.CANCELING);\n                this._error = canceled();\n                this._state = state;\n                this._notifyObservers();\n                break;\n            case \"error\" /* InternalTaskState.ERROR */:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING ||\n                //        this.state_ === InternalTaskState.PAUSING ||\n                //        this.state_ === InternalTaskState.CANCELING);\n                this._state = state;\n                this._notifyObservers();\n                break;\n            case \"success\" /* InternalTaskState.SUCCESS */:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING ||\n                //        this.state_ === InternalTaskState.PAUSING ||\n                //        this.state_ === InternalTaskState.CANCELING);\n                this._state = state;\n                this._notifyObservers();\n                break;\n        }\n    }\n    completeTransitions_() {\n        switch (this._state) {\n            case \"pausing\" /* InternalTaskState.PAUSING */:\n                this._transition(\"paused\" /* InternalTaskState.PAUSED */);\n                break;\n            case \"canceling\" /* InternalTaskState.CANCELING */:\n                this._transition(\"canceled\" /* InternalTaskState.CANCELED */);\n                break;\n            case \"running\" /* InternalTaskState.RUNNING */:\n                this._start();\n                break;\n        }\n    }\n    /**\n     * A snapshot of the current task state.\n     */\n    get snapshot() {\n        const externalState = taskStateFromInternalTaskState(this._state);\n        return {\n            bytesTransferred: this._transferred,\n            totalBytes: this._blob.size(),\n            state: externalState,\n            metadata: this._metadata,\n            task: this,\n            ref: this._ref\n        };\n    }\n    /**\n     * Adds a callback for an event.\n     * @param type - The type of event to listen for.\n     * @param nextOrObserver -\n     *     The `next` function, which gets called for each item in\n     *     the event stream, or an observer object with some or all of these three\n     *     properties (`next`, `error`, `complete`).\n     * @param error - A function that gets called with a `StorageError`\n     *     if the event stream ends due to an error.\n     * @param completed - A function that gets called if the\n     *     event stream ends normally.\n     * @returns\n     *     If only the event argument is passed, returns a function you can use to\n     *     add callbacks (see the examples above). If more than just the event\n     *     argument is passed, returns a function you can call to unregister the\n     *     callbacks.\n     */\n    on(type, nextOrObserver, error, completed) {\n        // Note: `type` isn't being used. Its type is also incorrect. TaskEvent should not be a string.\n        const observer = new Observer(nextOrObserver || undefined, error || undefined, completed || undefined);\n        this._addObserver(observer);\n        return () => {\n            this._removeObserver(observer);\n        };\n    }\n    /**\n     * This object behaves like a Promise, and resolves with its snapshot data\n     * when the upload completes.\n     * @param onFulfilled - The fulfillment callback. Promise chaining works as normal.\n     * @param onRejected - The rejection callback.\n     */\n    then(onFulfilled, onRejected) {\n        // These casts are needed so that TypeScript can infer the types of the\n        // resulting Promise.\n        return this._promise.then(onFulfilled, onRejected);\n    }\n    /**\n     * Equivalent to calling `then(null, onRejected)`.\n     */\n    catch(onRejected) {\n        return this.then(null, onRejected);\n    }\n    /**\n     * Adds the given observer.\n     */\n    _addObserver(observer) {\n        this._observers.push(observer);\n        this._notifyObserver(observer);\n    }\n    /**\n     * Removes the given observer.\n     */\n    _removeObserver(observer) {\n        const i = this._observers.indexOf(observer);\n        if (i !== -1) {\n            this._observers.splice(i, 1);\n        }\n    }\n    _notifyObservers() {\n        this._finishPromise();\n        const observers = this._observers.slice();\n        observers.forEach(observer => {\n            this._notifyObserver(observer);\n        });\n    }\n    _finishPromise() {\n        if (this._resolve !== undefined) {\n            let triggered = true;\n            switch (taskStateFromInternalTaskState(this._state)) {\n                case TaskState.SUCCESS:\n                    async(this._resolve.bind(null, this.snapshot))();\n                    break;\n                case TaskState.CANCELED:\n                case TaskState.ERROR:\n                    const toCall = this._reject;\n                    async(toCall.bind(null, this._error))();\n                    break;\n                default:\n                    triggered = false;\n                    break;\n            }\n            if (triggered) {\n                this._resolve = undefined;\n                this._reject = undefined;\n            }\n        }\n    }\n    _notifyObserver(observer) {\n        const externalState = taskStateFromInternalTaskState(this._state);\n        switch (externalState) {\n            case TaskState.RUNNING:\n            case TaskState.PAUSED:\n                if (observer.next) {\n                    async(observer.next.bind(observer, this.snapshot))();\n                }\n                break;\n            case TaskState.SUCCESS:\n                if (observer.complete) {\n                    async(observer.complete.bind(observer))();\n                }\n                break;\n            case TaskState.CANCELED:\n            case TaskState.ERROR:\n                if (observer.error) {\n                    async(observer.error.bind(observer, this._error))();\n                }\n                break;\n            default:\n                // TODO(andysoto): assert(false);\n                if (observer.error) {\n                    async(observer.error.bind(observer, this._error))();\n                }\n        }\n    }\n    /**\n     * Resumes a paused task. Has no effect on a currently running or failed task.\n     * @returns True if the operation took effect, false if ignored.\n     */\n    resume() {\n        const valid = this._state === \"paused\" /* InternalTaskState.PAUSED */ ||\n            this._state === \"pausing\" /* InternalTaskState.PAUSING */;\n        if (valid) {\n            this._transition(\"running\" /* InternalTaskState.RUNNING */);\n        }\n        return valid;\n    }\n    /**\n     * Pauses a currently running task. Has no effect on a paused or failed task.\n     * @returns True if the operation took effect, false if ignored.\n     */\n    pause() {\n        const valid = this._state === \"running\" /* InternalTaskState.RUNNING */;\n        if (valid) {\n            this._transition(\"pausing\" /* InternalTaskState.PAUSING */);\n        }\n        return valid;\n    }\n    /**\n     * Cancels a currently running or paused task. Has no effect on a complete or\n     * failed task.\n     * @returns True if the operation took effect, false if ignored.\n     */\n    cancel() {\n        const valid = this._state === \"running\" /* InternalTaskState.RUNNING */ ||\n            this._state === \"pausing\" /* InternalTaskState.PAUSING */;\n        if (valid) {\n            this._transition(\"canceling\" /* InternalTaskState.CANCELING */);\n        }\n        return valid;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides methods to interact with a bucket in the Firebase Storage service.\n * @internal\n * @param _location - An fbs.location, or the URL at\n *     which to base this object, in one of the following forms:\n *         gs://<bucket>/<object-path>\n *         http[s]://firebasestorage.googleapis.com/\n *                     <api-version>/b/<bucket>/o/<object-path>\n *     Any query or fragment strings will be ignored in the http[s]\n *     format. If no value is passed, the storage object will use a URL based on\n *     the project ID of the base firebase.App instance.\n */\nclass Reference {\n    constructor(_service, location) {\n        this._service = _service;\n        if (location instanceof Location) {\n            this._location = location;\n        }\n        else {\n            this._location = Location.makeFromUrl(location, _service.host);\n        }\n    }\n    /**\n     * Returns the URL for the bucket and path this object references,\n     *     in the form gs://<bucket>/<object-path>\n     * @override\n     */\n    toString() {\n        return 'gs://' + this._location.bucket + '/' + this._location.path;\n    }\n    _newRef(service, location) {\n        return new Reference(service, location);\n    }\n    /**\n     * A reference to the root of this object's bucket.\n     */\n    get root() {\n        const location = new Location(this._location.bucket, '');\n        return this._newRef(this._service, location);\n    }\n    /**\n     * The name of the bucket containing this reference's object.\n     */\n    get bucket() {\n        return this._location.bucket;\n    }\n    /**\n     * The full path of this object.\n     */\n    get fullPath() {\n        return this._location.path;\n    }\n    /**\n     * The short name of this object, which is the last component of the full path.\n     * For example, if fullPath is 'full/path/image.png', name is 'image.png'.\n     */\n    get name() {\n        return lastComponent(this._location.path);\n    }\n    /**\n     * The `StorageService` instance this `StorageReference` is associated with.\n     */\n    get storage() {\n        return this._service;\n    }\n    /**\n     * A `StorageReference` pointing to the parent location of this `StorageReference`, or null if\n     * this reference is the root.\n     */\n    get parent() {\n        const newPath = parent(this._location.path);\n        if (newPath === null) {\n            return null;\n        }\n        const location = new Location(this._location.bucket, newPath);\n        return new Reference(this._service, location);\n    }\n    /**\n     * Utility function to throw an error in methods that do not accept a root reference.\n     */\n    _throwIfRoot(name) {\n        if (this._location.path === '') {\n            throw invalidRootOperation(name);\n        }\n    }\n}\n/**\n * Download the bytes at the object's location.\n * @returns A Promise containing the downloaded bytes.\n */\nfunction getBytesInternal(ref, maxDownloadSizeBytes) {\n    ref._throwIfRoot('getBytes');\n    const requestInfo = getBytes$1(ref.storage, ref._location, maxDownloadSizeBytes);\n    return ref.storage\n        .makeRequestWithTokens(requestInfo, newBytesConnection)\n        .then(bytes => maxDownloadSizeBytes !== undefined\n        ? // GCS may not honor the Range header for small files\n            bytes.slice(0, maxDownloadSizeBytes)\n        : bytes);\n}\n/**\n * Download the bytes at the object's location.\n * @returns A Promise containing the downloaded blob.\n */\nfunction getBlobInternal(ref, maxDownloadSizeBytes) {\n    ref._throwIfRoot('getBlob');\n    const requestInfo = getBytes$1(ref.storage, ref._location, maxDownloadSizeBytes);\n    return ref.storage\n        .makeRequestWithTokens(requestInfo, newBlobConnection)\n        .then(blob => maxDownloadSizeBytes !== undefined\n        ? // GCS may not honor the Range header for small files\n            blob.slice(0, maxDownloadSizeBytes)\n        : blob);\n}\n/**\n * Uploads data to this object's location.\n * The upload is not resumable.\n *\n * @param ref - StorageReference where data should be uploaded.\n * @param data - The data to upload.\n * @param metadata - Metadata for the newly uploaded data.\n * @returns A Promise containing an UploadResult\n */\nfunction uploadBytes$1(ref, data, metadata) {\n    ref._throwIfRoot('uploadBytes');\n    const requestInfo = multipartUpload(ref.storage, ref._location, getMappings(), new FbsBlob(data, true), metadata);\n    return ref.storage\n        .makeRequestWithTokens(requestInfo, newTextConnection)\n        .then(finalMetadata => {\n        return {\n            metadata: finalMetadata,\n            ref\n        };\n    });\n}\n/**\n * Uploads data to this object's location.\n * The upload can be paused and resumed, and exposes progress updates.\n * @public\n * @param ref - StorageReference where data should be uploaded.\n * @param data - The data to upload.\n * @param metadata - Metadata for the newly uploaded data.\n * @returns An UploadTask\n */\nfunction uploadBytesResumable$1(ref, data, metadata) {\n    ref._throwIfRoot('uploadBytesResumable');\n    return new UploadTask(ref, new FbsBlob(data), metadata);\n}\n/**\n * Uploads a string to this object's location.\n * The upload is not resumable.\n * @public\n * @param ref - StorageReference where string should be uploaded.\n * @param value - The string to upload.\n * @param format - The format of the string to upload.\n * @param metadata - Metadata for the newly uploaded string.\n * @returns A Promise containing an UploadResult\n */\nfunction uploadString$1(ref, value, format = StringFormat.RAW, metadata) {\n    ref._throwIfRoot('uploadString');\n    const data = dataFromString(format, value);\n    const metadataClone = { ...metadata };\n    if (metadataClone['contentType'] == null && data.contentType != null) {\n        metadataClone['contentType'] = data.contentType;\n    }\n    return uploadBytes$1(ref, data.data, metadataClone);\n}\n/**\n * List all items (files) and prefixes (folders) under this storage reference.\n *\n * This is a helper method for calling list() repeatedly until there are\n * no more results. The default pagination size is 1000.\n *\n * Note: The results may not be consistent if objects are changed while this\n * operation is running.\n *\n * Warning: listAll may potentially consume too many resources if there are\n * too many results.\n * @public\n * @param ref - StorageReference to get list from.\n *\n * @returns A Promise that resolves with all the items and prefixes under\n *      the current storage reference. `prefixes` contains references to\n *      sub-directories and `items` contains references to objects in this\n *      folder. `nextPageToken` is never returned.\n */\nfunction listAll$1(ref) {\n    const accumulator = {\n        prefixes: [],\n        items: []\n    };\n    return listAllHelper(ref, accumulator).then(() => accumulator);\n}\n/**\n * Separated from listAll because async functions can't use \"arguments\".\n * @param ref\n * @param accumulator\n * @param pageToken\n */\nasync function listAllHelper(ref, accumulator, pageToken) {\n    const opt = {\n        // maxResults is 1000 by default.\n        pageToken\n    };\n    const nextPage = await list$1(ref, opt);\n    accumulator.prefixes.push(...nextPage.prefixes);\n    accumulator.items.push(...nextPage.items);\n    if (nextPage.nextPageToken != null) {\n        await listAllHelper(ref, accumulator, nextPage.nextPageToken);\n    }\n}\n/**\n * List items (files) and prefixes (folders) under this storage reference.\n *\n * List API is only available for Firebase Rules Version 2.\n *\n * GCS is a key-blob store. Firebase Storage imposes the semantic of '/'\n * delimited folder structure.\n * Refer to GCS's List API if you want to learn more.\n *\n * To adhere to Firebase Rules's Semantics, Firebase Storage does not\n * support objects whose paths end with \"/\" or contain two consecutive\n * \"/\"s. Firebase Storage List API will filter these unsupported objects.\n * list() may fail if there are too many unsupported objects in the bucket.\n * @public\n *\n * @param ref - StorageReference to get list from.\n * @param options - See ListOptions for details.\n * @returns A Promise that resolves with the items and prefixes.\n *      `prefixes` contains references to sub-folders and `items`\n *      contains references to objects in this folder. `nextPageToken`\n *      can be used to get the rest of the results.\n */\nfunction list$1(ref, options) {\n    if (options != null) {\n        if (typeof options.maxResults === 'number') {\n            validateNumber('options.maxResults', \n            /* minValue= */ 1, \n            /* maxValue= */ 1000, options.maxResults);\n        }\n    }\n    const op = options || {};\n    const requestInfo = list$2(ref.storage, ref._location, \n    /*delimiter= */ '/', op.pageToken, op.maxResults);\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\n}\n/**\n * A `Promise` that resolves with the metadata for this object. If this\n * object doesn't exist or metadata cannot be retrieved, the promise is\n * rejected.\n * @public\n * @param ref - StorageReference to get metadata from.\n */\nfunction getMetadata$1(ref) {\n    ref._throwIfRoot('getMetadata');\n    const requestInfo = getMetadata$2(ref.storage, ref._location, getMappings());\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\n}\n/**\n * Updates the metadata for this object.\n * @public\n * @param ref - StorageReference to update metadata for.\n * @param metadata - The new metadata for the object.\n *     Only values that have been explicitly set will be changed. Explicitly\n *     setting a value to null will remove the metadata.\n * @returns A `Promise` that resolves\n *     with the new metadata for this object.\n *     See `firebaseStorage.Reference.prototype.getMetadata`\n */\nfunction updateMetadata$1(ref, metadata) {\n    ref._throwIfRoot('updateMetadata');\n    const requestInfo = updateMetadata$2(ref.storage, ref._location, metadata, getMappings());\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\n}\n/**\n * Returns the download URL for the given Reference.\n * @public\n * @returns A `Promise` that resolves with the download\n *     URL for this object.\n */\nfunction getDownloadURL$1(ref) {\n    ref._throwIfRoot('getDownloadURL');\n    const requestInfo = getDownloadUrl(ref.storage, ref._location, getMappings());\n    return ref.storage\n        .makeRequestWithTokens(requestInfo, newTextConnection)\n        .then(url => {\n        if (url === null) {\n            throw noDownloadURL();\n        }\n        return url;\n    });\n}\n/**\n * Deletes the object at this location.\n * @public\n * @param ref - StorageReference for object to delete.\n * @returns A `Promise` that resolves if the deletion succeeds.\n */\nfunction deleteObject$1(ref) {\n    ref._throwIfRoot('deleteObject');\n    const requestInfo = deleteObject$2(ref.storage, ref._location);\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\n}\n/**\n * Returns reference for object obtained by appending `childPath` to `ref`.\n *\n * @param ref - StorageReference to get child of.\n * @param childPath - Child path from provided ref.\n * @returns A reference to the object obtained by\n * appending childPath, removing any duplicate, beginning, or trailing\n * slashes.\n *\n */\nfunction _getChild$1(ref, childPath) {\n    const newPath = child(ref._location.path, childPath);\n    const location = new Location(ref._location.bucket, newPath);\n    return new Reference(ref.storage, location);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isUrl(path) {\n    return /^[A-Za-z]+:\\/\\//.test(path);\n}\n/**\n * Returns a firebaseStorage.Reference for the given url.\n */\nfunction refFromURL(service, url) {\n    return new Reference(service, url);\n}\n/**\n * Returns a firebaseStorage.Reference for the given path in the default\n * bucket.\n */\nfunction refFromPath(ref, path) {\n    if (ref instanceof FirebaseStorageImpl) {\n        const service = ref;\n        if (service._bucket == null) {\n            throw noDefaultBucket();\n        }\n        const reference = new Reference(service, service._bucket);\n        if (path != null) {\n            return refFromPath(reference, path);\n        }\n        else {\n            return reference;\n        }\n    }\n    else {\n        // ref is a Reference\n        if (path !== undefined) {\n            return _getChild$1(ref, path);\n        }\n        else {\n            return ref;\n        }\n    }\n}\nfunction ref$1(serviceOrRef, pathOrUrl) {\n    if (pathOrUrl && isUrl(pathOrUrl)) {\n        if (serviceOrRef instanceof FirebaseStorageImpl) {\n            return refFromURL(serviceOrRef, pathOrUrl);\n        }\n        else {\n            throw invalidArgument('To use ref(service, url), the first argument must be a Storage instance.');\n        }\n    }\n    else {\n        return refFromPath(serviceOrRef, pathOrUrl);\n    }\n}\nfunction extractBucket(host, config) {\n    const bucketString = config?.[CONFIG_STORAGE_BUCKET_KEY];\n    if (bucketString == null) {\n        return null;\n    }\n    return Location.makeFromBucketSpec(bucketString, host);\n}\nfunction connectStorageEmulator$1(storage, host, port, options = {}) {\n    storage.host = `${host}:${port}`;\n    const useSsl = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isCloudWorkstation)(host);\n    // Workaround to get cookies in Firebase Studio\n    if (useSsl) {\n        void (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.pingServer)(`https://${storage.host}/b`);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.updateEmulatorBanner)('Storage', true);\n    }\n    storage._isUsingEmulator = true;\n    storage._protocol = useSsl ? 'https' : 'http';\n    const { mockUserToken } = options;\n    if (mockUserToken) {\n        storage._overrideAuthToken =\n            typeof mockUserToken === 'string'\n                ? mockUserToken\n                : (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.createMockUserToken)(mockUserToken, storage.app.options.projectId);\n    }\n}\n/**\n * A service that provides Firebase Storage Reference instances.\n * @param opt_url - gs:// url to a custom Storage Bucket\n *\n * @internal\n */\nclass FirebaseStorageImpl {\n    constructor(\n    /**\n     * FirebaseApp associated with this StorageService instance.\n     */\n    app, _authProvider, \n    /**\n     * @internal\n     */\n    _appCheckProvider, \n    /**\n     * @internal\n     */\n    _url, _firebaseVersion, _isUsingEmulator = false) {\n        this.app = app;\n        this._authProvider = _authProvider;\n        this._appCheckProvider = _appCheckProvider;\n        this._url = _url;\n        this._firebaseVersion = _firebaseVersion;\n        this._isUsingEmulator = _isUsingEmulator;\n        this._bucket = null;\n        /**\n         * This string can be in the formats:\n         * - host\n         * - host:port\n         */\n        this._host = DEFAULT_HOST;\n        this._protocol = 'https';\n        this._appId = null;\n        this._deleted = false;\n        this._maxOperationRetryTime = DEFAULT_MAX_OPERATION_RETRY_TIME;\n        this._maxUploadRetryTime = DEFAULT_MAX_UPLOAD_RETRY_TIME;\n        this._requests = new Set();\n        if (_url != null) {\n            this._bucket = Location.makeFromBucketSpec(_url, this._host);\n        }\n        else {\n            this._bucket = extractBucket(this._host, this.app.options);\n        }\n    }\n    /**\n     * The host string for this service, in the form of `host` or\n     * `host:port`.\n     */\n    get host() {\n        return this._host;\n    }\n    set host(host) {\n        this._host = host;\n        if (this._url != null) {\n            this._bucket = Location.makeFromBucketSpec(this._url, host);\n        }\n        else {\n            this._bucket = extractBucket(host, this.app.options);\n        }\n    }\n    /**\n     * The maximum time to retry uploads in milliseconds.\n     */\n    get maxUploadRetryTime() {\n        return this._maxUploadRetryTime;\n    }\n    set maxUploadRetryTime(time) {\n        validateNumber('time', \n        /* minValue=*/ 0, \n        /* maxValue= */ Number.POSITIVE_INFINITY, time);\n        this._maxUploadRetryTime = time;\n    }\n    /**\n     * The maximum time to retry operations other than uploads or downloads in\n     * milliseconds.\n     */\n    get maxOperationRetryTime() {\n        return this._maxOperationRetryTime;\n    }\n    set maxOperationRetryTime(time) {\n        validateNumber('time', \n        /* minValue=*/ 0, \n        /* maxValue= */ Number.POSITIVE_INFINITY, time);\n        this._maxOperationRetryTime = time;\n    }\n    async _getAuthToken() {\n        if (this._overrideAuthToken) {\n            return this._overrideAuthToken;\n        }\n        const auth = this._authProvider.getImmediate({ optional: true });\n        if (auth) {\n            const tokenData = await auth.getToken();\n            if (tokenData !== null) {\n                return tokenData.accessToken;\n            }\n        }\n        return null;\n    }\n    async _getAppCheckToken() {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app) && this.app.settings.appCheckToken) {\n            return this.app.settings.appCheckToken;\n        }\n        const appCheck = this._appCheckProvider.getImmediate({ optional: true });\n        if (appCheck) {\n            const result = await appCheck.getToken();\n            // TODO: What do we want to do if there is an error getting the token?\n            // Context: appCheck.getToken() will never throw even if an error happened. In the error case, a dummy token will be\n            // returned along with an error field describing the error. In general, we shouldn't care about the error condition and just use\n            // the token (actual or dummy) to send requests.\n            return result.token;\n        }\n        return null;\n    }\n    /**\n     * Stop running requests and prevent more from being created.\n     */\n    _delete() {\n        if (!this._deleted) {\n            this._deleted = true;\n            this._requests.forEach(request => request.cancel());\n            this._requests.clear();\n        }\n        return Promise.resolve();\n    }\n    /**\n     * Returns a new firebaseStorage.Reference object referencing this StorageService\n     * at the given Location.\n     */\n    _makeStorageReference(loc) {\n        return new Reference(this, loc);\n    }\n    /**\n     * @param requestInfo - HTTP RequestInfo object\n     * @param authToken - Firebase auth token\n     */\n    _makeRequest(requestInfo, requestFactory, authToken, appCheckToken, retry = true) {\n        if (!this._deleted) {\n            const request = makeRequest(requestInfo, this._appId, authToken, appCheckToken, requestFactory, this._firebaseVersion, retry, this._isUsingEmulator);\n            this._requests.add(request);\n            // Request removes itself from set when complete.\n            request.getPromise().then(() => this._requests.delete(request), () => this._requests.delete(request));\n            return request;\n        }\n        else {\n            return new FailRequest(appDeleted());\n        }\n    }\n    async makeRequestWithTokens(requestInfo, requestFactory) {\n        const [authToken, appCheckToken] = await Promise.all([\n            this._getAuthToken(),\n            this._getAppCheckToken()\n        ]);\n        return this._makeRequest(requestInfo, requestFactory, authToken, appCheckToken).getPromise();\n    }\n}\n\nconst name = \"@firebase/storage\";\nconst version = \"0.14.0\";\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Type constant for Firebase Storage.\n */\nconst STORAGE_TYPE = 'storage';\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Downloads the data at the object's location. Returns an error if the object\n * is not found.\n *\n * To use this functionality, you have to whitelist your app's origin in your\n * Cloud Storage bucket. See also\n * https://cloud.google.com/storage/docs/configuring-cors\n *\n * @public\n * @param ref - StorageReference where data should be downloaded.\n * @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to\n * retrieve.\n * @returns A Promise containing the object's bytes\n */\nfunction getBytes(ref, maxDownloadSizeBytes) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return getBytesInternal(ref, maxDownloadSizeBytes);\n}\n/**\n * Uploads data to this object's location.\n * The upload is not resumable.\n * @public\n * @param ref - {@link StorageReference} where data should be uploaded.\n * @param data - The data to upload.\n * @param metadata - Metadata for the data to upload.\n * @returns A Promise containing an UploadResult\n */\nfunction uploadBytes(ref, data, metadata) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return uploadBytes$1(ref, data, metadata);\n}\n/**\n * Uploads a string to this object's location.\n * The upload is not resumable.\n * @public\n * @param ref - {@link StorageReference} where string should be uploaded.\n * @param value - The string to upload.\n * @param format - The format of the string to upload.\n * @param metadata - Metadata for the string to upload.\n * @returns A Promise containing an UploadResult\n */\nfunction uploadString(ref, value, format, metadata) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return uploadString$1(ref, value, format, metadata);\n}\n/**\n * Uploads data to this object's location.\n * The upload can be paused and resumed, and exposes progress updates.\n * @public\n * @param ref - {@link StorageReference} where data should be uploaded.\n * @param data - The data to upload.\n * @param metadata - Metadata for the data to upload.\n * @returns An UploadTask\n */\nfunction uploadBytesResumable(ref, data, metadata) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return uploadBytesResumable$1(ref, data, metadata);\n}\n/**\n * A `Promise` that resolves with the metadata for this object. If this\n * object doesn't exist or metadata cannot be retrieved, the promise is\n * rejected.\n * @public\n * @param ref - {@link StorageReference} to get metadata from.\n */\nfunction getMetadata(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return getMetadata$1(ref);\n}\n/**\n * Updates the metadata for this object.\n * @public\n * @param ref - {@link StorageReference} to update metadata for.\n * @param metadata - The new metadata for the object.\n *     Only values that have been explicitly set will be changed. Explicitly\n *     setting a value to null will remove the metadata.\n * @returns A `Promise` that resolves with the new metadata for this object.\n */\nfunction updateMetadata(ref, metadata) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return updateMetadata$1(ref, metadata);\n}\n/**\n * List items (files) and prefixes (folders) under this storage reference.\n *\n * List API is only available for Firebase Rules Version 2.\n *\n * GCS is a key-blob store. Firebase Storage imposes the semantic of '/'\n * delimited folder structure.\n * Refer to GCS's List API if you want to learn more.\n *\n * To adhere to Firebase Rules's Semantics, Firebase Storage does not\n * support objects whose paths end with \"/\" or contain two consecutive\n * \"/\"s. Firebase Storage List API will filter these unsupported objects.\n * list() may fail if there are too many unsupported objects in the bucket.\n * @public\n *\n * @param ref - {@link StorageReference} to get list from.\n * @param options - See {@link ListOptions} for details.\n * @returns A `Promise` that resolves with the items and prefixes.\n *      `prefixes` contains references to sub-folders and `items`\n *      contains references to objects in this folder. `nextPageToken`\n *      can be used to get the rest of the results.\n */\nfunction list(ref, options) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return list$1(ref, options);\n}\n/**\n * List all items (files) and prefixes (folders) under this storage reference.\n *\n * This is a helper method for calling list() repeatedly until there are\n * no more results. The default pagination size is 1000.\n *\n * Note: The results may not be consistent if objects are changed while this\n * operation is running.\n *\n * Warning: `listAll` may potentially consume too many resources if there are\n * too many results.\n * @public\n * @param ref - {@link StorageReference} to get list from.\n *\n * @returns A `Promise` that resolves with all the items and prefixes under\n *      the current storage reference. `prefixes` contains references to\n *      sub-directories and `items` contains references to objects in this\n *      folder. `nextPageToken` is never returned.\n */\nfunction listAll(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return listAll$1(ref);\n}\n/**\n * Returns the download URL for the given {@link StorageReference}.\n * @public\n * @param ref - {@link StorageReference} to get the download URL for.\n * @returns A `Promise` that resolves with the download\n *     URL for this object.\n */\nfunction getDownloadURL(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return getDownloadURL$1(ref);\n}\n/**\n * Deletes the object at this location.\n * @public\n * @param ref - {@link StorageReference} for object to delete.\n * @returns A `Promise` that resolves if the deletion succeeds.\n */\nfunction deleteObject(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return deleteObject$1(ref);\n}\nfunction ref(serviceOrRef, pathOrUrl) {\n    serviceOrRef = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(serviceOrRef);\n    return ref$1(serviceOrRef, pathOrUrl);\n}\n/**\n * @internal\n */\nfunction _getChild(ref, childPath) {\n    return _getChild$1(ref, childPath);\n}\n/**\n * Gets a {@link FirebaseStorage} instance for the given Firebase app.\n * @public\n * @param app - Firebase app to get {@link FirebaseStorage} instance for.\n * @param bucketUrl - The gs:// url to your Firebase Storage Bucket.\n * If not passed, uses the app's default Storage Bucket.\n * @returns A {@link FirebaseStorage} instance.\n */\nfunction getStorage(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)(), bucketUrl) {\n    app = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(app);\n    const storageProvider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, STORAGE_TYPE);\n    const storageInstance = storageProvider.getImmediate({\n        identifier: bucketUrl\n    });\n    const emulator = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getDefaultEmulatorHostnameAndPort)('storage');\n    if (emulator) {\n        connectStorageEmulator(storageInstance, ...emulator);\n    }\n    return storageInstance;\n}\n/**\n * Modify this {@link FirebaseStorage} instance to communicate with the Cloud Storage emulator.\n *\n * @param storage - The {@link FirebaseStorage} instance\n * @param host - The emulator host (ex: localhost)\n * @param port - The emulator port (ex: 5001)\n * @param options - Emulator options. `options.mockUserToken` is the mock auth\n * token to use for unit testing Security Rules.\n * @public\n */\nfunction connectStorageEmulator(storage, host, port, options = {}) {\n    connectStorageEmulator$1(storage, host, port, options);\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Downloads the data at the object's location. Returns an error if the object\n * is not found.\n *\n * To use this functionality, you have to whitelist your app's origin in your\n * Cloud Storage bucket. See also\n * https://cloud.google.com/storage/docs/configuring-cors\n *\n * This API is not available in Node.\n *\n * @public\n * @param ref - StorageReference where data should be downloaded.\n * @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to\n * retrieve.\n * @returns A Promise that resolves with a Blob containing the object's bytes\n */\nfunction getBlob(ref, maxDownloadSizeBytes) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return getBlobInternal(ref, maxDownloadSizeBytes);\n}\n/**\n * Downloads the data at the object's location. Raises an error event if the\n * object is not found.\n *\n * This API is only available in Node.\n *\n * @public\n * @param ref - StorageReference where data should be downloaded.\n * @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to\n * retrieve.\n * @returns A stream with the object's data as bytes\n */\nfunction getStream(ref, maxDownloadSizeBytes) {\n    throw new Error('getStream() is only supported by NodeJS builds');\n}\n\n/**\n * Cloud Storage for Firebase\n *\n * @packageDocumentation\n */\nfunction factory(container, { instanceIdentifier: url }) {\n    const app = container.getProvider('app').getImmediate();\n    const authProvider = container.getProvider('auth-internal');\n    const appCheckProvider = container.getProvider('app-check-internal');\n    return new FirebaseStorageImpl(app, authProvider, appCheckProvider, url, _firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION);\n}\nfunction registerStorage() {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(STORAGE_TYPE, factory, \"PUBLIC\" /* ComponentType.PUBLIC */).setMultipleInstances(true));\n    //RUNTIME_ENV will be replaced during the compilation to \"node\" for nodejs and an empty string for browser\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, '');\n    // BUILD_TARGET will be replaced by values like esm, cjs, etc during the compilation\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, 'esm2020');\n}\nregisterStorage();\n\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkg7QUFDb0Q7QUFDakk7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseURBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUyxHQUFHLGtCQUFrQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtCQUFrQixJQUFJLCtCQUErQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFVBQVU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELG9CQUFvQixHQUFHLFFBQVEsS0FBSyxhQUFhLElBQUksb0JBQW9CO0FBQ3ZJLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxpQkFBaUIsR0FBRyxhQUFhLEdBQUcsaUJBQWlCO0FBQ2hILHNDQUFzQztBQUN0QztBQUNBLGNBQWMsMERBQTBEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUyxjQUFjLFVBQVU7QUFDckY7QUFDQTtBQUNBLG9EQUFvRCxTQUFTLGNBQWMsVUFBVTtBQUNyRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUs7QUFDakM7QUFDQSxjQUFjLFNBQVMsS0FBSyxPQUFPLEtBQUssUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4Qjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscUJBQXFCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQ0FBbUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtFQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLHNCQUFzQixLQUFLLEdBQUcsS0FBSztBQUNuQyxtQkFBbUIsa0VBQWtCO0FBQ3JDO0FBQ0E7QUFDQSxhQUFhLDBEQUFVLFlBQVksYUFBYTtBQUNoRCxRQUFRLG9FQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtRUFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1FQUFvQjtBQUNoQztBQUNBO0FBQ0EsK0RBQStELGdCQUFnQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0EsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekMseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1QkFBdUI7QUFDbEU7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtFQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBLHFDQUFxQyx1QkFBdUI7QUFDNUQ7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0EsMEJBQTBCLHFEQUFNO0FBQ2hDLFVBQVUsa0VBQWtCO0FBQzVCLDRCQUE0QiwyREFBWTtBQUN4QztBQUNBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQixpRkFBaUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsc0RBQVc7QUFDeEY7QUFDQTtBQUNBLElBQUksaUVBQWtCLEtBQUssMERBQVM7QUFDcEM7QUFDQSxJQUFJLDhEQUFlO0FBQ25CO0FBQ0EsSUFBSSw4REFBZTtBQUNuQjtBQUNBOztBQUVxZjtBQUNyZiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxob2xlY2VralxcRGVza3RvcFxca3JvdS1reS1oYi1tYWluXFxub2RlX21vZHVsZXNcXEBmaXJlYmFzZVxcc3RvcmFnZVxcZGlzdFxcaW5kZXguZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9pc0ZpcmViYXNlU2VydmVyQXBwLCBfZ2V0UHJvdmlkZXIsIGdldEFwcCwgX3JlZ2lzdGVyQ29tcG9uZW50LCByZWdpc3RlclZlcnNpb24sIFNES19WRVJTSU9OIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBGaXJlYmFzZUVycm9yLCBpc0Nsb3VkV29ya3N0YXRpb24sIHBpbmdTZXJ2ZXIsIHVwZGF0ZUVtdWxhdG9yQmFubmVyLCBjcmVhdGVNb2NrVXNlclRva2VuLCBnZXRNb2R1bGFySW5zdGFuY2UsIGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbnN0YW50cyB1c2VkIGluIHRoZSBGaXJlYmFzZSBTdG9yYWdlIGxpYnJhcnkuXG4gKi9cbi8qKlxuICogRG9tYWluIG5hbWUgZm9yIGZpcmViYXNlIHN0b3JhZ2UuXG4gKi9cbmNvbnN0IERFRkFVTFRfSE9TVCA9ICdmaXJlYmFzZXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20nO1xuLyoqXG4gKiBUaGUga2V5IGluIEZpcmViYXNlIGNvbmZpZyBqc29uIGZvciB0aGUgc3RvcmFnZSBidWNrZXQuXG4gKi9cbmNvbnN0IENPTkZJR19TVE9SQUdFX0JVQ0tFVF9LRVkgPSAnc3RvcmFnZUJ1Y2tldCc7XG4vKipcbiAqIDIgbWludXRlc1xuICpcbiAqIFRoZSB0aW1lb3V0IGZvciBhbGwgb3BlcmF0aW9ucyBleGNlcHQgdXBsb2FkLlxuICovXG5jb25zdCBERUZBVUxUX01BWF9PUEVSQVRJT05fUkVUUllfVElNRSA9IDIgKiA2MCAqIDEwMDA7XG4vKipcbiAqIDEwIG1pbnV0ZXNcbiAqXG4gKiBUaGUgdGltZW91dCBmb3IgdXBsb2FkLlxuICovXG5jb25zdCBERUZBVUxUX01BWF9VUExPQURfUkVUUllfVElNRSA9IDEwICogNjAgKiAxMDAwO1xuLyoqXG4gKiAxIHNlY29uZFxuICovXG5jb25zdCBERUZBVUxUX01JTl9TTEVFUF9USU1FX01JTExJUyA9IDEwMDA7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGVycm9yIHJldHVybmVkIGJ5IHRoZSBGaXJlYmFzZSBTdG9yYWdlIFNESy5cbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgU3RvcmFnZUVycm9yIGV4dGVuZHMgRmlyZWJhc2VFcnJvciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvZGUgLSBBIGBTdG9yYWdlRXJyb3JDb2RlYCBzdHJpbmcgdG8gYmUgcHJlZml4ZWQgd2l0aCAnc3RvcmFnZS8nIGFuZFxuICAgICAqICBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlICAtIEVycm9yIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHN0YXR1c18gLSBDb3JyZXNwb25kaW5nIEhUVFAgU3RhdHVzIENvZGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBzdGF0dXNfID0gMCkge1xuICAgICAgICBzdXBlcihwcmVwZW5kQ29kZShjb2RlKSwgYEZpcmViYXNlIFN0b3JhZ2U6ICR7bWVzc2FnZX0gKCR7cHJlcGVuZENvZGUoY29kZSl9KWApO1xuICAgICAgICB0aGlzLnN0YXR1c18gPSBzdGF0dXNfO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmVzIGN1c3RvbSBlcnJvciBkYXRhIHVuaXF1ZSB0byB0aGUgYFN0b3JhZ2VFcnJvcmAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1c3RvbURhdGEgPSB7IHNlcnZlclJlc3BvbnNlOiBudWxsIH07XG4gICAgICAgIHRoaXMuX2Jhc2VNZXNzYWdlID0gdGhpcy5tZXNzYWdlO1xuICAgICAgICAvLyBXaXRob3V0IHRoaXMsIGBpbnN0YW5jZW9mIFN0b3JhZ2VFcnJvcmAsIGluIHRlc3RzIGZvciBleGFtcGxlLFxuICAgICAgICAvLyByZXR1cm5zIGZhbHNlLlxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgU3RvcmFnZUVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1c187XG4gICAgfVxuICAgIHNldCBzdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzXyA9IHN0YXR1cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgYSBgU3RvcmFnZUVycm9yQ29kZWAgYWdhaW5zdCB0aGlzIGVycm9yJ3MgY29kZSwgZmlsdGVyaW5nIG91dCB0aGUgcHJlZml4LlxuICAgICAqL1xuICAgIF9jb2RlRXF1YWxzKGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHByZXBlbmRDb2RlKGNvZGUpID09PSB0aGlzLmNvZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIHJlc3BvbnNlIG1lc3NhZ2UgdGhhdCB3YXMgYWRkZWQgYnkgdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBnZXQgc2VydmVyUmVzcG9uc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1c3RvbURhdGEuc2VydmVyUmVzcG9uc2U7XG4gICAgfVxuICAgIHNldCBzZXJ2ZXJSZXNwb25zZShzZXJ2ZXJSZXNwb25zZSkge1xuICAgICAgICB0aGlzLmN1c3RvbURhdGEuc2VydmVyUmVzcG9uc2UgPSBzZXJ2ZXJSZXNwb25zZTtcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tRGF0YS5zZXJ2ZXJSZXNwb25zZSkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gYCR7dGhpcy5fYmFzZU1lc3NhZ2V9XFxuJHt0aGlzLmN1c3RvbURhdGEuc2VydmVyUmVzcG9uc2V9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuX2Jhc2VNZXNzYWdlO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBAcHVibGljXG4gKiBFcnJvciBjb2RlcyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBgU3RvcmFnZUVycm9yYCBvYmplY3RzLlxuICovXG52YXIgU3RvcmFnZUVycm9yQ29kZTtcbihmdW5jdGlvbiAoU3RvcmFnZUVycm9yQ29kZSkge1xuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIGFsbCBwbGF0Zm9ybXNcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiVU5LTk9XTlwiXSA9IFwidW5rbm93blwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJPQkpFQ1RfTk9UX0ZPVU5EXCJdID0gXCJvYmplY3Qtbm90LWZvdW5kXCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIkJVQ0tFVF9OT1RfRk9VTkRcIl0gPSBcImJ1Y2tldC1ub3QtZm91bmRcIjtcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiUFJPSkVDVF9OT1RfRk9VTkRcIl0gPSBcInByb2plY3Qtbm90LWZvdW5kXCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIlFVT1RBX0VYQ0VFREVEXCJdID0gXCJxdW90YS1leGNlZWRlZFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJVTkFVVEhFTlRJQ0FURURcIl0gPSBcInVuYXV0aGVudGljYXRlZFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJVTkFVVEhPUklaRURcIl0gPSBcInVuYXV0aG9yaXplZFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJVTkFVVEhPUklaRURfQVBQXCJdID0gXCJ1bmF1dGhvcml6ZWQtYXBwXCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIlJFVFJZX0xJTUlUX0VYQ0VFREVEXCJdID0gXCJyZXRyeS1saW1pdC1leGNlZWRlZFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJJTlZBTElEX0NIRUNLU1VNXCJdID0gXCJpbnZhbGlkLWNoZWNrc3VtXCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIkNBTkNFTEVEXCJdID0gXCJjYW5jZWxlZFwiO1xuICAgIC8vIEpTIHNwZWNpZmljXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIklOVkFMSURfRVZFTlRfTkFNRVwiXSA9IFwiaW52YWxpZC1ldmVudC1uYW1lXCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIklOVkFMSURfVVJMXCJdID0gXCJpbnZhbGlkLXVybFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJJTlZBTElEX0RFRkFVTFRfQlVDS0VUXCJdID0gXCJpbnZhbGlkLWRlZmF1bHQtYnVja2V0XCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIk5PX0RFRkFVTFRfQlVDS0VUXCJdID0gXCJuby1kZWZhdWx0LWJ1Y2tldFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJDQU5OT1RfU0xJQ0VfQkxPQlwiXSA9IFwiY2Fubm90LXNsaWNlLWJsb2JcIjtcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiU0VSVkVSX0ZJTEVfV1JPTkdfU0laRVwiXSA9IFwic2VydmVyLWZpbGUtd3Jvbmctc2l6ZVwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJOT19ET1dOTE9BRF9VUkxcIl0gPSBcIm5vLWRvd25sb2FkLXVybFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJJTlZBTElEX0FSR1VNRU5UXCJdID0gXCJpbnZhbGlkLWFyZ3VtZW50XCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIklOVkFMSURfQVJHVU1FTlRfQ09VTlRcIl0gPSBcImludmFsaWQtYXJndW1lbnQtY291bnRcIjtcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiQVBQX0RFTEVURURcIl0gPSBcImFwcC1kZWxldGVkXCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIklOVkFMSURfUk9PVF9PUEVSQVRJT05cIl0gPSBcImludmFsaWQtcm9vdC1vcGVyYXRpb25cIjtcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiSU5WQUxJRF9GT1JNQVRcIl0gPSBcImludmFsaWQtZm9ybWF0XCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIklOVEVSTkFMX0VSUk9SXCJdID0gXCJpbnRlcm5hbC1lcnJvclwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJVTlNVUFBPUlRFRF9FTlZJUk9OTUVOVFwiXSA9IFwidW5zdXBwb3J0ZWQtZW52aXJvbm1lbnRcIjtcbn0pKFN0b3JhZ2VFcnJvckNvZGUgfHwgKFN0b3JhZ2VFcnJvckNvZGUgPSB7fSkpO1xuZnVuY3Rpb24gcHJlcGVuZENvZGUoY29kZSkge1xuICAgIHJldHVybiAnc3RvcmFnZS8nICsgY29kZTtcbn1cbmZ1bmN0aW9uIHVua25vd24oKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkLCBwbGVhc2UgY2hlY2sgdGhlIGVycm9yIHBheWxvYWQgZm9yICcgK1xuICAgICAgICAnc2VydmVyIHJlc3BvbnNlLic7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5VTktOT1dOLCBtZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIG9iamVjdE5vdEZvdW5kKHBhdGgpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLk9CSkVDVF9OT1RfRk9VTkQsIFwiT2JqZWN0ICdcIiArIHBhdGggKyBcIicgZG9lcyBub3QgZXhpc3QuXCIpO1xufVxuZnVuY3Rpb24gcXVvdGFFeGNlZWRlZChidWNrZXQpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLlFVT1RBX0VYQ0VFREVELCBcIlF1b3RhIGZvciBidWNrZXQgJ1wiICtcbiAgICAgICAgYnVja2V0ICtcbiAgICAgICAgXCInIGV4Y2VlZGVkLCBwbGVhc2UgdmlldyBxdW90YSBvbiBcIiArXG4gICAgICAgICdodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vcHJpY2luZy8uJyk7XG59XG5mdW5jdGlvbiB1bmF1dGhlbnRpY2F0ZWQoKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9ICdVc2VyIGlzIG5vdCBhdXRoZW50aWNhdGVkLCBwbGVhc2UgYXV0aGVudGljYXRlIHVzaW5nIEZpcmViYXNlICcgK1xuICAgICAgICAnQXV0aGVudGljYXRpb24gYW5kIHRyeSBhZ2Fpbi4nO1xuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuVU5BVVRIRU5USUNBVEVELCBtZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIHVuYXV0aG9yaXplZEFwcCgpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLlVOQVVUSE9SSVpFRF9BUFAsICdUaGlzIGFwcCBkb2VzIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gYWNjZXNzIEZpcmViYXNlIFN0b3JhZ2Ugb24gdGhpcyBwcm9qZWN0LicpO1xufVxuZnVuY3Rpb24gdW5hdXRob3JpemVkKHBhdGgpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLlVOQVVUSE9SSVpFRCwgXCJVc2VyIGRvZXMgbm90IGhhdmUgcGVybWlzc2lvbiB0byBhY2Nlc3MgJ1wiICsgcGF0aCArIFwiJy5cIik7XG59XG5mdW5jdGlvbiByZXRyeUxpbWl0RXhjZWVkZWQoKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5SRVRSWV9MSU1JVF9FWENFRURFRCwgJ01heCByZXRyeSB0aW1lIGZvciBvcGVyYXRpb24gZXhjZWVkZWQsIHBsZWFzZSB0cnkgYWdhaW4uJyk7XG59XG5mdW5jdGlvbiBjYW5jZWxlZCgpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLkNBTkNFTEVELCAnVXNlciBjYW5jZWxlZCB0aGUgdXBsb2FkL2Rvd25sb2FkLicpO1xufVxuZnVuY3Rpb24gaW52YWxpZFVybCh1cmwpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLklOVkFMSURfVVJMLCBcIkludmFsaWQgVVJMICdcIiArIHVybCArIFwiJy5cIik7XG59XG5mdW5jdGlvbiBpbnZhbGlkRGVmYXVsdEJ1Y2tldChidWNrZXQpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLklOVkFMSURfREVGQVVMVF9CVUNLRVQsIFwiSW52YWxpZCBkZWZhdWx0IGJ1Y2tldCAnXCIgKyBidWNrZXQgKyBcIicuXCIpO1xufVxuZnVuY3Rpb24gbm9EZWZhdWx0QnVja2V0KCkge1xuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuTk9fREVGQVVMVF9CVUNLRVQsICdObyBkZWZhdWx0IGJ1Y2tldCAnICtcbiAgICAgICAgXCJmb3VuZC4gRGlkIHlvdSBzZXQgdGhlICdcIiArXG4gICAgICAgIENPTkZJR19TVE9SQUdFX0JVQ0tFVF9LRVkgK1xuICAgICAgICBcIicgcHJvcGVydHkgd2hlbiBpbml0aWFsaXppbmcgdGhlIGFwcD9cIik7XG59XG5mdW5jdGlvbiBjYW5ub3RTbGljZUJsb2IoKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5DQU5OT1RfU0xJQ0VfQkxPQiwgJ0Nhbm5vdCBzbGljZSBibG9iIGZvciB1cGxvYWQuIFBsZWFzZSByZXRyeSB0aGUgdXBsb2FkLicpO1xufVxuZnVuY3Rpb24gc2VydmVyRmlsZVdyb25nU2l6ZSgpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLlNFUlZFUl9GSUxFX1dST05HX1NJWkUsICdTZXJ2ZXIgcmVjb3JkZWQgaW5jb3JyZWN0IHVwbG9hZCBmaWxlIHNpemUsIHBsZWFzZSByZXRyeSB0aGUgdXBsb2FkLicpO1xufVxuZnVuY3Rpb24gbm9Eb3dubG9hZFVSTCgpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLk5PX0RPV05MT0FEX1VSTCwgJ1RoZSBnaXZlbiBmaWxlIGRvZXMgbm90IGhhdmUgYW55IGRvd25sb2FkIFVSTHMuJyk7XG59XG5mdW5jdGlvbiBtaXNzaW5nUG9seUZpbGwocG9seUZpbGwpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLlVOU1VQUE9SVEVEX0VOVklST05NRU5ULCBgJHtwb2x5RmlsbH0gaXMgbWlzc2luZy4gTWFrZSBzdXJlIHRvIGluc3RhbGwgdGhlIHJlcXVpcmVkIHBvbHlmaWxscy4gU2VlIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL3dlYi9lbnZpcm9ubWVudHMtanMtc2RrI3BvbHlmaWxscyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGludmFsaWRBcmd1bWVudChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBtZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIGFwcERlbGV0ZWQoKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5BUFBfREVMRVRFRCwgJ1RoZSBGaXJlYmFzZSBhcHAgd2FzIGRlbGV0ZWQuJyk7XG59XG4vKipcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIG9wZXJhdGlvbiB0aGF0IHdhcyBpbnZhbGlkLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpbnZhbGlkUm9vdE9wZXJhdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5JTlZBTElEX1JPT1RfT1BFUkFUSU9OLCBcIlRoZSBvcGVyYXRpb24gJ1wiICtcbiAgICAgICAgbmFtZSArXG4gICAgICAgIFwiJyBjYW5ub3QgYmUgcGVyZm9ybWVkIG9uIGEgcm9vdCByZWZlcmVuY2UsIGNyZWF0ZSBhIG5vbi1yb290IFwiICtcbiAgICAgICAgXCJyZWZlcmVuY2UgdXNpbmcgY2hpbGQsIHN1Y2ggYXMgLmNoaWxkKCdmaWxlLnBuZycpLlwiKTtcbn1cbi8qKlxuICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgdGhhdCB3YXMgbm90IHZhbGlkLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBBIG1lc3NhZ2UgZGVzY3JpYmluZyB0aGUgZm9ybWF0IHZpb2xhdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW52YWxpZEZvcm1hdChmb3JtYXQsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLklOVkFMSURfRk9STUFULCBcIlN0cmluZyBkb2VzIG5vdCBtYXRjaCBmb3JtYXQgJ1wiICsgZm9ybWF0ICsgXCInOiBcIiArIG1lc3NhZ2UpO1xufVxuLyoqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIEEgbWVzc2FnZSBkZXNjcmliaW5nIHRoZSBpbnRlcm5hbCBlcnJvci5cbiAqL1xuZnVuY3Rpb24gaW50ZXJuYWxFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SLCAnSW50ZXJuYWwgZXJyb3I6ICcgKyBtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRmlyZWJhc2UgU3RvcmFnZSBsb2NhdGlvbiBkYXRhLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBMb2NhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYnVja2V0LCBwYXRoKSB7XG4gICAgICAgIHRoaXMuYnVja2V0ID0gYnVja2V0O1xuICAgICAgICB0aGlzLnBhdGhfID0gcGF0aDtcbiAgICB9XG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGhfO1xuICAgIH1cbiAgICBnZXQgaXNSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgZnVsbFNlcnZlclVybCgpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlID0gZW5jb2RlVVJJQ29tcG9uZW50O1xuICAgICAgICByZXR1cm4gJy9iLycgKyBlbmNvZGUodGhpcy5idWNrZXQpICsgJy9vLycgKyBlbmNvZGUodGhpcy5wYXRoKTtcbiAgICB9XG4gICAgYnVja2V0T25seVNlcnZlclVybCgpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlID0gZW5jb2RlVVJJQ29tcG9uZW50O1xuICAgICAgICByZXR1cm4gJy9iLycgKyBlbmNvZGUodGhpcy5idWNrZXQpICsgJy9vJztcbiAgICB9XG4gICAgc3RhdGljIG1ha2VGcm9tQnVja2V0U3BlYyhidWNrZXRTdHJpbmcsIGhvc3QpIHtcbiAgICAgICAgbGV0IGJ1Y2tldExvY2F0aW9uO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYnVja2V0TG9jYXRpb24gPSBMb2NhdGlvbi5tYWtlRnJvbVVybChidWNrZXRTdHJpbmcsIGhvc3QpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBOb3QgdmFsaWQgVVJMLCB1c2UgYXMtaXMuIFRoaXMgbGV0cyB5b3UgcHV0IGJhcmUgYnVja2V0IG5hbWVzIGluXG4gICAgICAgICAgICAvLyBjb25maWcuXG4gICAgICAgICAgICByZXR1cm4gbmV3IExvY2F0aW9uKGJ1Y2tldFN0cmluZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWNrZXRMb2NhdGlvbi5wYXRoID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGJ1Y2tldExvY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgaW52YWxpZERlZmF1bHRCdWNrZXQoYnVja2V0U3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgbWFrZUZyb21VcmwodXJsLCBob3N0KSB7XG4gICAgICAgIGxldCBsb2NhdGlvbiA9IG51bGw7XG4gICAgICAgIGNvbnN0IGJ1Y2tldERvbWFpbiA9ICcoW0EtWmEtejAtOS5cXFxcLV9dKyknO1xuICAgICAgICBmdW5jdGlvbiBnc01vZGlmeShsb2MpIHtcbiAgICAgICAgICAgIGlmIChsb2MucGF0aC5jaGFyQXQobG9jLnBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJykge1xuICAgICAgICAgICAgICAgIGxvYy5wYXRoXyA9IGxvYy5wYXRoXy5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ3NQYXRoID0gJygvKC4qKSk/JCc7XG4gICAgICAgIGNvbnN0IGdzUmVnZXggPSBuZXcgUmVnRXhwKCdeZ3M6Ly8nICsgYnVja2V0RG9tYWluICsgZ3NQYXRoLCAnaScpO1xuICAgICAgICBjb25zdCBnc0luZGljZXMgPSB7IGJ1Y2tldDogMSwgcGF0aDogMyB9O1xuICAgICAgICBmdW5jdGlvbiBodHRwTW9kaWZ5KGxvYykge1xuICAgICAgICAgICAgbG9jLnBhdGhfID0gZGVjb2RlVVJJQ29tcG9uZW50KGxvYy5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gJ3ZbQS1aYS16MC05X10rJztcbiAgICAgICAgY29uc3QgZmlyZWJhc2VTdG9yYWdlSG9zdCA9IGhvc3QucmVwbGFjZSgvWy5dL2csICdcXFxcLicpO1xuICAgICAgICBjb25zdCBmaXJlYmFzZVN0b3JhZ2VQYXRoID0gJygvKFtePyNdKikuKik/JCc7XG4gICAgICAgIGNvbnN0IGZpcmViYXNlU3RvcmFnZVJlZ0V4cCA9IG5ldyBSZWdFeHAoYF5odHRwcz86Ly8ke2ZpcmViYXNlU3RvcmFnZUhvc3R9LyR7dmVyc2lvbn0vYi8ke2J1Y2tldERvbWFpbn0vbyR7ZmlyZWJhc2VTdG9yYWdlUGF0aH1gLCAnaScpO1xuICAgICAgICBjb25zdCBmaXJlYmFzZVN0b3JhZ2VJbmRpY2VzID0geyBidWNrZXQ6IDEsIHBhdGg6IDMgfTtcbiAgICAgICAgY29uc3QgY2xvdWRTdG9yYWdlSG9zdCA9IGhvc3QgPT09IERFRkFVTFRfSE9TVFxuICAgICAgICAgICAgPyAnKD86c3RvcmFnZS5nb29nbGVhcGlzLmNvbXxzdG9yYWdlLmNsb3VkLmdvb2dsZS5jb20pJ1xuICAgICAgICAgICAgOiBob3N0O1xuICAgICAgICBjb25zdCBjbG91ZFN0b3JhZ2VQYXRoID0gJyhbXj8jXSopJztcbiAgICAgICAgY29uc3QgY2xvdWRTdG9yYWdlUmVnRXhwID0gbmV3IFJlZ0V4cChgXmh0dHBzPzovLyR7Y2xvdWRTdG9yYWdlSG9zdH0vJHtidWNrZXREb21haW59LyR7Y2xvdWRTdG9yYWdlUGF0aH1gLCAnaScpO1xuICAgICAgICBjb25zdCBjbG91ZFN0b3JhZ2VJbmRpY2VzID0geyBidWNrZXQ6IDEsIHBhdGg6IDIgfTtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gW1xuICAgICAgICAgICAgeyByZWdleDogZ3NSZWdleCwgaW5kaWNlczogZ3NJbmRpY2VzLCBwb3N0TW9kaWZ5OiBnc01vZGlmeSB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlZ2V4OiBmaXJlYmFzZVN0b3JhZ2VSZWdFeHAsXG4gICAgICAgICAgICAgICAgaW5kaWNlczogZmlyZWJhc2VTdG9yYWdlSW5kaWNlcyxcbiAgICAgICAgICAgICAgICBwb3N0TW9kaWZ5OiBodHRwTW9kaWZ5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlZ2V4OiBjbG91ZFN0b3JhZ2VSZWdFeHAsXG4gICAgICAgICAgICAgICAgaW5kaWNlczogY2xvdWRTdG9yYWdlSW5kaWNlcyxcbiAgICAgICAgICAgICAgICBwb3N0TW9kaWZ5OiBodHRwTW9kaWZ5XG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVzID0gZ3JvdXAucmVnZXguZXhlYyh1cmwpO1xuICAgICAgICAgICAgaWYgKGNhcHR1cmVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVja2V0VmFsdWUgPSBjYXB0dXJlc1tncm91cC5pbmRpY2VzLmJ1Y2tldF07XG4gICAgICAgICAgICAgICAgbGV0IHBhdGhWYWx1ZSA9IGNhcHR1cmVzW2dyb3VwLmluZGljZXMucGF0aF07XG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aFZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gbmV3IExvY2F0aW9uKGJ1Y2tldFZhbHVlLCBwYXRoVmFsdWUpO1xuICAgICAgICAgICAgICAgIGdyb3VwLnBvc3RNb2RpZnkobG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkVXJsKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIHJlcXVlc3Qgd2hvc2UgcHJvbWlzZSBhbHdheXMgZmFpbHMuXG4gKi9cbmNsYXNzIEZhaWxSZXF1ZXN0IHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICB0aGlzLnByb21pc2VfID0gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBnZXRQcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlXztcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgY2FuY2VsKF9hcHBEZWxldGUgPSBmYWxzZSkgeyB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFjY2VwdHMgYSBjYWxsYmFjayBmb3IgYW4gYWN0aW9uIHRvIHBlcmZvcm0gKGBkb1JlcXVlc3RgKSxcbiAqIGFuZCB0aGVuIGEgY2FsbGJhY2sgZm9yIHdoZW4gdGhlIGJhY2tvZmYgaGFzIGNvbXBsZXRlZCAoYGJhY2tvZmZDb21wbGV0ZUNiYCkuXG4gKiBUaGUgY2FsbGJhY2sgc2VudCB0byBzdGFydCByZXF1aXJlcyBhbiBhcmd1bWVudCB0byBjYWxsIChgb25SZXF1ZXN0Q29tcGxldGVgKS5cbiAqIFdoZW4gYHN0YXJ0YCBjYWxscyBgZG9SZXF1ZXN0YCwgaXQgcGFzc2VzIGEgY2FsbGJhY2sgZm9yIHdoZW4gdGhlIHJlcXVlc3QgaGFzXG4gKiBjb21wbGV0ZWQsIGBvblJlcXVlc3RDb21wbGV0ZWAuIEJhc2VkIG9uIHRoaXMsIHRoZSBiYWNrb2ZmIGNvbnRpbnVlcywgd2l0aFxuICogYW5vdGhlciBjYWxsIHRvIGBkb1JlcXVlc3RgIGFuZCB0aGUgYWJvdmUgbG9vcCBjb250aW51ZXMgdW50aWwgdGhlIHRpbWVvdXRcbiAqIGlzIGhpdCwgb3IgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIG9jY3Vycy5cbiAqIEBkZXNjcmlwdGlvblxuICogQHBhcmFtIGRvUmVxdWVzdCBDYWxsYmFjayB0byBwZXJmb3JtIHJlcXVlc3RcbiAqIEBwYXJhbSBiYWNrb2ZmQ29tcGxldGVDYiBDYWxsYmFjayB0byBjYWxsIHdoZW4gYmFja29mZiBoYXMgYmVlbiBjb21wbGV0ZWRcbiAqL1xuZnVuY3Rpb24gc3RhcnQoZG9SZXF1ZXN0LCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5iYWNrb2ZmQ29tcGxldGVDYiwgdGltZW91dCkge1xuICAgIC8vIFRPRE8oYW5keXNvdG8pOiBtYWtlIHRoaXMgY29kZSBjbGVhbmVyIChwcm9iYWJseSByZWZhY3RvciBpbnRvIGFuIGFjdHVhbFxuICAgIC8vIHR5cGUgaW5zdGVhZCBvZiBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyB3aXRoIHN0YXRlIHNoYXJlZCBpbiB0aGUgY2xvc3VyZSlcbiAgICBsZXQgd2FpdFNlY29uZHMgPSAxO1xuICAgIC8vIFdvdWxkIHR5cGUgdGhpcyBhcyBcIm51bWJlclwiIGJ1dCB0aGF0IGRvZXNuJ3Qgd29yayBmb3IgTm9kZSBzbyDCr1xcXyjjg4QpXy/Cr1xuICAgIC8vIFRPRE86IGZpbmQgYSB3YXkgdG8gZXhjbHVkZSBOb2RlIHR5cGUgZGVmaW5pdGlvbiBmb3Igc3RvcmFnZSBiZWNhdXNlIHN0b3JhZ2Ugb25seSB3b3JrcyBpbiBicm93c2VyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBsZXQgcmV0cnlUaW1lb3V0SWQgPSBudWxsO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgbGV0IGdsb2JhbFRpbWVvdXRJZCA9IG51bGw7XG4gICAgbGV0IGhpdFRpbWVvdXQgPSBmYWxzZTtcbiAgICBsZXQgY2FuY2VsU3RhdGUgPSAwO1xuICAgIGZ1bmN0aW9uIGNhbmNlbGVkKCkge1xuICAgICAgICByZXR1cm4gY2FuY2VsU3RhdGUgPT09IDI7XG4gICAgfVxuICAgIGxldCB0cmlnZ2VyZWRDYWxsYmFjayA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJDYWxsYmFjayguLi5hcmdzKSB7XG4gICAgICAgIGlmICghdHJpZ2dlcmVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRyaWdnZXJlZENhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIGJhY2tvZmZDb21wbGV0ZUNiLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxXaXRoRGVsYXkobWlsbGlzKSB7XG4gICAgICAgIHJldHJ5VGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZXRyeVRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICBkb1JlcXVlc3QocmVzcG9uc2VIYW5kbGVyLCBjYW5jZWxlZCgpKTtcbiAgICAgICAgfSwgbWlsbGlzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXJHbG9iYWxUaW1lb3V0KCkge1xuICAgICAgICBpZiAoZ2xvYmFsVGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZ2xvYmFsVGltZW91dElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXNwb25zZUhhbmRsZXIoc3VjY2VzcywgLi4uYXJncykge1xuICAgICAgICBpZiAodHJpZ2dlcmVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNsZWFyR2xvYmFsVGltZW91dCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICBjbGVhckdsb2JhbFRpbWVvdXQoKTtcbiAgICAgICAgICAgIHRyaWdnZXJDYWxsYmFjay5jYWxsKG51bGwsIHN1Y2Nlc3MsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG11c3RTdG9wID0gY2FuY2VsZWQoKSB8fCBoaXRUaW1lb3V0O1xuICAgICAgICBpZiAobXVzdFN0b3ApIHtcbiAgICAgICAgICAgIGNsZWFyR2xvYmFsVGltZW91dCgpO1xuICAgICAgICAgICAgdHJpZ2dlckNhbGxiYWNrLmNhbGwobnVsbCwgc3VjY2VzcywgLi4uYXJncyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdhaXRTZWNvbmRzIDwgNjQpIHtcbiAgICAgICAgICAgIC8qIFRPRE8oYW5keXNvdG8pOiBkb24ndCBiYWNrIG9mZiBzbyBxdWlja2x5IGlmIHdlIGtub3cgd2UncmUgb2ZmbGluZS4gKi9cbiAgICAgICAgICAgIHdhaXRTZWNvbmRzICo9IDI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdhaXRNaWxsaXM7XG4gICAgICAgIGlmIChjYW5jZWxTdGF0ZSA9PT0gMSkge1xuICAgICAgICAgICAgY2FuY2VsU3RhdGUgPSAyO1xuICAgICAgICAgICAgd2FpdE1pbGxpcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3YWl0TWlsbGlzID0gKHdhaXRTZWNvbmRzICsgTWF0aC5yYW5kb20oKSkgKiAxMDAwO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxXaXRoRGVsYXkod2FpdE1pbGxpcyk7XG4gICAgfVxuICAgIGxldCBzdG9wcGVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gc3RvcCh3YXNUaW1lb3V0KSB7XG4gICAgICAgIGlmIChzdG9wcGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFyR2xvYmFsVGltZW91dCgpO1xuICAgICAgICBpZiAodHJpZ2dlcmVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0cnlUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghd2FzVGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNhbmNlbFN0YXRlID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXRyeVRpbWVvdXRJZCk7XG4gICAgICAgICAgICBjYWxsV2l0aERlbGF5KDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF3YXNUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsU3RhdGUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxXaXRoRGVsYXkoMCk7XG4gICAgZ2xvYmFsVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGhpdFRpbWVvdXQgPSB0cnVlO1xuICAgICAgICBzdG9wKHRydWUpO1xuICAgIH0sIHRpbWVvdXQpO1xuICAgIHJldHVybiBzdG9wO1xufVxuLyoqXG4gKiBTdG9wcyB0aGUgcmV0cnkgbG9vcCBmcm9tIHJlcGVhdGluZy5cbiAqIElmIHRoZSBmdW5jdGlvbiBpcyBjdXJyZW50bHkgXCJpbiBiZXR3ZWVuXCIgcmV0cmllcywgaXQgaXMgaW52b2tlZCBpbW1lZGlhdGVseVxuICogd2l0aCB0aGUgc2Vjb25kIHBhcmFtZXRlciBhcyBcInRydWVcIi4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGludm9rZWQgb25jZSBtb3JlXG4gKiBhZnRlciB0aGUgY3VycmVudCBpbnZvY2F0aW9uIGZpbmlzaGVzIGlmZiB0aGUgY3VycmVudCBpbnZvY2F0aW9uIHdvdWxkIGhhdmVcbiAqIHRyaWdnZXJlZCBhbm90aGVyIHJldHJ5LlxuICovXG5mdW5jdGlvbiBzdG9wKGlkKSB7XG4gICAgaWQoZmFsc2UpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gaXNKdXN0RGVmKHApIHtcbiAgICByZXR1cm4gcCAhPT0gdm9pZCAwO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmZ1bmN0aW9uIGlzRnVuY3Rpb24ocCkge1xuICAgIHJldHVybiB0eXBlb2YgcCA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGlzTm9uQXJyYXlPYmplY3QocCkge1xuICAgIHJldHVybiB0eXBlb2YgcCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocCk7XG59XG5mdW5jdGlvbiBpc1N0cmluZyhwKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwID09PSAnc3RyaW5nJyB8fCBwIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuZnVuY3Rpb24gaXNOYXRpdmVCbG9iKHApIHtcbiAgICByZXR1cm4gaXNOYXRpdmVCbG9iRGVmaW5lZCgpICYmIHAgaW5zdGFuY2VvZiBCbG9iO1xufVxuZnVuY3Rpb24gaXNOYXRpdmVCbG9iRGVmaW5lZCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIoYXJndW1lbnQsIG1pblZhbHVlLCBtYXhWYWx1ZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPCBtaW5WYWx1ZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkQXJndW1lbnQoYEludmFsaWQgdmFsdWUgZm9yICcke2FyZ3VtZW50fScuIEV4cGVjdGVkICR7bWluVmFsdWV9IG9yIGdyZWF0ZXIuYCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+IG1heFZhbHVlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRBcmd1bWVudChgSW52YWxpZCB2YWx1ZSBmb3IgJyR7YXJndW1lbnR9Jy4gRXhwZWN0ZWQgJHttYXhWYWx1ZX0gb3IgbGVzcy5gKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBtYWtlVXJsKHVybFBhcnQsIGhvc3QsIHByb3RvY29sKSB7XG4gICAgbGV0IG9yaWdpbiA9IGhvc3Q7XG4gICAgaWYgKHByb3RvY29sID09IG51bGwpIHtcbiAgICAgICAgb3JpZ2luID0gYGh0dHBzOi8vJHtob3N0fWA7XG4gICAgfVxuICAgIHJldHVybiBgJHtwcm90b2NvbH06Ly8ke29yaWdpbn0vdjAke3VybFBhcnR9YDtcbn1cbmZ1bmN0aW9uIG1ha2VRdWVyeVN0cmluZyhwYXJhbXMpIHtcbiAgICBjb25zdCBlbmNvZGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XG4gICAgbGV0IHF1ZXJ5UGFydCA9ICc/JztcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0UGFydCA9IGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHBhcmFtc1trZXldKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFydCA9IHF1ZXJ5UGFydCArIG5leHRQYXJ0ICsgJyYnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENob3Agb2ZmIHRoZSBleHRyYSAnJicgb3IgJz8nIG9uIHRoZSBlbmRcbiAgICBxdWVyeVBhcnQgPSBxdWVyeVBhcnQuc2xpY2UoMCwgLTEpO1xuICAgIHJldHVybiBxdWVyeVBhcnQ7XG59XG5cbi8qKlxuICogRXJyb3IgY29kZXMgZm9yIHJlcXVlc3RzIG1hZGUgYnkgdGhlIFhocklvIHdyYXBwZXIuXG4gKi9cbnZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEVycm9yQ29kZSkge1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJOT19FUlJPUlwiXSA9IDBdID0gXCJOT19FUlJPUlwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJORVRXT1JLX0VSUk9SXCJdID0gMV0gPSBcIk5FVFdPUktfRVJST1JcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiQUJPUlRcIl0gPSAyXSA9IFwiQUJPUlRcIjtcbn0pKEVycm9yQ29kZSB8fCAoRXJyb3JDb2RlID0ge30pKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ2hlY2tzIHRoZSBzdGF0dXMgY29kZSB0byBzZWUgaWYgdGhlIGFjdGlvbiBzaG91bGQgYmUgcmV0cmllZC5cbiAqXG4gKiBAcGFyYW0gc3RhdHVzIEN1cnJlbnQgSFRUUCBzdGF0dXMgY29kZSByZXR1cm5lZCBieSBzZXJ2ZXIuXG4gKiBAcGFyYW0gYWRkaXRpb25hbFJldHJ5Q29kZXMgYWRkaXRpb25hbCByZXRyeSBjb2RlcyB0byBjaGVjayBhZ2FpbnN0XG4gKi9cbmZ1bmN0aW9uIGlzUmV0cnlTdGF0dXNDb2RlKHN0YXR1cywgYWRkaXRpb25hbFJldHJ5Q29kZXMpIHtcbiAgICAvLyBUaGUgY29kZXMgZm9yIHdoaWNoIHRvIHJldHJ5IGNhbWUgZnJvbSB0aGlzIHBhZ2U6XG4gICAgLy8gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3N0b3JhZ2UvZG9jcy9leHBvbmVudGlhbC1iYWNrb2ZmXG4gICAgY29uc3QgaXNGaXZlSHVuZHJlZENvZGUgPSBzdGF0dXMgPj0gNTAwICYmIHN0YXR1cyA8IDYwMDtcbiAgICBjb25zdCBleHRyYVJldHJ5Q29kZXMgPSBbXG4gICAgICAgIC8vIFJlcXVlc3QgVGltZW91dDogd2ViIHNlcnZlciBkaWRuJ3QgcmVjZWl2ZSBmdWxsIHJlcXVlc3QgaW4gdGltZS5cbiAgICAgICAgNDA4LFxuICAgICAgICAvLyBUb28gTWFueSBSZXF1ZXN0czogeW91J3JlIGdldHRpbmcgcmF0ZS1saW1pdGVkLCBiYXNpY2FsbHkuXG4gICAgICAgIDQyOVxuICAgIF07XG4gICAgY29uc3QgaXNFeHRyYVJldHJ5Q29kZSA9IGV4dHJhUmV0cnlDb2Rlcy5pbmRleE9mKHN0YXR1cykgIT09IC0xO1xuICAgIGNvbnN0IGlzQWRkaXRpb25hbFJldHJ5Q29kZSA9IGFkZGl0aW9uYWxSZXRyeUNvZGVzLmluZGV4T2Yoc3RhdHVzKSAhPT0gLTE7XG4gICAgcmV0dXJuIGlzRml2ZUh1bmRyZWRDb2RlIHx8IGlzRXh0cmFSZXRyeUNvZGUgfHwgaXNBZGRpdGlvbmFsUmV0cnlDb2RlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBIYW5kbGVzIG5ldHdvcmsgbG9naWMgZm9yIGFsbCBTdG9yYWdlIFJlcXVlc3RzLCBpbmNsdWRpbmcgZXJyb3IgcmVwb3J0aW5nIGFuZFxuICogcmV0cmllcyB3aXRoIGJhY2tvZmYuXG4gKlxuICogQHBhcmFtIEkgLSB0aGUgdHlwZSBvZiB0aGUgYmFja2VuZCdzIG5ldHdvcmsgcmVzcG9uc2UuXG4gKiBAcGFyYW0gLSBPIHRoZSBvdXRwdXQgdHlwZSB1c2VkIGJ5IHRoZSByZXN0IG9mIHRoZSBTREsuIFRoZSBjb252ZXJzaW9uXG4gKiBoYXBwZW5zIGluIHRoZSBzcGVjaWZpZWQgYGNhbGxiYWNrX2AuXG4gKi9cbmNsYXNzIE5ldHdvcmtSZXF1ZXN0IHtcbiAgICBjb25zdHJ1Y3Rvcih1cmxfLCBtZXRob2RfLCBoZWFkZXJzXywgYm9keV8sIHN1Y2Nlc3NDb2Rlc18sIGFkZGl0aW9uYWxSZXRyeUNvZGVzXywgY2FsbGJhY2tfLCBlcnJvckNhbGxiYWNrXywgdGltZW91dF8sIHByb2dyZXNzQ2FsbGJhY2tfLCBjb25uZWN0aW9uRmFjdG9yeV8sIHJldHJ5ID0gdHJ1ZSwgaXNVc2luZ0VtdWxhdG9yID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy51cmxfID0gdXJsXztcbiAgICAgICAgdGhpcy5tZXRob2RfID0gbWV0aG9kXztcbiAgICAgICAgdGhpcy5oZWFkZXJzXyA9IGhlYWRlcnNfO1xuICAgICAgICB0aGlzLmJvZHlfID0gYm9keV87XG4gICAgICAgIHRoaXMuc3VjY2Vzc0NvZGVzXyA9IHN1Y2Nlc3NDb2Rlc187XG4gICAgICAgIHRoaXMuYWRkaXRpb25hbFJldHJ5Q29kZXNfID0gYWRkaXRpb25hbFJldHJ5Q29kZXNfO1xuICAgICAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrXztcbiAgICAgICAgdGhpcy5lcnJvckNhbGxiYWNrXyA9IGVycm9yQ2FsbGJhY2tfO1xuICAgICAgICB0aGlzLnRpbWVvdXRfID0gdGltZW91dF87XG4gICAgICAgIHRoaXMucHJvZ3Jlc3NDYWxsYmFja18gPSBwcm9ncmVzc0NhbGxiYWNrXztcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uRmFjdG9yeV8gPSBjb25uZWN0aW9uRmFjdG9yeV87XG4gICAgICAgIHRoaXMucmV0cnkgPSByZXRyeTtcbiAgICAgICAgdGhpcy5pc1VzaW5nRW11bGF0b3IgPSBpc1VzaW5nRW11bGF0b3I7XG4gICAgICAgIHRoaXMucGVuZGluZ0Nvbm5lY3Rpb25fID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYWNrb2ZmSWRfID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYW5jZWxlZF8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hcHBEZWxldGVfID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvbWlzZV8gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVfID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0XyA9IHJlamVjdDtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRfKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3R1YWxseSBzdGFydHMgdGhlIHJldHJ5IGxvb3AuXG4gICAgICovXG4gICAgc3RhcnRfKCkge1xuICAgICAgICBjb25zdCBkb1RoZVJlcXVlc3QgPSAoYmFja29mZkNhbGxiYWNrLCBjYW5jZWxlZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgYmFja29mZkNhbGxiYWNrKGZhbHNlLCBuZXcgUmVxdWVzdEVuZFN0YXR1cyhmYWxzZSwgbnVsbCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb25GYWN0b3J5XygpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ29ubmVjdGlvbl8gPSBjb25uZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3NMaXN0ZW5lciA9IHByb2dyZXNzRXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRlZCA9IHByb2dyZXNzRXZlbnQubG9hZGVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsID0gcHJvZ3Jlc3NFdmVudC5sZW5ndGhDb21wdXRhYmxlID8gcHJvZ3Jlc3NFdmVudC50b3RhbCA6IC0xO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb2dyZXNzQ2FsbGJhY2tfICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NDYWxsYmFja18obG9hZGVkLCB0b3RhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2dyZXNzQ2FsbGJhY2tfICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5hZGRVcGxvYWRQcm9ncmVzc0xpc3RlbmVyKHByb2dyZXNzTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29ubmVjdGlvbi5zZW5kKCkgbmV2ZXIgcmVqZWN0cywgc28gd2UgZG9uJ3QgbmVlZCB0byBoYXZlIGEgZXJyb3IgaGFuZGxlciBvciB1c2UgY2F0Y2ggb24gdGhlIHJldHVybmVkIHByb21pc2UuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgICAgICBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgLnNlbmQodGhpcy51cmxfLCB0aGlzLm1ldGhvZF8sIHRoaXMuaXNVc2luZ0VtdWxhdG9yLCB0aGlzLmJvZHlfLCB0aGlzLmhlYWRlcnNfKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9ncmVzc0NhbGxiYWNrXyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnJlbW92ZVVwbG9hZFByb2dyZXNzTGlzdGVuZXIocHJvZ3Jlc3NMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0Nvbm5lY3Rpb25fID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCBoaXRTZXJ2ZXIgPSBjb25uZWN0aW9uLmdldEVycm9yQ29kZSgpID09PSBFcnJvckNvZGUuTk9fRVJST1I7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gY29ubmVjdGlvbi5nZXRTdGF0dXMoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhpdFNlcnZlciB8fFxuICAgICAgICAgICAgICAgICAgICAoaXNSZXRyeVN0YXR1c0NvZGUoc3RhdHVzLCB0aGlzLmFkZGl0aW9uYWxSZXRyeUNvZGVzXykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmV0cnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhc0NhbmNlbGVkID0gY29ubmVjdGlvbi5nZXRFcnJvckNvZGUoKSA9PT0gRXJyb3JDb2RlLkFCT1JUO1xuICAgICAgICAgICAgICAgICAgICBiYWNrb2ZmQ2FsbGJhY2soZmFsc2UsIG5ldyBSZXF1ZXN0RW5kU3RhdHVzKGZhbHNlLCBudWxsLCB3YXNDYW5jZWxlZCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NDb2RlID0gdGhpcy5zdWNjZXNzQ29kZXNfLmluZGV4T2Yoc3RhdHVzKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgYmFja29mZkNhbGxiYWNrKHRydWUsIG5ldyBSZXF1ZXN0RW5kU3RhdHVzKHN1Y2Nlc3NDb2RlLCBjb25uZWN0aW9uKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSByZXF1ZXN0V2VudFRocm91Z2ggLSBUcnVlIGlmIHRoZSByZXF1ZXN0IGV2ZW50dWFsbHkgd2VudFxuICAgICAgICAgKiAgICAgdGhyb3VnaCwgZmFsc2UgaWYgaXQgaGl0IHRoZSByZXRyeSBsaW1pdCBvciB3YXMgY2FuY2VsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBiYWNrb2ZmRG9uZSA9IChyZXF1ZXN0V2VudFRocm91Z2gsIHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZSA9IHRoaXMucmVzb2x2ZV87XG4gICAgICAgICAgICBjb25zdCByZWplY3QgPSB0aGlzLnJlamVjdF87XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gc3RhdHVzLmNvbm5lY3Rpb247XG4gICAgICAgICAgICBpZiAoc3RhdHVzLndhc1N1Y2Nlc3NDb2RlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jYWxsYmFja18oY29ubmVjdGlvbiwgY29ubmVjdGlvbi5nZXRSZXNwb25zZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSnVzdERlZihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IHVua25vd24oKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyLnNlcnZlclJlc3BvbnNlID0gY29ubmVjdGlvbi5nZXRFcnJvclRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3JDYWxsYmFja18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aGlzLmVycm9yQ2FsbGJhY2tfKGNvbm5lY3Rpb24sIGVycikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IHRoaXMuYXBwRGVsZXRlXyA/IGFwcERlbGV0ZWQoKSA6IGNhbmNlbGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IHJldHJ5TGltaXRFeGNlZWRlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGVkXykge1xuICAgICAgICAgICAgYmFja29mZkRvbmUoZmFsc2UsIG5ldyBSZXF1ZXN0RW5kU3RhdHVzKGZhbHNlLCBudWxsLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmZJZF8gPSBzdGFydChkb1RoZVJlcXVlc3QsIGJhY2tvZmZEb25lLCB0aGlzLnRpbWVvdXRfKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBnZXRQcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlXztcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgY2FuY2VsKGFwcERlbGV0ZSkge1xuICAgICAgICB0aGlzLmNhbmNlbGVkXyA9IHRydWU7XG4gICAgICAgIHRoaXMuYXBwRGVsZXRlXyA9IGFwcERlbGV0ZSB8fCBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuYmFja29mZklkXyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RvcCh0aGlzLmJhY2tvZmZJZF8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdDb25uZWN0aW9uXyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ29ubmVjdGlvbl8uYWJvcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZXN1bHQgb2YgYSBuZXR3b3JrIHJlcXVlc3QuXG4gKiBAcGFyYW0gb3B0X2NhbmNlbGVkIC0gRGVmYXVsdHMgdG8gZmFsc2UuXG4gKi9cbmNsYXNzIFJlcXVlc3RFbmRTdGF0dXMge1xuICAgIGNvbnN0cnVjdG9yKHdhc1N1Y2Nlc3NDb2RlLCBjb25uZWN0aW9uLCBjYW5jZWxlZCkge1xuICAgICAgICB0aGlzLndhc1N1Y2Nlc3NDb2RlID0gd2FzU3VjY2Vzc0NvZGU7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMuY2FuY2VsZWQgPSAhIWNhbmNlbGVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZEF1dGhIZWFkZXJfKGhlYWRlcnMsIGF1dGhUb2tlbikge1xuICAgIGlmIChhdXRoVG9rZW4gIT09IG51bGwgJiYgYXV0aFRva2VuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0ZpcmViYXNlICcgKyBhdXRoVG9rZW47XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkVmVyc2lvbkhlYWRlcl8oaGVhZGVycywgZmlyZWJhc2VWZXJzaW9uKSB7XG4gICAgaGVhZGVyc1snWC1GaXJlYmFzZS1TdG9yYWdlLVZlcnNpb24nXSA9XG4gICAgICAgICd3ZWJqcy8nICsgKGZpcmViYXNlVmVyc2lvbiA/PyAnQXBwTWFuYWdlcicpO1xufVxuZnVuY3Rpb24gYWRkR21waWRIZWFkZXJfKGhlYWRlcnMsIGFwcElkKSB7XG4gICAgaWYgKGFwcElkKSB7XG4gICAgICAgIGhlYWRlcnNbJ1gtRmlyZWJhc2UtR01QSUQnXSA9IGFwcElkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZEFwcENoZWNrSGVhZGVyXyhoZWFkZXJzLCBhcHBDaGVja1Rva2VuKSB7XG4gICAgaWYgKGFwcENoZWNrVG9rZW4gIT09IG51bGwpIHtcbiAgICAgICAgaGVhZGVyc1snWC1GaXJlYmFzZS1BcHBDaGVjayddID0gYXBwQ2hlY2tUb2tlbjtcbiAgICB9XG59XG5mdW5jdGlvbiBtYWtlUmVxdWVzdChyZXF1ZXN0SW5mbywgYXBwSWQsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgcmVxdWVzdEZhY3RvcnksIGZpcmViYXNlVmVyc2lvbiwgcmV0cnkgPSB0cnVlLCBpc1VzaW5nRW11bGF0b3IgPSBmYWxzZSkge1xuICAgIGNvbnN0IHF1ZXJ5UGFydCA9IG1ha2VRdWVyeVN0cmluZyhyZXF1ZXN0SW5mby51cmxQYXJhbXMpO1xuICAgIGNvbnN0IHVybCA9IHJlcXVlc3RJbmZvLnVybCArIHF1ZXJ5UGFydDtcbiAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdEluZm8uaGVhZGVycyk7XG4gICAgYWRkR21waWRIZWFkZXJfKGhlYWRlcnMsIGFwcElkKTtcbiAgICBhZGRBdXRoSGVhZGVyXyhoZWFkZXJzLCBhdXRoVG9rZW4pO1xuICAgIGFkZFZlcnNpb25IZWFkZXJfKGhlYWRlcnMsIGZpcmViYXNlVmVyc2lvbik7XG4gICAgYWRkQXBwQ2hlY2tIZWFkZXJfKGhlYWRlcnMsIGFwcENoZWNrVG9rZW4pO1xuICAgIHJldHVybiBuZXcgTmV0d29ya1JlcXVlc3QodXJsLCByZXF1ZXN0SW5mby5tZXRob2QsIGhlYWRlcnMsIHJlcXVlc3RJbmZvLmJvZHksIHJlcXVlc3RJbmZvLnN1Y2Nlc3NDb2RlcywgcmVxdWVzdEluZm8uYWRkaXRpb25hbFJldHJ5Q29kZXMsIHJlcXVlc3RJbmZvLmhhbmRsZXIsIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciwgcmVxdWVzdEluZm8udGltZW91dCwgcmVxdWVzdEluZm8ucHJvZ3Jlc3NDYWxsYmFjaywgcmVxdWVzdEZhY3RvcnksIHJldHJ5LCBpc1VzaW5nRW11bGF0b3IpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QmxvYkJ1aWxkZXIoKSB7XG4gICAgaWYgKHR5cGVvZiBCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIEJsb2JCdWlsZGVyO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgV2ViS2l0QmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBXZWJLaXRCbG9iQnVpbGRlcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBDb25jYXRlbmF0ZXMgb25lIG9yIG1vcmUgdmFsdWVzIHRvZ2V0aGVyIGFuZCBjb252ZXJ0cyB0aGVtIHRvIGEgQmxvYi5cbiAqXG4gKiBAcGFyYW0gYXJncyBUaGUgdmFsdWVzIHRoYXQgd2lsbCBtYWtlIHVwIHRoZSByZXN1bHRpbmcgYmxvYi5cbiAqIEByZXR1cm4gVGhlIGJsb2IuXG4gKi9cbmZ1bmN0aW9uIGdldEJsb2IkMSguLi5hcmdzKSB7XG4gICAgY29uc3QgQmxvYkJ1aWxkZXIgPSBnZXRCbG9iQnVpbGRlcigpO1xuICAgIGlmIChCbG9iQnVpbGRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYmIuYXBwZW5kKGFyZ3NbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYi5nZXRCbG9iKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaXNOYXRpdmVCbG9iRGVmaW5lZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2IoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuVU5TVVBQT1JURURfRU5WSVJPTk1FTlQsIFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc2VlbSB0byBzdXBwb3J0IGNyZWF0aW5nIEJsb2JzXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBTbGljZXMgdGhlIGJsb2IuIFRoZSByZXR1cm5lZCBibG9iIGNvbnRhaW5zIGRhdGEgZnJvbSB0aGUgc3RhcnQgYnl0ZVxuICogKGluY2x1c2l2ZSkgdGlsbCB0aGUgZW5kIGJ5dGUgKGV4Y2x1c2l2ZSkuIE5lZ2F0aXZlIGluZGljZXMgY2Fubm90IGJlIHVzZWQuXG4gKlxuICogQHBhcmFtIGJsb2IgVGhlIGJsb2IgdG8gYmUgc2xpY2VkLlxuICogQHBhcmFtIHN0YXJ0IEluZGV4IG9mIHRoZSBzdGFydGluZyBieXRlLlxuICogQHBhcmFtIGVuZCBJbmRleCBvZiB0aGUgZW5kaW5nIGJ5dGUuXG4gKiBAcmV0dXJuIFRoZSBibG9iIHNsaWNlIG9yIG51bGwgaWYgbm90IHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gc2xpY2VCbG9iKGJsb2IsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoYmxvYi53ZWJraXRTbGljZSkge1xuICAgICAgICByZXR1cm4gYmxvYi53ZWJraXRTbGljZShzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmxvYi5tb3pTbGljZSkge1xuICAgICAgICByZXR1cm4gYmxvYi5tb3pTbGljZShzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmxvYi5zbGljZSkge1xuICAgICAgICByZXR1cm4gYmxvYi5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogQ29udmVydHMgYSBCYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYSBiaW5hcnkgc3RyaW5nLiAqL1xuZnVuY3Rpb24gZGVjb2RlQmFzZTY0KGVuY29kZWQpIHtcbiAgICBpZiAodHlwZW9mIGF0b2IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG1pc3NpbmdQb2x5RmlsbCgnYmFzZS02NCcpO1xuICAgIH1cbiAgICByZXR1cm4gYXRvYihlbmNvZGVkKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdGhlIHBvc3NpYmxlIHN0cmluZyBmb3JtYXRzIGZvciB1cGxvYWQuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IFN0cmluZ0Zvcm1hdCA9IHtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIHN0cmluZyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgXCJyYXdcIiwgdGhhdCBpcywgYXMgbm9ybWFsIHRleHQuXG4gICAgICogVGhlIHN0cmluZyB3aWxsIGJlIGludGVycHJldGVkIGFzIFVURi0xNiwgdGhlbiB1cGxvYWRlZCBhcyBhIFVURi04IGJ5dGVcbiAgICAgKiBzZXF1ZW5jZS5cbiAgICAgKiBFeGFtcGxlOiBUaGUgc3RyaW5nICdIZWxsbyEgXFxcXHVkODNkXFxcXHVkZTBhJyBiZWNvbWVzIHRoZSBieXRlIHNlcXVlbmNlXG4gICAgICogNDggNjUgNmMgNmMgNmYgMjEgMjAgZjAgOWYgOTggOGFcbiAgICAgKi9cbiAgICBSQVc6ICdyYXcnLFxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgc3RyaW5nIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBiYXNlNjQtZW5jb2RlZCBkYXRhLlxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyAodHJhaWxpbmcgJz0ncykgYXJlIG9wdGlvbmFsLlxuICAgICAqIEV4YW1wbGU6IFRoZSBzdHJpbmcgJ3JXbU8rK0U2dDcvcmx3PT0nIGJlY29tZXMgdGhlIGJ5dGUgc2VxdWVuY2VcbiAgICAgKiBhZCA2OSA4ZSBmYiBlMSAzYSBiNyBiZiBlYiA5N1xuICAgICAqL1xuICAgIEJBU0U2NDogJ2Jhc2U2NCcsXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBzdHJpbmcgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGJhc2U2NHVybC1lbmNvZGVkIGRhdGEuXG4gICAgICogUGFkZGluZyBjaGFyYWN0ZXJzICh0cmFpbGluZyAnPSdzKSBhcmUgb3B0aW9uYWwuXG4gICAgICogRXhhbXBsZTogVGhlIHN0cmluZyAncldtTy0tRTZ0N19ybHc9PScgYmVjb21lcyB0aGUgYnl0ZSBzZXF1ZW5jZVxuICAgICAqIGFkIDY5IDhlIGZiIGUxIDNhIGI3IGJmIGViIDk3XG4gICAgICovXG4gICAgQkFTRTY0VVJMOiAnYmFzZTY0dXJsJyxcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIHN0cmluZyBpcyBhIGRhdGEgVVJMLCBzdWNoIGFzIG9uZSBvYnRhaW5lZCBmcm9tXG4gICAgICogY2FudmFzLnRvRGF0YVVSTCgpLlxuICAgICAqIEV4YW1wbGU6IHRoZSBzdHJpbmcgJ2RhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxhYWFhJ1xuICAgICAqIGJlY29tZXMgdGhlIGJ5dGUgc2VxdWVuY2VcbiAgICAgKiA2OSBhNiA5YVxuICAgICAqICh0aGUgY29udGVudC10eXBlIFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIgaXMgYWxzbyBhcHBsaWVkLCBidXQgY2FuXG4gICAgICogYmUgb3ZlcnJpZGRlbiBpbiB0aGUgbWV0YWRhdGEgb2JqZWN0KS5cbiAgICAgKi9cbiAgICBEQVRBX1VSTDogJ2RhdGFfdXJsJ1xufTtcbmNsYXNzIFN0cmluZ0RhdGEge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGNvbnRlbnRUeXBlKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuY29udGVudFR5cGUgPSBjb250ZW50VHlwZSB8fCBudWxsO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGRhdGFGcm9tU3RyaW5nKGZvcm1hdCwgc3RyaW5nRGF0YSkge1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgU3RyaW5nRm9ybWF0LlJBVzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nRGF0YSh1dGY4Qnl0ZXNfKHN0cmluZ0RhdGEpKTtcbiAgICAgICAgY2FzZSBTdHJpbmdGb3JtYXQuQkFTRTY0OlxuICAgICAgICBjYXNlIFN0cmluZ0Zvcm1hdC5CQVNFNjRVUkw6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0RhdGEoYmFzZTY0Qnl0ZXNfKGZvcm1hdCwgc3RyaW5nRGF0YSkpO1xuICAgICAgICBjYXNlIFN0cmluZ0Zvcm1hdC5EQVRBX1VSTDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nRGF0YShkYXRhVVJMQnl0ZXNfKHN0cmluZ0RhdGEpLCBkYXRhVVJMQ29udGVudFR5cGVfKHN0cmluZ0RhdGEpKTtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbiAgICAvLyBhc3NlcnQoZmFsc2UpO1xuICAgIHRocm93IHVua25vd24oKTtcbn1cbmZ1bmN0aW9uIHV0ZjhCeXRlc18odmFsdWUpIHtcbiAgICBjb25zdCBiID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYyA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDEyNykge1xuICAgICAgICAgICAgYi5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGMgPD0gMjA0Nykge1xuICAgICAgICAgICAgICAgIGIucHVzaCgxOTIgfCAoYyA+PiA2KSwgMTI4IHwgKGMgJiA2MykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKChjICYgNjQ1MTIpID09PSA1NTI5Nikge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc3RhcnQgb2YgYSBzdXJyb2dhdGUgcGFpci5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBpIDwgdmFsdWUubGVuZ3RoIC0gMSAmJiAodmFsdWUuY2hhckNvZGVBdChpICsgMSkgJiA2NDUxMikgPT09IDU2MzIwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc2Vjb25kIHN1cnJvZ2F0ZSB3YXNuJ3QgdGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goMjM5LCAxOTEsIDE4OSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoaSA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsbyA9IHZhbHVlLmNoYXJDb2RlQXQoKytpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSA2NTUzNiB8ICgoaGkgJiAxMDIzKSA8PCAxMCkgfCAobG8gJiAxMDIzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgyNDAgfCAoYyA+PiAxOCksIDEyOCB8ICgoYyA+PiAxMikgJiA2MyksIDEyOCB8ICgoYyA+PiA2KSAmIDYzKSwgMTI4IHwgKGMgJiA2MykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGMgJiA2NDUxMikgPT09IDU2MzIwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGxvdyBzdXJyb2dhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goMjM5LCAxOTEsIDE4OSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goMjI0IHwgKGMgPj4gMTIpLCAxMjggfCAoKGMgPj4gNikgJiA2MyksIDEyOCB8IChjICYgNjMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYik7XG59XG5mdW5jdGlvbiBwZXJjZW50RW5jb2RlZEJ5dGVzXyh2YWx1ZSkge1xuICAgIGxldCBkZWNvZGVkO1xuICAgIHRyeSB7XG4gICAgICAgIGRlY29kZWQgPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkRm9ybWF0KFN0cmluZ0Zvcm1hdC5EQVRBX1VSTCwgJ01hbGZvcm1lZCBkYXRhIFVSTC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0ZjhCeXRlc18oZGVjb2RlZCk7XG59XG5mdW5jdGlvbiBiYXNlNjRCeXRlc18oZm9ybWF0LCB2YWx1ZSkge1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgU3RyaW5nRm9ybWF0LkJBU0U2NDoge1xuICAgICAgICAgICAgY29uc3QgaGFzTWludXMgPSB2YWx1ZS5pbmRleE9mKCctJykgIT09IC0xO1xuICAgICAgICAgICAgY29uc3QgaGFzVW5kZXIgPSB2YWx1ZS5pbmRleE9mKCdfJykgIT09IC0xO1xuICAgICAgICAgICAgaWYgKGhhc01pbnVzIHx8IGhhc1VuZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZENoYXIgPSBoYXNNaW51cyA/ICctJyA6ICdfJztcbiAgICAgICAgICAgICAgICB0aHJvdyBpbnZhbGlkRm9ybWF0KGZvcm1hdCwgXCJJbnZhbGlkIGNoYXJhY3RlciAnXCIgK1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkQ2hhciArXG4gICAgICAgICAgICAgICAgICAgIFwiJyBmb3VuZDogaXMgaXQgYmFzZTY0dXJsIGVuY29kZWQ/XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBTdHJpbmdGb3JtYXQuQkFTRTY0VVJMOiB7XG4gICAgICAgICAgICBjb25zdCBoYXNQbHVzID0gdmFsdWUuaW5kZXhPZignKycpICE9PSAtMTtcbiAgICAgICAgICAgIGNvbnN0IGhhc1NsYXNoID0gdmFsdWUuaW5kZXhPZignLycpICE9PSAtMTtcbiAgICAgICAgICAgIGlmIChoYXNQbHVzIHx8IGhhc1NsYXNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZENoYXIgPSBoYXNQbHVzID8gJysnIDogJy8nO1xuICAgICAgICAgICAgICAgIHRocm93IGludmFsaWRGb3JtYXQoZm9ybWF0LCBcIkludmFsaWQgY2hhcmFjdGVyICdcIiArIGludmFsaWRDaGFyICsgXCInIGZvdW5kOiBpcyBpdCBiYXNlNjQgZW5jb2RlZD9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLy0vZywgJysnKS5yZXBsYWNlKC9fL2csICcvJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxuICAgIGxldCBieXRlcztcbiAgICB0cnkge1xuICAgICAgICBieXRlcyA9IGRlY29kZUJhc2U2NCh2YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLm1lc3NhZ2UuaW5jbHVkZXMoJ3BvbHlmaWxsJykpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgaW52YWxpZEZvcm1hdChmb3JtYXQsICdJbnZhbGlkIGNoYXJhY3RlciBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGVzLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmNsYXNzIERhdGFVUkxQYXJ0cyB7XG4gICAgY29uc3RydWN0b3IoZGF0YVVSTCkge1xuICAgICAgICB0aGlzLmJhc2U2NCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gbnVsbDtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGRhdGFVUkwubWF0Y2goL15kYXRhOihbXixdKyk/LC8pO1xuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgaW52YWxpZEZvcm1hdChTdHJpbmdGb3JtYXQuREFUQV9VUkwsIFwiTXVzdCBiZSBmb3JtYXR0ZWQgJ2RhdGE6WzxtZWRpYXR5cGU+XVs7YmFzZTY0XSw8ZGF0YT5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWlkZGxlID0gbWF0Y2hlc1sxXSB8fCBudWxsO1xuICAgICAgICBpZiAobWlkZGxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZTY0ID0gZW5kc1dpdGgobWlkZGxlLCAnO2Jhc2U2NCcpO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IHRoaXMuYmFzZTY0XG4gICAgICAgICAgICAgICAgPyBtaWRkbGUuc3Vic3RyaW5nKDAsIG1pZGRsZS5sZW5ndGggLSAnO2Jhc2U2NCcubGVuZ3RoKVxuICAgICAgICAgICAgICAgIDogbWlkZGxlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzdCA9IGRhdGFVUkwuc3Vic3RyaW5nKGRhdGFVUkwuaW5kZXhPZignLCcpICsgMSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGF0YVVSTEJ5dGVzXyhkYXRhVXJsKSB7XG4gICAgY29uc3QgcGFydHMgPSBuZXcgRGF0YVVSTFBhcnRzKGRhdGFVcmwpO1xuICAgIGlmIChwYXJ0cy5iYXNlNjQpIHtcbiAgICAgICAgcmV0dXJuIGJhc2U2NEJ5dGVzXyhTdHJpbmdGb3JtYXQuQkFTRTY0LCBwYXJ0cy5yZXN0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwZXJjZW50RW5jb2RlZEJ5dGVzXyhwYXJ0cy5yZXN0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBkYXRhVVJMQ29udGVudFR5cGVfKGRhdGFVcmwpIHtcbiAgICBjb25zdCBwYXJ0cyA9IG5ldyBEYXRhVVJMUGFydHMoZGF0YVVybCk7XG4gICAgcmV0dXJuIHBhcnRzLmNvbnRlbnRUeXBlO1xufVxuZnVuY3Rpb24gZW5kc1dpdGgocywgZW5kKSB7XG4gICAgY29uc3QgbG9uZ0Vub3VnaCA9IHMubGVuZ3RoID49IGVuZC5sZW5ndGg7XG4gICAgaWYgKCFsb25nRW5vdWdoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHMuc3Vic3RyaW5nKHMubGVuZ3RoIC0gZW5kLmxlbmd0aCkgPT09IGVuZDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQHBhcmFtIG9wdF9lbGlkZUNvcHkgLSBJZiB0cnVlLCBkb2Vzbid0IGNvcHkgbXV0YWJsZSBpbnB1dCBkYXRhXG4gKiAgICAgKGUuZy4gVWludDhBcnJheXMpLiBQYXNzIHRydWUgb25seSBpZiB5b3Uga25vdyB0aGUgb2JqZWN0cyB3aWxsIG5vdCBiZVxuICogICAgIG1vZGlmaWVkIGFmdGVyIHRoaXMgYmxvYidzIGNvbnN0cnVjdGlvbi5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgRmJzQmxvYiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgZWxpZGVDb3B5KSB7XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgbGV0IGJsb2JUeXBlID0gJyc7XG4gICAgICAgIGlmIChpc05hdGl2ZUJsb2IoZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YV8gPSBkYXRhO1xuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgICAgICAgIGJsb2JUeXBlID0gZGF0YS50eXBlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKGVsaWRlQ29weSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YV8gPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YV8gPSBuZXcgVWludDhBcnJheShkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YV8uc2V0KG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpemUgPSB0aGlzLmRhdGFfLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgaWYgKGVsaWRlQ29weSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YV8gPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhXyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFfLnNldChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpemUgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpemVfID0gc2l6ZTtcbiAgICAgICAgdGhpcy50eXBlXyA9IGJsb2JUeXBlO1xuICAgIH1cbiAgICBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplXztcbiAgICB9XG4gICAgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZV87XG4gICAgfVxuICAgIHNsaWNlKHN0YXJ0Qnl0ZSwgZW5kQnl0ZSkge1xuICAgICAgICBpZiAoaXNOYXRpdmVCbG9iKHRoaXMuZGF0YV8pKSB7XG4gICAgICAgICAgICBjb25zdCByZWFsQmxvYiA9IHRoaXMuZGF0YV87XG4gICAgICAgICAgICBjb25zdCBzbGljZWQgPSBzbGljZUJsb2IocmVhbEJsb2IsIHN0YXJ0Qnl0ZSwgZW5kQnl0ZSk7XG4gICAgICAgICAgICBpZiAoc2xpY2VkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZic0Jsb2Ioc2xpY2VkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhXy5idWZmZXIsIHN0YXJ0Qnl0ZSwgZW5kQnl0ZSAtIHN0YXJ0Qnl0ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZic0Jsb2Ioc2xpY2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCbG9iKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGlzTmF0aXZlQmxvYkRlZmluZWQoKSkge1xuICAgICAgICAgICAgY29uc3QgYmxvYmJ5ID0gYXJncy5tYXAoKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBGYnNCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwuZGF0YV87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYnNCbG9iKGdldEJsb2IkMS5hcHBseShudWxsLCBibG9iYnkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHVpbnQ4QXJyYXlzID0gYXJncy5tYXAoKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhRnJvbVN0cmluZyhTdHJpbmdGb3JtYXQuUkFXLCB2YWwpLmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBCbG9icyBkb24ndCBleGlzdCwgc28gdGhpcyBoYXMgdG8gYmUgYSBVaW50OEFycmF5LlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLmRhdGFfO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGZpbmFsTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHVpbnQ4QXJyYXlzLmZvckVhY2goKGFycmF5KSA9PiB7XG4gICAgICAgICAgICAgICAgZmluYWxMZW5ndGggKz0gYXJyYXkuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbmV3IFVpbnQ4QXJyYXkoZmluYWxMZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIHVpbnQ4QXJyYXlzLmZvckVhY2goKGFycmF5KSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRbaW5kZXgrK10gPSBhcnJheVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmJzQmxvYihtZXJnZWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwbG9hZERhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFfO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmV0dXJucyB0aGUgT2JqZWN0IHJlc3VsdGluZyBmcm9tIHBhcnNpbmcgdGhlIGdpdmVuIEpTT04sIG9yIG51bGwgaWYgdGhlXG4gKiBnaXZlbiBzdHJpbmcgZG9lcyBub3QgcmVwcmVzZW50IGEgSlNPTiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGpzb25PYmplY3RPck51bGwocykge1xuICAgIGxldCBvYmo7XG4gICAgdHJ5IHtcbiAgICAgICAgb2JqID0gSlNPTi5wYXJzZShzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpc05vbkFycmF5T2JqZWN0KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBDb250YWlucyBoZWxwZXIgbWV0aG9kcyBmb3IgbWFuaXB1bGF0aW5nIHBhdGhzLlxuICovXG4vKipcbiAqIEByZXR1cm4gTnVsbCBpZiB0aGUgcGF0aCBpcyBhbHJlYWR5IGF0IHRoZSByb290LlxuICovXG5mdW5jdGlvbiBwYXJlbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNvbnN0IG5ld1BhdGggPSBwYXRoLnNsaWNlKDAsIGluZGV4KTtcbiAgICByZXR1cm4gbmV3UGF0aDtcbn1cbmZ1bmN0aW9uIGNoaWxkKHBhdGgsIGNoaWxkUGF0aCkge1xuICAgIGNvbnN0IGNhbm9uaWNhbENoaWxkUGF0aCA9IGNoaWxkUGF0aFxuICAgICAgICAuc3BsaXQoJy8nKVxuICAgICAgICAuZmlsdGVyKGNvbXBvbmVudCA9PiBjb21wb25lbnQubGVuZ3RoID4gMClcbiAgICAgICAgLmpvaW4oJy8nKTtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNhbm9uaWNhbENoaWxkUGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXRoICsgJy8nICsgY2Fub25pY2FsQ2hpbGRQYXRoO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbGFzdCBjb21wb25lbnQgb2YgYSBwYXRoLlxuICogJy9mb28vYmFyJyAtPiAnYmFyJ1xuICogJy9mb28vYmFyL2Jhei8nIC0+ICdiYXovJ1xuICogJy9hJyAtPiAnYSdcbiAqL1xuZnVuY3Rpb24gbGFzdENvbXBvbmVudChwYXRoKSB7XG4gICAgY29uc3QgaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcvJywgcGF0aC5sZW5ndGggLSAyKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhdGguc2xpY2UoaW5kZXggKyAxKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBub1hmb3JtXyhtZXRhZGF0YSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5jbGFzcyBNYXBwaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXIsIGxvY2FsLCB3cml0YWJsZSwgeGZvcm0pIHtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbCB8fCBzZXJ2ZXI7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSAhIXdyaXRhYmxlO1xuICAgICAgICB0aGlzLnhmb3JtID0geGZvcm0gfHwgbm9YZm9ybV87XG4gICAgfVxufVxubGV0IG1hcHBpbmdzXyA9IG51bGw7XG5mdW5jdGlvbiB4Zm9ybVBhdGgoZnVsbFBhdGgpIHtcbiAgICBpZiAoIWlzU3RyaW5nKGZ1bGxQYXRoKSB8fCBmdWxsUGF0aC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBmdWxsUGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBsYXN0Q29tcG9uZW50KGZ1bGxQYXRoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRNYXBwaW5ncygpIHtcbiAgICBpZiAobWFwcGluZ3NfKSB7XG4gICAgICAgIHJldHVybiBtYXBwaW5nc187XG4gICAgfVxuICAgIGNvbnN0IG1hcHBpbmdzID0gW107XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnYnVja2V0JykpO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ2dlbmVyYXRpb24nKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnbWV0YWdlbmVyYXRpb24nKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnbmFtZScsICdmdWxsUGF0aCcsIHRydWUpKTtcbiAgICBmdW5jdGlvbiBtYXBwaW5nc1hmb3JtUGF0aChfbWV0YWRhdGEsIGZ1bGxQYXRoKSB7XG4gICAgICAgIHJldHVybiB4Zm9ybVBhdGgoZnVsbFBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBuYW1lTWFwcGluZyA9IG5ldyBNYXBwaW5nKCduYW1lJyk7XG4gICAgbmFtZU1hcHBpbmcueGZvcm0gPSBtYXBwaW5nc1hmb3JtUGF0aDtcbiAgICBtYXBwaW5ncy5wdXNoKG5hbWVNYXBwaW5nKTtcbiAgICAvKipcbiAgICAgKiBDb2VyY2VzIHRoZSBzZWNvbmQgcGFyYW0gdG8gYSBudW1iZXIsIGlmIGl0IGlzIGRlZmluZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24geGZvcm1TaXplKF9tZXRhZGF0YSwgc2l6ZSkge1xuICAgICAgICBpZiAoc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2l6ZU1hcHBpbmcgPSBuZXcgTWFwcGluZygnc2l6ZScpO1xuICAgIHNpemVNYXBwaW5nLnhmb3JtID0geGZvcm1TaXplO1xuICAgIG1hcHBpbmdzLnB1c2goc2l6ZU1hcHBpbmcpO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ3RpbWVDcmVhdGVkJykpO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ3VwZGF0ZWQnKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnbWQ1SGFzaCcsIG51bGwsIHRydWUpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdjYWNoZUNvbnRyb2wnLCBudWxsLCB0cnVlKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnY29udGVudERpc3Bvc2l0aW9uJywgbnVsbCwgdHJ1ZSkpO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ2NvbnRlbnRFbmNvZGluZycsIG51bGwsIHRydWUpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdjb250ZW50TGFuZ3VhZ2UnLCBudWxsLCB0cnVlKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnY29udGVudFR5cGUnLCBudWxsLCB0cnVlKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnbWV0YWRhdGEnLCAnY3VzdG9tTWV0YWRhdGEnLCB0cnVlKSk7XG4gICAgbWFwcGluZ3NfID0gbWFwcGluZ3M7XG4gICAgcmV0dXJuIG1hcHBpbmdzXztcbn1cbmZ1bmN0aW9uIGFkZFJlZihtZXRhZGF0YSwgc2VydmljZSkge1xuICAgIGZ1bmN0aW9uIGdlbmVyYXRlUmVmKCkge1xuICAgICAgICBjb25zdCBidWNrZXQgPSBtZXRhZGF0YVsnYnVja2V0J107XG4gICAgICAgIGNvbnN0IHBhdGggPSBtZXRhZGF0YVsnZnVsbFBhdGgnXTtcbiAgICAgICAgY29uc3QgbG9jID0gbmV3IExvY2F0aW9uKGJ1Y2tldCwgcGF0aCk7XG4gICAgICAgIHJldHVybiBzZXJ2aWNlLl9tYWtlU3RvcmFnZVJlZmVyZW5jZShsb2MpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0YWRhdGEsICdyZWYnLCB7IGdldDogZ2VuZXJhdGVSZWYgfSk7XG59XG5mdW5jdGlvbiBmcm9tUmVzb3VyY2Uoc2VydmljZSwgcmVzb3VyY2UsIG1hcHBpbmdzKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB7fTtcbiAgICBtZXRhZGF0YVsndHlwZSddID0gJ2ZpbGUnO1xuICAgIGNvbnN0IGxlbiA9IG1hcHBpbmdzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1hcHBpbmcgPSBtYXBwaW5nc1tpXTtcbiAgICAgICAgbWV0YWRhdGFbbWFwcGluZy5sb2NhbF0gPSBtYXBwaW5nLnhmb3JtKG1ldGFkYXRhLCByZXNvdXJjZVttYXBwaW5nLnNlcnZlcl0pO1xuICAgIH1cbiAgICBhZGRSZWYobWV0YWRhdGEsIHNlcnZpY2UpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbn1cbmZ1bmN0aW9uIGZyb21SZXNvdXJjZVN0cmluZyhzZXJ2aWNlLCByZXNvdXJjZVN0cmluZywgbWFwcGluZ3MpIHtcbiAgICBjb25zdCBvYmogPSBqc29uT2JqZWN0T3JOdWxsKHJlc291cmNlU3RyaW5nKTtcbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXNvdXJjZSA9IG9iajtcbiAgICByZXR1cm4gZnJvbVJlc291cmNlKHNlcnZpY2UsIHJlc291cmNlLCBtYXBwaW5ncyk7XG59XG5mdW5jdGlvbiBkb3dubG9hZFVybEZyb21SZXNvdXJjZVN0cmluZyhtZXRhZGF0YSwgcmVzb3VyY2VTdHJpbmcsIGhvc3QsIHByb3RvY29sKSB7XG4gICAgY29uc3Qgb2JqID0ganNvbk9iamVjdE9yTnVsbChyZXNvdXJjZVN0cmluZyk7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFpc1N0cmluZyhvYmpbJ2Rvd25sb2FkVG9rZW5zJ10pKSB7XG4gICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiBvYmplY3RzIGFyZSB1cGxvYWRlZCB0aHJvdWdoIEdDUyBhbmQgcmV0cmlldmVkXG4gICAgICAgIC8vIHRocm91Z2ggbGlzdCwgc28gd2UgZG9uJ3Qgd2FudCB0byB0aHJvdyBhbiBFcnJvci5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IG9ialsnZG93bmxvYWRUb2tlbnMnXTtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RlID0gZW5jb2RlVVJJQ29tcG9uZW50O1xuICAgIGNvbnN0IHRva2Vuc0xpc3QgPSB0b2tlbnMuc3BsaXQoJywnKTtcbiAgICBjb25zdCB1cmxzID0gdG9rZW5zTGlzdC5tYXAoKHRva2VuKSA9PiB7XG4gICAgICAgIGNvbnN0IGJ1Y2tldCA9IG1ldGFkYXRhWydidWNrZXQnXTtcbiAgICAgICAgY29uc3QgcGF0aCA9IG1ldGFkYXRhWydmdWxsUGF0aCddO1xuICAgICAgICBjb25zdCB1cmxQYXJ0ID0gJy9iLycgKyBlbmNvZGUoYnVja2V0KSArICcvby8nICsgZW5jb2RlKHBhdGgpO1xuICAgICAgICBjb25zdCBiYXNlID0gbWFrZVVybCh1cmxQYXJ0LCBob3N0LCBwcm90b2NvbCk7XG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gbWFrZVF1ZXJ5U3RyaW5nKHtcbiAgICAgICAgICAgIGFsdDogJ21lZGlhJyxcbiAgICAgICAgICAgIHRva2VuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYmFzZSArIHF1ZXJ5U3RyaW5nO1xuICAgIH0pO1xuICAgIHJldHVybiB1cmxzWzBdO1xufVxuZnVuY3Rpb24gdG9SZXNvdXJjZVN0cmluZyhtZXRhZGF0YSwgbWFwcGluZ3MpIHtcbiAgICBjb25zdCByZXNvdXJjZSA9IHt9O1xuICAgIGNvbnN0IGxlbiA9IG1hcHBpbmdzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1hcHBpbmcgPSBtYXBwaW5nc1tpXTtcbiAgICAgICAgaWYgKG1hcHBpbmcud3JpdGFibGUpIHtcbiAgICAgICAgICAgIHJlc291cmNlW21hcHBpbmcuc2VydmVyXSA9IG1ldGFkYXRhW21hcHBpbmcubG9jYWxdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXNvdXJjZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBQUkVGSVhFU19LRVkgPSAncHJlZml4ZXMnO1xuY29uc3QgSVRFTVNfS0VZID0gJ2l0ZW1zJztcbmZ1bmN0aW9uIGZyb21CYWNrZW5kUmVzcG9uc2Uoc2VydmljZSwgYnVja2V0LCByZXNvdXJjZSkge1xuICAgIGNvbnN0IGxpc3RSZXN1bHQgPSB7XG4gICAgICAgIHByZWZpeGVzOiBbXSxcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBuZXh0UGFnZVRva2VuOiByZXNvdXJjZVsnbmV4dFBhZ2VUb2tlbiddXG4gICAgfTtcbiAgICBpZiAocmVzb3VyY2VbUFJFRklYRVNfS0VZXSkge1xuICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcmVzb3VyY2VbUFJFRklYRVNfS0VZXSkge1xuICAgICAgICAgICAgY29uc3QgcGF0aFdpdGhvdXRUcmFpbGluZ1NsYXNoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gc2VydmljZS5fbWFrZVN0b3JhZ2VSZWZlcmVuY2UobmV3IExvY2F0aW9uKGJ1Y2tldCwgcGF0aFdpdGhvdXRUcmFpbGluZ1NsYXNoKSk7XG4gICAgICAgICAgICBsaXN0UmVzdWx0LnByZWZpeGVzLnB1c2gocmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzb3VyY2VbSVRFTVNfS0VZXSkge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcmVzb3VyY2VbSVRFTVNfS0VZXSkge1xuICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gc2VydmljZS5fbWFrZVN0b3JhZ2VSZWZlcmVuY2UobmV3IExvY2F0aW9uKGJ1Y2tldCwgaXRlbVsnbmFtZSddKSk7XG4gICAgICAgICAgICBsaXN0UmVzdWx0Lml0ZW1zLnB1c2gocmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlzdFJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZyb21SZXNwb25zZVN0cmluZyhzZXJ2aWNlLCBidWNrZXQsIHJlc291cmNlU3RyaW5nKSB7XG4gICAgY29uc3Qgb2JqID0ganNvbk9iamVjdE9yTnVsbChyZXNvdXJjZVN0cmluZyk7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVzb3VyY2UgPSBvYmo7XG4gICAgcmV0dXJuIGZyb21CYWNrZW5kUmVzcG9uc2Uoc2VydmljZSwgYnVja2V0LCByZXNvdXJjZSk7XG59XG5cbi8qKlxuICogQ29udGFpbnMgYSBmdWxseSBzcGVjaWZpZWQgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0gSSAtIHRoZSB0eXBlIG9mIHRoZSBiYWNrZW5kJ3MgbmV0d29yayByZXNwb25zZS5cbiAqIEBwYXJhbSBPIC0gdGhlIG91dHB1dCByZXNwb25zZSB0eXBlIHVzZWQgYnkgdGhlIHJlc3Qgb2YgdGhlIFNESy5cbiAqL1xuY2xhc3MgUmVxdWVzdEluZm8ge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgbWV0aG9kLCBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSB3aXRoIHdoaWNoIHRvIHJlc29sdmUgdGhlIHJlcXVlc3QncyBwcm9taXNlLiBPbmx5IGNhbGxlZFxuICAgICAqIGlmIHRoZSByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwuIFRocm93IGZyb20gdGhpcyBmdW5jdGlvbiB0byByZWplY3QgdGhlXG4gICAgICogcmV0dXJuZWQgUmVxdWVzdCdzIHByb21pc2Ugd2l0aCB0aGUgdGhyb3duIGVycm9yLlxuICAgICAqIE5vdGU6IFRoZSBYaHJJbyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBtYXkgYmUgcmV1c2VkIGFmdGVyIHRoaXMgY2FsbGJhY2tcbiAgICAgKiByZXR1cm5zLiBEbyBub3Qga2VlcCBhIHJlZmVyZW5jZSB0byBpdCBpbiBhbnkgd2F5LlxuICAgICAqL1xuICAgIGhhbmRsZXIsIHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICB0aGlzLnVybFBhcmFtcyA9IHt9O1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdpdGggdGhlIGN1cnJlbnQgbnVtYmVyIG9mIGJ5dGVzIHVwbG9hZGVkIGFuZCB0b3RhbCBzaXplICgtMSBpZiBub3RcbiAgICAgICAgICogY29tcHV0YWJsZSkgb2YgdGhlIHJlcXVlc3QgYm9keSAoaS5lLiB1c2VkIHRvIHJlcG9ydCB1cGxvYWQgcHJvZ3Jlc3MpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9ncmVzc0NhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdWNjZXNzQ29kZXMgPSBbMjAwXTtcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsUmV0cnlDb2RlcyA9IFtdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGhyb3dzIHRoZSBVTktOT1dOIFN0b3JhZ2VFcnJvciBpZiBjbmRuIGlzIGZhbHNlLlxuICovXG5mdW5jdGlvbiBoYW5kbGVyQ2hlY2soY25kbikge1xuICAgIGlmICghY25kbikge1xuICAgICAgICB0aHJvdyB1bmtub3duKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWV0YWRhdGFIYW5kbGVyKHNlcnZpY2UsIG1hcHBpbmdzKSB7XG4gICAgZnVuY3Rpb24gaGFuZGxlcih4aHIsIHRleHQpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBmcm9tUmVzb3VyY2VTdHJpbmcoc2VydmljZSwgdGV4dCwgbWFwcGluZ3MpO1xuICAgICAgICBoYW5kbGVyQ2hlY2sobWV0YWRhdGEgIT09IG51bGwpO1xuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyO1xufVxuZnVuY3Rpb24gbGlzdEhhbmRsZXIoc2VydmljZSwgYnVja2V0KSB7XG4gICAgZnVuY3Rpb24gaGFuZGxlcih4aHIsIHRleHQpIHtcbiAgICAgICAgY29uc3QgbGlzdFJlc3VsdCA9IGZyb21SZXNwb25zZVN0cmluZyhzZXJ2aWNlLCBidWNrZXQsIHRleHQpO1xuICAgICAgICBoYW5kbGVyQ2hlY2sobGlzdFJlc3VsdCAhPT0gbnVsbCk7XG4gICAgICAgIHJldHVybiBsaXN0UmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlcjtcbn1cbmZ1bmN0aW9uIGRvd25sb2FkVXJsSGFuZGxlcihzZXJ2aWNlLCBtYXBwaW5ncykge1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIoeGhyLCB0ZXh0KSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gZnJvbVJlc291cmNlU3RyaW5nKHNlcnZpY2UsIHRleHQsIG1hcHBpbmdzKTtcbiAgICAgICAgaGFuZGxlckNoZWNrKG1ldGFkYXRhICE9PSBudWxsKTtcbiAgICAgICAgcmV0dXJuIGRvd25sb2FkVXJsRnJvbVJlc291cmNlU3RyaW5nKG1ldGFkYXRhLCB0ZXh0LCBzZXJ2aWNlLmhvc3QsIHNlcnZpY2UuX3Byb3RvY29sKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXI7XG59XG5mdW5jdGlvbiBzaGFyZWRFcnJvckhhbmRsZXIobG9jYXRpb24pIHtcbiAgICBmdW5jdGlvbiBlcnJvckhhbmRsZXIoeGhyLCBlcnIpIHtcbiAgICAgICAgbGV0IG5ld0VycjtcbiAgICAgICAgaWYgKHhoci5nZXRTdGF0dXMoKSA9PT0gNDAxKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBUaGlzIGV4YWN0IG1lc3NhZ2Ugc3RyaW5nIGlzIHRoZSBvbmx5IGNvbnNpc3RlbnQgcGFydCBvZiB0aGVcbiAgICAgICAgICAgIC8vIHNlcnZlcidzIGVycm9yIHJlc3BvbnNlIHRoYXQgaWRlbnRpZmllcyBpdCBhcyBhbiBBcHAgQ2hlY2sgZXJyb3IuXG4gICAgICAgICAgICB4aHIuZ2V0RXJyb3JUZXh0KCkuaW5jbHVkZXMoJ0ZpcmViYXNlIEFwcCBDaGVjayB0b2tlbiBpcyBpbnZhbGlkJykpIHtcbiAgICAgICAgICAgICAgICBuZXdFcnIgPSB1bmF1dGhvcml6ZWRBcHAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0VyciA9IHVuYXV0aGVudGljYXRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHhoci5nZXRTdGF0dXMoKSA9PT0gNDAyKSB7XG4gICAgICAgICAgICAgICAgbmV3RXJyID0gcXVvdGFFeGNlZWRlZChsb2NhdGlvbi5idWNrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHhoci5nZXRTdGF0dXMoKSA9PT0gNDAzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0VyciA9IHVuYXV0aG9yaXplZChsb2NhdGlvbi5wYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0VyciA9IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3RXJyLnN0YXR1cyA9IHhoci5nZXRTdGF0dXMoKTtcbiAgICAgICAgbmV3RXJyLnNlcnZlclJlc3BvbnNlID0gZXJyLnNlcnZlclJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gbmV3RXJyO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JIYW5kbGVyO1xufVxuZnVuY3Rpb24gb2JqZWN0RXJyb3JIYW5kbGVyKGxvY2F0aW9uKSB7XG4gICAgY29uc3Qgc2hhcmVkID0gc2hhcmVkRXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcbiAgICBmdW5jdGlvbiBlcnJvckhhbmRsZXIoeGhyLCBlcnIpIHtcbiAgICAgICAgbGV0IG5ld0VyciA9IHNoYXJlZCh4aHIsIGVycik7XG4gICAgICAgIGlmICh4aHIuZ2V0U3RhdHVzKCkgPT09IDQwNCkge1xuICAgICAgICAgICAgbmV3RXJyID0gb2JqZWN0Tm90Rm91bmQobG9jYXRpb24ucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3RXJyLnNlcnZlclJlc3BvbnNlID0gZXJyLnNlcnZlclJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gbmV3RXJyO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JIYW5kbGVyO1xufVxuZnVuY3Rpb24gZ2V0TWV0YWRhdGEkMihzZXJ2aWNlLCBsb2NhdGlvbiwgbWFwcGluZ3MpIHtcbiAgICBjb25zdCB1cmxQYXJ0ID0gbG9jYXRpb24uZnVsbFNlcnZlclVybCgpO1xuICAgIGNvbnN0IHVybCA9IG1ha2VVcmwodXJsUGFydCwgc2VydmljZS5ob3N0LCBzZXJ2aWNlLl9wcm90b2NvbCk7XG4gICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgY29uc3QgdGltZW91dCA9IHNlcnZpY2UubWF4T3BlcmF0aW9uUmV0cnlUaW1lO1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBtZXRhZGF0YUhhbmRsZXIoc2VydmljZSwgbWFwcGluZ3MpLCB0aW1lb3V0KTtcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBvYmplY3RFcnJvckhhbmRsZXIobG9jYXRpb24pO1xuICAgIHJldHVybiByZXF1ZXN0SW5mbztcbn1cbmZ1bmN0aW9uIGxpc3QkMihzZXJ2aWNlLCBsb2NhdGlvbiwgZGVsaW1pdGVyLCBwYWdlVG9rZW4sIG1heFJlc3VsdHMpIHtcbiAgICBjb25zdCB1cmxQYXJhbXMgPSB7fTtcbiAgICBpZiAobG9jYXRpb24uaXNSb290KSB7XG4gICAgICAgIHVybFBhcmFtc1sncHJlZml4J10gPSAnJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVybFBhcmFtc1sncHJlZml4J10gPSBsb2NhdGlvbi5wYXRoICsgJy8nO1xuICAgIH1cbiAgICBpZiAoZGVsaW1pdGVyICYmIGRlbGltaXRlci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHVybFBhcmFtc1snZGVsaW1pdGVyJ10gPSBkZWxpbWl0ZXI7XG4gICAgfVxuICAgIGlmIChwYWdlVG9rZW4pIHtcbiAgICAgICAgdXJsUGFyYW1zWydwYWdlVG9rZW4nXSA9IHBhZ2VUb2tlbjtcbiAgICB9XG4gICAgaWYgKG1heFJlc3VsdHMpIHtcbiAgICAgICAgdXJsUGFyYW1zWydtYXhSZXN1bHRzJ10gPSBtYXhSZXN1bHRzO1xuICAgIH1cbiAgICBjb25zdCB1cmxQYXJ0ID0gbG9jYXRpb24uYnVja2V0T25seVNlcnZlclVybCgpO1xuICAgIGNvbnN0IHVybCA9IG1ha2VVcmwodXJsUGFydCwgc2VydmljZS5ob3N0LCBzZXJ2aWNlLl9wcm90b2NvbCk7XG4gICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgY29uc3QgdGltZW91dCA9IHNlcnZpY2UubWF4T3BlcmF0aW9uUmV0cnlUaW1lO1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBsaXN0SGFuZGxlcihzZXJ2aWNlLCBsb2NhdGlvbi5idWNrZXQpLCB0aW1lb3V0KTtcbiAgICByZXF1ZXN0SW5mby51cmxQYXJhbXMgPSB1cmxQYXJhbXM7XG4gICAgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyID0gc2hhcmVkRXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XG59XG5mdW5jdGlvbiBnZXRCeXRlcyQxKHNlcnZpY2UsIGxvY2F0aW9uLCBtYXhEb3dubG9hZFNpemVCeXRlcykge1xuICAgIGNvbnN0IHVybFBhcnQgPSBsb2NhdGlvbi5mdWxsU2VydmVyVXJsKCk7XG4gICAgY29uc3QgdXJsID0gbWFrZVVybCh1cmxQYXJ0LCBzZXJ2aWNlLmhvc3QsIHNlcnZpY2UuX3Byb3RvY29sKSArICc/YWx0PW1lZGlhJztcbiAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhPcGVyYXRpb25SZXRyeVRpbWU7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBuZXcgUmVxdWVzdEluZm8odXJsLCBtZXRob2QsIChfLCBkYXRhKSA9PiBkYXRhLCB0aW1lb3V0KTtcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBvYmplY3RFcnJvckhhbmRsZXIobG9jYXRpb24pO1xuICAgIGlmIChtYXhEb3dubG9hZFNpemVCeXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcXVlc3RJbmZvLmhlYWRlcnNbJ1JhbmdlJ10gPSBgYnl0ZXM9MC0ke21heERvd25sb2FkU2l6ZUJ5dGVzfWA7XG4gICAgICAgIHJlcXVlc3RJbmZvLnN1Y2Nlc3NDb2RlcyA9IFsyMDAgLyogT0sgKi8sIDIwNiAvKiBQYXJ0aWFsIENvbnRlbnQgKi9dO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdEluZm87XG59XG5mdW5jdGlvbiBnZXREb3dubG9hZFVybChzZXJ2aWNlLCBsb2NhdGlvbiwgbWFwcGluZ3MpIHtcbiAgICBjb25zdCB1cmxQYXJ0ID0gbG9jYXRpb24uZnVsbFNlcnZlclVybCgpO1xuICAgIGNvbnN0IHVybCA9IG1ha2VVcmwodXJsUGFydCwgc2VydmljZS5ob3N0LCBzZXJ2aWNlLl9wcm90b2NvbCk7XG4gICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgY29uc3QgdGltZW91dCA9IHNlcnZpY2UubWF4T3BlcmF0aW9uUmV0cnlUaW1lO1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBkb3dubG9hZFVybEhhbmRsZXIoc2VydmljZSwgbWFwcGluZ3MpLCB0aW1lb3V0KTtcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBvYmplY3RFcnJvckhhbmRsZXIobG9jYXRpb24pO1xuICAgIHJldHVybiByZXF1ZXN0SW5mbztcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1ldGFkYXRhJDIoc2VydmljZSwgbG9jYXRpb24sIG1ldGFkYXRhLCBtYXBwaW5ncykge1xuICAgIGNvbnN0IHVybFBhcnQgPSBsb2NhdGlvbi5mdWxsU2VydmVyVXJsKCk7XG4gICAgY29uc3QgdXJsID0gbWFrZVVybCh1cmxQYXJ0LCBzZXJ2aWNlLmhvc3QsIHNlcnZpY2UuX3Byb3RvY29sKTtcbiAgICBjb25zdCBtZXRob2QgPSAnUEFUQ0gnO1xuICAgIGNvbnN0IGJvZHkgPSB0b1Jlc291cmNlU3RyaW5nKG1ldGFkYXRhLCBtYXBwaW5ncyk7XG4gICAgY29uc3QgaGVhZGVycyA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04JyB9O1xuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXJ2aWNlLm1heE9wZXJhdGlvblJldHJ5VGltZTtcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgbWV0YWRhdGFIYW5kbGVyKHNlcnZpY2UsIG1hcHBpbmdzKSwgdGltZW91dCk7XG4gICAgcmVxdWVzdEluZm8uaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgcmVxdWVzdEluZm8uYm9keSA9IGJvZHk7XG4gICAgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyID0gb2JqZWN0RXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XG59XG5mdW5jdGlvbiBkZWxldGVPYmplY3QkMihzZXJ2aWNlLCBsb2NhdGlvbikge1xuICAgIGNvbnN0IHVybFBhcnQgPSBsb2NhdGlvbi5mdWxsU2VydmVyVXJsKCk7XG4gICAgY29uc3QgdXJsID0gbWFrZVVybCh1cmxQYXJ0LCBzZXJ2aWNlLmhvc3QsIHNlcnZpY2UuX3Byb3RvY29sKTtcbiAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhPcGVyYXRpb25SZXRyeVRpbWU7XG4gICAgZnVuY3Rpb24gaGFuZGxlcihfeGhyLCBfdGV4dCkgeyB9XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBuZXcgUmVxdWVzdEluZm8odXJsLCBtZXRob2QsIGhhbmRsZXIsIHRpbWVvdXQpO1xuICAgIHJlcXVlc3RJbmZvLnN1Y2Nlc3NDb2RlcyA9IFsyMDAsIDIwNF07XG4gICAgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyID0gb2JqZWN0RXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVDb250ZW50VHlwZV8obWV0YWRhdGEsIGJsb2IpIHtcbiAgICByZXR1cm4gKChtZXRhZGF0YSAmJiBtZXRhZGF0YVsnY29udGVudFR5cGUnXSkgfHxcbiAgICAgICAgKGJsb2IgJiYgYmxvYi50eXBlKCkpIHx8XG4gICAgICAgICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbn1cbmZ1bmN0aW9uIG1ldGFkYXRhRm9yVXBsb2FkXyhsb2NhdGlvbiwgYmxvYiwgbWV0YWRhdGEpIHtcbiAgICBjb25zdCBtZXRhZGF0YUNsb25lID0gT2JqZWN0LmFzc2lnbih7fSwgbWV0YWRhdGEpO1xuICAgIG1ldGFkYXRhQ2xvbmVbJ2Z1bGxQYXRoJ10gPSBsb2NhdGlvbi5wYXRoO1xuICAgIG1ldGFkYXRhQ2xvbmVbJ3NpemUnXSA9IGJsb2Iuc2l6ZSgpO1xuICAgIGlmICghbWV0YWRhdGFDbG9uZVsnY29udGVudFR5cGUnXSkge1xuICAgICAgICBtZXRhZGF0YUNsb25lWydjb250ZW50VHlwZSddID0gZGV0ZXJtaW5lQ29udGVudFR5cGVfKG51bGwsIGJsb2IpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YWRhdGFDbG9uZTtcbn1cbi8qKlxuICogUHJlcGFyZSBSZXF1ZXN0SW5mbyBmb3IgdXBsb2FkcyBhcyBDb250ZW50LVR5cGU6IG11bHRpcGFydC5cbiAqL1xuZnVuY3Rpb24gbXVsdGlwYXJ0VXBsb2FkKHNlcnZpY2UsIGxvY2F0aW9uLCBtYXBwaW5ncywgYmxvYiwgbWV0YWRhdGEpIHtcbiAgICBjb25zdCB1cmxQYXJ0ID0gbG9jYXRpb24uYnVja2V0T25seVNlcnZlclVybCgpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICdYLUdvb2ctVXBsb2FkLVByb3RvY29sJzogJ211bHRpcGFydCdcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdlbkJvdW5kYXJ5KCkge1xuICAgICAgICBsZXQgc3RyID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc2xpY2UoMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgY29uc3QgYm91bmRhcnkgPSBnZW5Cb3VuZGFyeSgpO1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ211bHRpcGFydC9yZWxhdGVkOyBib3VuZGFyeT0nICsgYm91bmRhcnk7XG4gICAgY29uc3QgbWV0YWRhdGFfID0gbWV0YWRhdGFGb3JVcGxvYWRfKGxvY2F0aW9uLCBibG9iLCBtZXRhZGF0YSk7XG4gICAgY29uc3QgbWV0YWRhdGFTdHJpbmcgPSB0b1Jlc291cmNlU3RyaW5nKG1ldGFkYXRhXywgbWFwcGluZ3MpO1xuICAgIGNvbnN0IHByZUJsb2JQYXJ0ID0gJy0tJyArXG4gICAgICAgIGJvdW5kYXJ5ICtcbiAgICAgICAgJ1xcclxcbicgK1xuICAgICAgICAnQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XFxyXFxuXFxyXFxuJyArXG4gICAgICAgIG1ldGFkYXRhU3RyaW5nICtcbiAgICAgICAgJ1xcclxcbi0tJyArXG4gICAgICAgIGJvdW5kYXJ5ICtcbiAgICAgICAgJ1xcclxcbicgK1xuICAgICAgICAnQ29udGVudC1UeXBlOiAnICtcbiAgICAgICAgbWV0YWRhdGFfWydjb250ZW50VHlwZSddICtcbiAgICAgICAgJ1xcclxcblxcclxcbic7XG4gICAgY29uc3QgcG9zdEJsb2JQYXJ0ID0gJ1xcclxcbi0tJyArIGJvdW5kYXJ5ICsgJy0tJztcbiAgICBjb25zdCBib2R5ID0gRmJzQmxvYi5nZXRCbG9iKHByZUJsb2JQYXJ0LCBibG9iLCBwb3N0QmxvYlBhcnQpO1xuICAgIGlmIChib2R5ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IGNhbm5vdFNsaWNlQmxvYigpO1xuICAgIH1cbiAgICBjb25zdCB1cmxQYXJhbXMgPSB7IG5hbWU6IG1ldGFkYXRhX1snZnVsbFBhdGgnXSB9O1xuICAgIGNvbnN0IHVybCA9IG1ha2VVcmwodXJsUGFydCwgc2VydmljZS5ob3N0LCBzZXJ2aWNlLl9wcm90b2NvbCk7XG4gICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXJ2aWNlLm1heFVwbG9hZFJldHJ5VGltZTtcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgbWV0YWRhdGFIYW5kbGVyKHNlcnZpY2UsIG1hcHBpbmdzKSwgdGltZW91dCk7XG4gICAgcmVxdWVzdEluZm8udXJsUGFyYW1zID0gdXJsUGFyYW1zO1xuICAgIHJlcXVlc3RJbmZvLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHJlcXVlc3RJbmZvLmJvZHkgPSBib2R5LnVwbG9hZERhdGEoKTtcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBzaGFyZWRFcnJvckhhbmRsZXIobG9jYXRpb24pO1xuICAgIHJldHVybiByZXF1ZXN0SW5mbztcbn1cbi8qKlxuICogQHBhcmFtIGN1cnJlbnQgVGhlIG51bWJlciBvZiBieXRlcyB0aGF0IGhhdmUgYmVlbiB1cGxvYWRlZCBzbyBmYXIuXG4gKiBAcGFyYW0gdG90YWwgVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyBpbiB0aGUgdXBsb2FkLlxuICogQHBhcmFtIG9wdF9maW5hbGl6ZWQgVHJ1ZSBpZiB0aGUgc2VydmVyIGhhcyBmaW5pc2hlZCB0aGUgdXBsb2FkLlxuICogQHBhcmFtIG9wdF9tZXRhZGF0YSBUaGUgdXBsb2FkIG1ldGFkYXRhLCBzaG91bGRcbiAqICAgICBvbmx5IGJlIHBhc3NlZCBpZiBvcHRfZmluYWxpemVkIGlzIHRydWUuXG4gKi9cbmNsYXNzIFJlc3VtYWJsZVVwbG9hZFN0YXR1cyB7XG4gICAgY29uc3RydWN0b3IoY3VycmVudCwgdG90YWwsIGZpbmFsaXplZCwgbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLmZpbmFsaXplZCA9ICEhZmluYWxpemVkO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGEgfHwgbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1Jlc3VtZUhlYWRlcl8oeGhyLCBhbGxvd2VkKSB7XG4gICAgbGV0IHN0YXR1cyA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgICAgc3RhdHVzID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdYLUdvb2ctVXBsb2FkLVN0YXR1cycpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVyQ2hlY2soZmFsc2UpO1xuICAgIH1cbiAgICBjb25zdCBhbGxvd2VkU3RhdHVzID0gYWxsb3dlZCB8fCBbJ2FjdGl2ZSddO1xuICAgIGhhbmRsZXJDaGVjayghIXN0YXR1cyAmJiBhbGxvd2VkU3RhdHVzLmluZGV4T2Yoc3RhdHVzKSAhPT0gLTEpO1xuICAgIHJldHVybiBzdGF0dXM7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXN1bWFibGVVcGxvYWQoc2VydmljZSwgbG9jYXRpb24sIG1hcHBpbmdzLCBibG9iLCBtZXRhZGF0YSkge1xuICAgIGNvbnN0IHVybFBhcnQgPSBsb2NhdGlvbi5idWNrZXRPbmx5U2VydmVyVXJsKCk7XG4gICAgY29uc3QgbWV0YWRhdGFGb3JVcGxvYWQgPSBtZXRhZGF0YUZvclVwbG9hZF8obG9jYXRpb24sIGJsb2IsIG1ldGFkYXRhKTtcbiAgICBjb25zdCB1cmxQYXJhbXMgPSB7IG5hbWU6IG1ldGFkYXRhRm9yVXBsb2FkWydmdWxsUGF0aCddIH07XG4gICAgY29uc3QgdXJsID0gbWFrZVVybCh1cmxQYXJ0LCBzZXJ2aWNlLmhvc3QsIHNlcnZpY2UuX3Byb3RvY29sKTtcbiAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgJ1gtR29vZy1VcGxvYWQtUHJvdG9jb2wnOiAncmVzdW1hYmxlJyxcbiAgICAgICAgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6ICdzdGFydCcsXG4gICAgICAgICdYLUdvb2ctVXBsb2FkLUhlYWRlci1Db250ZW50LUxlbmd0aCc6IGAke2Jsb2Iuc2l6ZSgpfWAsXG4gICAgICAgICdYLUdvb2ctVXBsb2FkLUhlYWRlci1Db250ZW50LVR5cGUnOiBtZXRhZGF0YUZvclVwbG9hZFsnY29udGVudFR5cGUnXSxcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04J1xuICAgIH07XG4gICAgY29uc3QgYm9keSA9IHRvUmVzb3VyY2VTdHJpbmcobWV0YWRhdGFGb3JVcGxvYWQsIG1hcHBpbmdzKTtcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhVcGxvYWRSZXRyeVRpbWU7XG4gICAgZnVuY3Rpb24gaGFuZGxlcih4aHIpIHtcbiAgICAgICAgY2hlY2tSZXN1bWVIZWFkZXJfKHhocik7XG4gICAgICAgIGxldCB1cmw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1cmwgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtR29vZy1VcGxvYWQtVVJMJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZXJDaGVjayhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlckNoZWNrKGlzU3RyaW5nKHVybCkpO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgaGFuZGxlciwgdGltZW91dCk7XG4gICAgcmVxdWVzdEluZm8udXJsUGFyYW1zID0gdXJsUGFyYW1zO1xuICAgIHJlcXVlc3RJbmZvLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHJlcXVlc3RJbmZvLmJvZHkgPSBib2R5O1xuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbik7XG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xufVxuLyoqXG4gKiBAcGFyYW0gdXJsIEZyb20gYSBjYWxsIHRvIGZicy5yZXF1ZXN0cy5jcmVhdGVSZXN1bWFibGVVcGxvYWQuXG4gKi9cbmZ1bmN0aW9uIGdldFJlc3VtYWJsZVVwbG9hZFN0YXR1cyhzZXJ2aWNlLCBsb2NhdGlvbiwgdXJsLCBibG9iKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHsgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6ICdxdWVyeScgfTtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKHhocikge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBjaGVja1Jlc3VtZUhlYWRlcl8oeGhyLCBbJ2FjdGl2ZScsICdmaW5hbCddKTtcbiAgICAgICAgbGV0IHNpemVTdHJpbmcgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2l6ZVN0cmluZyA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1Hb29nLVVwbG9hZC1TaXplLVJlY2VpdmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZXJDaGVjayhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaXplU3RyaW5nKSB7XG4gICAgICAgICAgICAvLyBudWxsIG9yIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgaGFuZGxlckNoZWNrKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplID0gTnVtYmVyKHNpemVTdHJpbmcpO1xuICAgICAgICBoYW5kbGVyQ2hlY2soIWlzTmFOKHNpemUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bWFibGVVcGxvYWRTdGF0dXMoc2l6ZSwgYmxvYi5zaXplKCksIHN0YXR1cyA9PT0gJ2ZpbmFsJyk7XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhVcGxvYWRSZXRyeVRpbWU7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBuZXcgUmVxdWVzdEluZm8odXJsLCBtZXRob2QsIGhhbmRsZXIsIHRpbWVvdXQpO1xuICAgIHJlcXVlc3RJbmZvLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbik7XG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xufVxuLyoqXG4gKiBBbnkgdXBsb2FkcyB2aWEgdGhlIHJlc3VtYWJsZSB1cGxvYWQgQVBJIG11c3QgdHJhbnNmZXIgYSBudW1iZXIgb2YgYnl0ZXNcbiAqIHRoYXQgaXMgYSBtdWx0aXBsZSBvZiB0aGlzIG51bWJlci5cbiAqL1xuY29uc3QgUkVTVU1BQkxFX1VQTE9BRF9DSFVOS19TSVpFID0gMjU2ICogMTAyNDtcbi8qKlxuICogQHBhcmFtIHVybCBGcm9tIGEgY2FsbCB0byBmYnMucmVxdWVzdHMuY3JlYXRlUmVzdW1hYmxlVXBsb2FkLlxuICogQHBhcmFtIGNodW5rU2l6ZSBOdW1iZXIgb2YgYnl0ZXMgdG8gdXBsb2FkLlxuICogQHBhcmFtIHN0YXR1cyBUaGUgcHJldmlvdXMgc3RhdHVzLlxuICogICAgIElmIG5vdCBwYXNzZWQgb3IgbnVsbCwgd2Ugc3RhcnQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICogQHRocm93cyBmYnMuRXJyb3IgSWYgdGhlIHVwbG9hZCBpcyBhbHJlYWR5IGNvbXBsZXRlLCB0aGUgcGFzc2VkIGluIHN0YXR1c1xuICogICAgIGhhcyBhIGZpbmFsIHNpemUgaW5jb25zaXN0ZW50IHdpdGggdGhlIGJsb2IsIG9yIHRoZSBibG9iIGNhbm5vdCBiZSBzbGljZWRcbiAqICAgICBmb3IgdXBsb2FkLlxuICovXG5mdW5jdGlvbiBjb250aW51ZVJlc3VtYWJsZVVwbG9hZChsb2NhdGlvbiwgc2VydmljZSwgdXJsLCBibG9iLCBjaHVua1NpemUsIG1hcHBpbmdzLCBzdGF0dXMsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAvLyBUT0RPKGFuZHlzb3RvKTogc3RhbmRhcmRpemUgb24gaW50ZXJuYWwgYXNzZXJ0c1xuICAgIC8vIGFzc2VydCghKG9wdF9zdGF0dXMgJiYgb3B0X3N0YXR1cy5maW5hbGl6ZWQpKTtcbiAgICBjb25zdCBzdGF0dXNfID0gbmV3IFJlc3VtYWJsZVVwbG9hZFN0YXR1cygwLCAwKTtcbiAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgIHN0YXR1c18uY3VycmVudCA9IHN0YXR1cy5jdXJyZW50O1xuICAgICAgICBzdGF0dXNfLnRvdGFsID0gc3RhdHVzLnRvdGFsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhdHVzXy5jdXJyZW50ID0gMDtcbiAgICAgICAgc3RhdHVzXy50b3RhbCA9IGJsb2Iuc2l6ZSgpO1xuICAgIH1cbiAgICBpZiAoYmxvYi5zaXplKCkgIT09IHN0YXR1c18udG90YWwpIHtcbiAgICAgICAgdGhyb3cgc2VydmVyRmlsZVdyb25nU2l6ZSgpO1xuICAgIH1cbiAgICBjb25zdCBieXRlc0xlZnQgPSBzdGF0dXNfLnRvdGFsIC0gc3RhdHVzXy5jdXJyZW50O1xuICAgIGxldCBieXRlc1RvVXBsb2FkID0gYnl0ZXNMZWZ0O1xuICAgIGlmIChjaHVua1NpemUgPiAwKSB7XG4gICAgICAgIGJ5dGVzVG9VcGxvYWQgPSBNYXRoLm1pbihieXRlc1RvVXBsb2FkLCBjaHVua1NpemUpO1xuICAgIH1cbiAgICBjb25zdCBzdGFydEJ5dGUgPSBzdGF0dXNfLmN1cnJlbnQ7XG4gICAgY29uc3QgZW5kQnl0ZSA9IHN0YXJ0Qnl0ZSArIGJ5dGVzVG9VcGxvYWQ7XG4gICAgbGV0IHVwbG9hZENvbW1hbmQgPSAnJztcbiAgICBpZiAoYnl0ZXNUb1VwbG9hZCA9PT0gMCkge1xuICAgICAgICB1cGxvYWRDb21tYW5kID0gJ2ZpbmFsaXplJztcbiAgICB9XG4gICAgZWxzZSBpZiAoYnl0ZXNMZWZ0ID09PSBieXRlc1RvVXBsb2FkKSB7XG4gICAgICAgIHVwbG9hZENvbW1hbmQgPSAndXBsb2FkLCBmaW5hbGl6ZSc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1cGxvYWRDb21tYW5kID0gJ3VwbG9hZCc7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICdYLUdvb2ctVXBsb2FkLUNvbW1hbmQnOiB1cGxvYWRDb21tYW5kLFxuICAgICAgICAnWC1Hb29nLVVwbG9hZC1PZmZzZXQnOiBgJHtzdGF0dXNfLmN1cnJlbnR9YFxuICAgIH07XG4gICAgY29uc3QgYm9keSA9IGJsb2Iuc2xpY2Uoc3RhcnRCeXRlLCBlbmRCeXRlKTtcbiAgICBpZiAoYm9keSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBjYW5ub3RTbGljZUJsb2IoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlcih4aHIsIHRleHQpIHtcbiAgICAgICAgLy8gVE9ETyhhbmR5c290byk6IFZlcmlmeSB0aGUgTUQ1IG9mIGVhY2ggdXBsb2FkZWQgcmFuZ2U6XG4gICAgICAgIC8vIHRoZSAneC1yYW5nZS1tZDUnIGhlYWRlciBjb21lcyBiYWNrIHdpdGggc3RhdHVzIGNvZGUgMzA4IHJlc3BvbnNlcy5cbiAgICAgICAgLy8gV2UnbGwgb25seSBiZSBhYmxlIHRvIGJhaWwgb3V0IHRob3VnaCwgYmVjYXVzZSB5b3UgY2FuJ3QgcmUtdXBsb2FkIGFcbiAgICAgICAgLy8gcmFuZ2UgdGhhdCB5b3UgcHJldmlvdXNseSB1cGxvYWRlZC5cbiAgICAgICAgY29uc3QgdXBsb2FkU3RhdHVzID0gY2hlY2tSZXN1bWVIZWFkZXJfKHhociwgWydhY3RpdmUnLCAnZmluYWwnXSk7XG4gICAgICAgIGNvbnN0IG5ld0N1cnJlbnQgPSBzdGF0dXNfLmN1cnJlbnQgKyBieXRlc1RvVXBsb2FkO1xuICAgICAgICBjb25zdCBzaXplID0gYmxvYi5zaXplKCk7XG4gICAgICAgIGxldCBtZXRhZGF0YTtcbiAgICAgICAgaWYgKHVwbG9hZFN0YXR1cyA9PT0gJ2ZpbmFsJykge1xuICAgICAgICAgICAgbWV0YWRhdGEgPSBtZXRhZGF0YUhhbmRsZXIoc2VydmljZSwgbWFwcGluZ3MpKHhociwgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bWFibGVVcGxvYWRTdGF0dXMobmV3Q3VycmVudCwgc2l6ZSwgdXBsb2FkU3RhdHVzID09PSAnZmluYWwnLCBtZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhVcGxvYWRSZXRyeVRpbWU7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBuZXcgUmVxdWVzdEluZm8odXJsLCBtZXRob2QsIGhhbmRsZXIsIHRpbWVvdXQpO1xuICAgIHJlcXVlc3RJbmZvLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHJlcXVlc3RJbmZvLmJvZHkgPSBib2R5LnVwbG9hZERhdGEoKTtcbiAgICByZXF1ZXN0SW5mby5wcm9ncmVzc0NhbGxiYWNrID0gcHJvZ3Jlc3NDYWxsYmFjayB8fCBudWxsO1xuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbik7XG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIHRyaWdnZXJlZCBvbiBhIHRhc2suXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgVGFza0V2ZW50ID0ge1xuICAgIC8qKlxuICAgICAqIEZvciB0aGlzIGV2ZW50LFxuICAgICAqIDx1bD5cbiAgICAgKiAgIDxsaT5UaGUgYG5leHRgIGZ1bmN0aW9uIGlzIHRyaWdnZXJlZCBvbiBwcm9ncmVzcyB1cGRhdGVzIGFuZCB3aGVuIHRoZVxuICAgICAqICAgICAgIHRhc2sgaXMgcGF1c2VkL3Jlc3VtZWQgd2l0aCBhbiBgVXBsb2FkVGFza1NuYXBzaG90YCBhcyB0aGUgZmlyc3RcbiAgICAgKiAgICAgICBhcmd1bWVudC48L2xpPlxuICAgICAqICAgPGxpPlRoZSBgZXJyb3JgIGZ1bmN0aW9uIGlzIHRyaWdnZXJlZCBpZiB0aGUgdXBsb2FkIGlzIGNhbmNlbGVkIG9yIGZhaWxzXG4gICAgICogICAgICAgZm9yIGFub3RoZXIgcmVhc29uLjwvbGk+XG4gICAgICogICA8bGk+VGhlIGBjb21wbGV0ZWAgZnVuY3Rpb24gaXMgdHJpZ2dlcmVkIGlmIHRoZSB1cGxvYWQgY29tcGxldGVzXG4gICAgICogICAgICAgc3VjY2Vzc2Z1bGx5LjwvbGk+XG4gICAgICogPC91bD5cbiAgICAgKi9cbiAgICBTVEFURV9DSEFOR0VEOiAnc3RhdGVfY2hhbmdlZCdcbn07XG4vLyB0eXBlIGtleXMgPSBrZXlvZiBUYXNrU3RhdGVcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY3VycmVudCBzdGF0ZSBvZiBhIHJ1bm5pbmcgdXBsb2FkLlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFRhc2tTdGF0ZSA9IHtcbiAgICAvKiogVGhlIHRhc2sgaXMgY3VycmVudGx5IHRyYW5zZmVycmluZyBkYXRhLiAqL1xuICAgIFJVTk5JTkc6ICdydW5uaW5nJyxcbiAgICAvKiogVGhlIHRhc2sgd2FzIHBhdXNlZCBieSB0aGUgdXNlci4gKi9cbiAgICBQQVVTRUQ6ICdwYXVzZWQnLFxuICAgIC8qKiBUaGUgdGFzayBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiAqL1xuICAgIFNVQ0NFU1M6ICdzdWNjZXNzJyxcbiAgICAvKiogVGhlIHRhc2sgd2FzIGNhbmNlbGVkLiAqL1xuICAgIENBTkNFTEVEOiAnY2FuY2VsZWQnLFxuICAgIC8qKiBUaGUgdGFzayBmYWlsZWQgd2l0aCBhbiBlcnJvci4gKi9cbiAgICBFUlJPUjogJ2Vycm9yJ1xufTtcbmZ1bmN0aW9uIHRhc2tTdGF0ZUZyb21JbnRlcm5hbFRhc2tTdGF0ZShzdGF0ZSkge1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgY2FzZSBcInJ1bm5pbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HICovOlxuICAgICAgICBjYXNlIFwicGF1c2luZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcgKi86XG4gICAgICAgIGNhc2UgXCJjYW5jZWxpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcgKi86XG4gICAgICAgICAgICByZXR1cm4gVGFza1N0YXRlLlJVTk5JTkc7XG4gICAgICAgIGNhc2UgXCJwYXVzZWRcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQgKi86XG4gICAgICAgICAgICByZXR1cm4gVGFza1N0YXRlLlBBVVNFRDtcbiAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5TVUNDRVNTICovOlxuICAgICAgICAgICAgcmV0dXJuIFRhc2tTdGF0ZS5TVUNDRVNTO1xuICAgICAgICBjYXNlIFwiY2FuY2VsZWRcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxFRCAqLzpcbiAgICAgICAgICAgIHJldHVybiBUYXNrU3RhdGUuQ0FOQ0VMRUQ7XG4gICAgICAgIGNhc2UgXCJlcnJvclwiIC8qIEludGVybmFsVGFza1N0YXRlLkVSUk9SICovOlxuICAgICAgICAgICAgcmV0dXJuIFRhc2tTdGF0ZS5FUlJPUjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOiBhc3NlcnQoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIFRhc2tTdGF0ZS5FUlJPUjtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBjb25zdCBhc0Z1bmN0aW9ucyA9IGlzRnVuY3Rpb24obmV4dE9yT2JzZXJ2ZXIpIHx8IGVycm9yICE9IG51bGwgfHwgY29tcGxldGUgIT0gbnVsbDtcbiAgICAgICAgaWYgKGFzRnVuY3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvciA/PyB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gY29tcGxldGUgPz8gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG9ic2VydmVyLm5leHQ7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gb2JzZXJ2ZXIuZXJyb3I7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gb2JzZXJ2ZXIuY29tcGxldGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgZiB3aXRoIGl0cyBhcmd1bWVudHMgYXN5bmNocm9ub3VzbHkgYXMgYVxuICogbWljcm90YXNrLCBpLmUuIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgc2NyaXB0IHJldHVybnMgYmFja1xuICogaW50byBicm93c2VyIGNvZGUuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5mdW5jdGlvbiBhc3luYyhmKSB7XG4gICAgcmV0dXJuICguLi5hcmdzVG9Gb3J3YXJkKSA9PiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBmKC4uLmFyZ3NUb0ZvcndhcmQpKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIEFuIG92ZXJyaWRlIGZvciB0aGUgdGV4dC1iYXNlZCBDb25uZWN0aW9uLiBVc2VkIGluIHRlc3RzLiAqL1xubGV0IHRleHRGYWN0b3J5T3ZlcnJpZGUgPSBudWxsO1xuLyoqXG4gKiBOZXR3b3JrIGxheWVyIGZvciBicm93c2Vycy4gV2UgdXNlIHRoaXMgaW5zdGVhZCBvZiBnb29nLm5ldC5YaHJJbyBiZWNhdXNlXG4gKiBnb29nLm5ldC5YaHJJbyBpcyBoeXV1dXVnZSBhbmQgZG9lc24ndCB3b3JrIGluIFJlYWN0IE5hdGl2ZSBvbiBBbmRyb2lkLlxuICovXG5jbGFzcyBYaHJDb25uZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zZW50XyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnhocl8gPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgdGhpcy5pbml0WGhyKCk7XG4gICAgICAgIHRoaXMuZXJyb3JDb2RlXyA9IEVycm9yQ29kZS5OT19FUlJPUjtcbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZV8gPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHRoaXMueGhyXy5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yQ29kZV8gPSBFcnJvckNvZGUuQUJPUlQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnhocl8uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvckNvZGVfID0gRXJyb3JDb2RlLk5FVFdPUktfRVJST1I7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnhocl8uYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmQodXJsLCBtZXRob2QsIGlzVXNpbmdFbXVsYXRvciwgYm9keSwgaGVhZGVycykge1xuICAgICAgICBpZiAodGhpcy5zZW50Xykge1xuICAgICAgICAgICAgdGhyb3cgaW50ZXJuYWxFcnJvcignY2Fubm90IC5zZW5kKCkgbW9yZSB0aGFuIG9uY2UnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDbG91ZFdvcmtzdGF0aW9uKHVybCkgJiYgaXNVc2luZ0VtdWxhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnhocl8ud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbnRfID0gdHJ1ZTtcbiAgICAgICAgdGhpcy54aHJfLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgICAgICBpZiAoaGVhZGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnhocl8uc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy54aHJfLnNlbmQoYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnhocl8uc2VuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRQcm9taXNlXztcbiAgICB9XG4gICAgZ2V0RXJyb3JDb2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VudF8pIHtcbiAgICAgICAgICAgIHRocm93IGludGVybmFsRXJyb3IoJ2Nhbm5vdCAuZ2V0RXJyb3JDb2RlKCkgYmVmb3JlIHNlbmRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNvZGVfO1xuICAgIH1cbiAgICBnZXRTdGF0dXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZW50Xykge1xuICAgICAgICAgICAgdGhyb3cgaW50ZXJuYWxFcnJvcignY2Fubm90IC5nZXRTdGF0dXMoKSBiZWZvcmUgc2VuZGluZycpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54aHJfLnN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJlc3BvbnNlKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VudF8pIHtcbiAgICAgICAgICAgIHRocm93IGludGVybmFsRXJyb3IoJ2Nhbm5vdCAuZ2V0UmVzcG9uc2UoKSBiZWZvcmUgc2VuZGluZycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnhocl8ucmVzcG9uc2U7XG4gICAgfVxuICAgIGdldEVycm9yVGV4dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbnRfKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnRlcm5hbEVycm9yKCdjYW5ub3QgLmdldEVycm9yVGV4dCgpIGJlZm9yZSBzZW5kaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMueGhyXy5zdGF0dXNUZXh0O1xuICAgIH1cbiAgICAvKiogQWJvcnRzIHRoZSByZXF1ZXN0LiAqL1xuICAgIGFib3J0KCkge1xuICAgICAgICB0aGlzLnhocl8uYWJvcnQoKTtcbiAgICB9XG4gICAgZ2V0UmVzcG9uc2VIZWFkZXIoaGVhZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnhocl8uZ2V0UmVzcG9uc2VIZWFkZXIoaGVhZGVyKTtcbiAgICB9XG4gICAgYWRkVXBsb2FkUHJvZ3Jlc3NMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy54aHJfLnVwbG9hZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnhocl8udXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZVVwbG9hZFByb2dyZXNzTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMueGhyXy51cGxvYWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy54aHJfLnVwbG9hZC5yZW1vdmVFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFhoclRleHRDb25uZWN0aW9uIGV4dGVuZHMgWGhyQ29ubmVjdGlvbiB7XG4gICAgaW5pdFhocigpIHtcbiAgICAgICAgdGhpcy54aHJfLnJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcbiAgICB9XG59XG5mdW5jdGlvbiBuZXdUZXh0Q29ubmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGV4dEZhY3RvcnlPdmVycmlkZSA/IHRleHRGYWN0b3J5T3ZlcnJpZGUoKSA6IG5ldyBYaHJUZXh0Q29ubmVjdGlvbigpO1xufVxuY2xhc3MgWGhyQnl0ZXNDb25uZWN0aW9uIGV4dGVuZHMgWGhyQ29ubmVjdGlvbiB7XG4gICAgaW5pdFhocigpIHtcbiAgICAgICAgdGhpcy54aHJfLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3Qnl0ZXNDb25uZWN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgWGhyQnl0ZXNDb25uZWN0aW9uKCk7XG59XG5jbGFzcyBYaHJCbG9iQ29ubmVjdGlvbiBleHRlbmRzIFhockNvbm5lY3Rpb24ge1xuICAgIGluaXRYaHIoKSB7XG4gICAgICAgIHRoaXMueGhyXy5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3QmxvYkNvbm5lY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBYaHJCbG9iQ29ubmVjdGlvbigpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgYmxvYiBiZWluZyB1cGxvYWRlZC4gQ2FuIGJlIHVzZWQgdG8gcGF1c2UvcmVzdW1lL2NhbmNlbCB0aGVcbiAqIHVwbG9hZCBhbmQgbWFuYWdlIGNhbGxiYWNrcyBmb3IgdmFyaW91cyBldmVudHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgVXBsb2FkVGFzayB7XG4gICAgaXNFeHBvbmVudGlhbEJhY2tvZmZFeHBpcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbGVlcFRpbWUgPiB0aGlzLm1heFNsZWVwVGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHJlZiAtIFRoZSBmaXJlYmFzZVN0b3JhZ2UuUmVmZXJlbmNlIG9iamVjdCB0aGlzIHRhc2sgY2FtZVxuICAgICAqICAgICBmcm9tLCB1bnR5cGVkIHRvIGF2b2lkIGN5Y2xpYyBkZXBlbmRlbmNpZXMuXG4gICAgICogQHBhcmFtIGJsb2IgLSBUaGUgYmxvYiB0byB1cGxvYWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVmLCBibG9iLCBtZXRhZGF0YSA9IG51bGwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBvZiBieXRlcyB0cmFuc2ZlcnJlZCBzbyBmYXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90cmFuc2ZlcnJlZCA9IDA7XG4gICAgICAgIHRoaXMuX25lZWRUb0ZldGNoU3RhdHVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX25lZWRUb0ZldGNoTWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzID0gW107XG4gICAgICAgIHRoaXMuX2Vycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl91cGxvYWRVcmwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3JlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2NodW5rTXVsdGlwbGllciA9IDE7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcmVmID0gcmVmO1xuICAgICAgICB0aGlzLl9ibG9iID0gYmxvYjtcbiAgICAgICAgdGhpcy5fbWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5fbWFwcGluZ3MgPSBnZXRNYXBwaW5ncygpO1xuICAgICAgICB0aGlzLl9yZXN1bWFibGUgPSB0aGlzLl9zaG91bGREb1Jlc3VtYWJsZSh0aGlzLl9ibG9iKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBcInJ1bm5pbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HICovO1xuICAgICAgICB0aGlzLl9lcnJvckhhbmRsZXIgPSBlcnJvciA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fY2h1bmtNdWx0aXBsaWVyID0gMTtcbiAgICAgICAgICAgIGlmIChlcnJvci5fY29kZUVxdWFscyhTdG9yYWdlRXJyb3JDb2RlLkNBTkNFTEVEKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRUb0ZldGNoU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlVHJhbnNpdGlvbnNfKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYWNrb2ZmRXhwaXJlZCA9IHRoaXMuaXNFeHBvbmVudGlhbEJhY2tvZmZFeHBpcmVkKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmV0cnlTdGF0dXNDb2RlKGVycm9yLnN0YXR1cywgW10pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYWNrb2ZmRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSByZXRyeUxpbWl0RXhjZWVkZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2xlZXBUaW1lID0gTWF0aC5tYXgodGhpcy5zbGVlcFRpbWUgKiAyLCBERUZBVUxUX01JTl9TTEVFUF9USU1FX01JTExJUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZWVkVG9GZXRjaFN0YXR1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlVHJhbnNpdGlvbnNfKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwiZXJyb3JcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5FUlJPUiAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX21ldGFkYXRhRXJyb3JIYW5kbGVyID0gZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChlcnJvci5fY29kZUVxdWFscyhTdG9yYWdlRXJyb3JDb2RlLkNBTkNFTEVEKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVUcmFuc2l0aW9uc18oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcImVycm9yXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuRVJST1IgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNsZWVwVGltZSA9IDA7XG4gICAgICAgIHRoaXMubWF4U2xlZXBUaW1lID0gdGhpcy5fcmVmLnN0b3JhZ2UubWF4VXBsb2FkUmV0cnlUaW1lO1xuICAgICAgICB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICB0aGlzLl9zdGFydCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUHJldmVudCB1bmNhdWdodCByZWplY3Rpb25zIG9uIHRoZSBpbnRlcm5hbCBwcm9taXNlIGZyb20gYnViYmxpbmcgb3V0XG4gICAgICAgIC8vIHRvIHRoZSB0b3AgbGV2ZWwgd2l0aCBhIGR1bW15IGhhbmRsZXIuXG4gICAgICAgIHRoaXMuX3Byb21pc2UudGhlbihudWxsLCAoKSA9PiB7IH0pO1xuICAgIH1cbiAgICBfbWFrZVByb2dyZXNzQ2FsbGJhY2soKSB7XG4gICAgICAgIGNvbnN0IHNpemVCZWZvcmUgPSB0aGlzLl90cmFuc2ZlcnJlZDtcbiAgICAgICAgcmV0dXJuIGxvYWRlZCA9PiB0aGlzLl91cGRhdGVQcm9ncmVzcyhzaXplQmVmb3JlICsgbG9hZGVkKTtcbiAgICB9XG4gICAgX3Nob3VsZERvUmVzdW1hYmxlKGJsb2IpIHtcbiAgICAgICAgcmV0dXJuIGJsb2Iuc2l6ZSgpID4gMjU2ICogMTAyNDtcbiAgICB9XG4gICAgX3N0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IFwicnVubmluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgKi8pIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiBzb21lb25lIHBhdXNlcyB1cyBpbiBhIHJlc3VtZSBjYWxsYmFjaywgZm9yIGV4YW1wbGUuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZXN1bWFibGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl91cGxvYWRVcmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJlc3VtYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX25lZWRUb0ZldGNoU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZldGNoU3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmVlZFRvRmV0Y2hNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFwcGVucyBpZiB3ZSBtaXNzIHRoZSBtZXRhZGF0YSBvbiB1cGxvYWQgY29tcGxldGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZldGNoTWV0YWRhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRpbnVlVXBsb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnNsZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9vbmVTaG90VXBsb2FkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Jlc29sdmVUb2tlbihjYWxsYmFjaykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMuX3JlZi5zdG9yYWdlLl9nZXRBdXRoVG9rZW4oKSxcbiAgICAgICAgICAgIHRoaXMuX3JlZi5zdG9yYWdlLl9nZXRBcHBDaGVja1Rva2VuKClcbiAgICAgICAgXSkudGhlbigoW2F1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbl0pID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicnVubmluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgKi86XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjYW5jZWxpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcgKi86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJjYW5jZWxlZFwiIC8qIEludGVybmFsVGFza1N0YXRlLkNBTkNFTEVEICovKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInBhdXNpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwicGF1c2VkXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEICovKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUT0RPKGFuZHlzb3RvKTogYXNzZXJ0IGZhbHNlXG4gICAgX2NyZWF0ZVJlc3VtYWJsZSgpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVRva2VuKChhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gY3JlYXRlUmVzdW1hYmxlVXBsb2FkKHRoaXMuX3JlZi5zdG9yYWdlLCB0aGlzLl9yZWYuX2xvY2F0aW9uLCB0aGlzLl9tYXBwaW5ncywgdGhpcy5fYmxvYiwgdGhpcy5fbWV0YWRhdGEpO1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlUmVxdWVzdCA9IHRoaXMuX3JlZi5zdG9yYWdlLl9tYWtlUmVxdWVzdChyZXF1ZXN0SW5mbywgbmV3VGV4dENvbm5lY3Rpb24sIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbik7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdDtcbiAgICAgICAgICAgIGNyZWF0ZVJlcXVlc3QuZ2V0UHJvbWlzZSgpLnRoZW4oKHVybCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkVXJsID0gdXJsO1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRUb0ZldGNoU3RhdHVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZVRyYW5zaXRpb25zXygpO1xuICAgICAgICAgICAgfSwgdGhpcy5fZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9mZXRjaFN0YXR1cygpIHtcbiAgICAgICAgLy8gVE9ETyhhbmR5c290byk6IGFzc2VydCh0aGlzLnVwbG9hZFVybF8gIT09IG51bGwpO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLl91cGxvYWRVcmw7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVUb2tlbigoYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SW5mbyA9IGdldFJlc3VtYWJsZVVwbG9hZFN0YXR1cyh0aGlzLl9yZWYuc3RvcmFnZSwgdGhpcy5fcmVmLl9sb2NhdGlvbiwgdXJsLCB0aGlzLl9ibG9iKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c1JlcXVlc3QgPSB0aGlzLl9yZWYuc3RvcmFnZS5fbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHN0YXR1c1JlcXVlc3Q7XG4gICAgICAgICAgICBzdGF0dXNSZXF1ZXN0LmdldFByb21pc2UoKS50aGVuKHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJvZ3Jlc3Moc3RhdHVzLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRUb0ZldGNoU3RhdHVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5maW5hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmVlZFRvRmV0Y2hNZXRhZGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVUcmFuc2l0aW9uc18oKTtcbiAgICAgICAgICAgIH0sIHRoaXMuX2Vycm9ySGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfY29udGludWVVcGxvYWQoKSB7XG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IFJFU1VNQUJMRV9VUExPQURfQ0hVTktfU0laRSAqIHRoaXMuX2NodW5rTXVsdGlwbGllcjtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFJlc3VtYWJsZVVwbG9hZFN0YXR1cyh0aGlzLl90cmFuc2ZlcnJlZCwgdGhpcy5fYmxvYi5zaXplKCkpO1xuICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTogYXNzZXJ0KHRoaXMudXBsb2FkVXJsXyAhPT0gbnVsbCk7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuX3VwbG9hZFVybDtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVRva2VuKChhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pID0+IHtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0SW5mbztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEluZm8gPSBjb250aW51ZVJlc3VtYWJsZVVwbG9hZCh0aGlzLl9yZWYuX2xvY2F0aW9uLCB0aGlzLl9yZWYuc3RvcmFnZSwgdXJsLCB0aGlzLl9ibG9iLCBjaHVua1NpemUsIHRoaXMuX21hcHBpbmdzLCBzdGF0dXMsIHRoaXMuX21ha2VQcm9ncmVzc0NhbGxiYWNrKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcImVycm9yXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuRVJST1IgKi8pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVwbG9hZFJlcXVlc3QgPSB0aGlzLl9yZWYuc3RvcmFnZS5fbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIFxuICAgICAgICAgICAgLypyZXRyeT0qLyBmYWxzZSAvLyBVcGxvYWQgcmVxdWVzdHMgc2hvdWxkIG5vdCBiZSByZXRyaWVkIGFzIGVhY2ggcmV0cnkgc2hvdWxkIGJlIHByZWNlZGVkIGJ5IGFub3RoZXIgcXVlcnkgcmVxdWVzdC4gV2hpY2ggaXMgaGFuZGxlZCBpbiB0aGlzIGZpbGUuXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHVwbG9hZFJlcXVlc3Q7XG4gICAgICAgICAgICB1cGxvYWRSZXF1ZXN0LmdldFByb21pc2UoKS50aGVuKChuZXdTdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmNyZWFzZU11bHRpcGxpZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVByb2dyZXNzKG5ld1N0YXR1cy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdHVzLmZpbmFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXRhZGF0YSA9IG5ld1N0YXR1cy5tZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcInN1Y2Nlc3NcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5TVUNDRVNTICovKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVUcmFuc2l0aW9uc18oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzLl9lcnJvckhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2luY3JlYXNlTXVsdGlwbGllcigpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFNpemUgPSBSRVNVTUFCTEVfVVBMT0FEX0NIVU5LX1NJWkUgKiB0aGlzLl9jaHVua011bHRpcGxpZXI7XG4gICAgICAgIC8vIE1heCBjaHVuayBzaXplIGlzIDMyTS5cbiAgICAgICAgaWYgKGN1cnJlbnRTaXplICogMiA8IDMyICogMTAyNCAqIDEwMjQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NodW5rTXVsdGlwbGllciAqPSAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9mZXRjaE1ldGFkYXRhKCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlVG9rZW4oKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEluZm8gPSBnZXRNZXRhZGF0YSQyKHRoaXMuX3JlZi5zdG9yYWdlLCB0aGlzLl9yZWYuX2xvY2F0aW9uLCB0aGlzLl9tYXBwaW5ncyk7XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YVJlcXVlc3QgPSB0aGlzLl9yZWYuc3RvcmFnZS5fbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IG1ldGFkYXRhUmVxdWVzdDtcbiAgICAgICAgICAgIG1ldGFkYXRhUmVxdWVzdC5nZXRQcm9taXNlKCkudGhlbihtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJzdWNjZXNzXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuU1VDQ0VTUyAqLyk7XG4gICAgICAgICAgICB9LCB0aGlzLl9tZXRhZGF0YUVycm9ySGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfb25lU2hvdFVwbG9hZCgpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVRva2VuKChhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbXVsdGlwYXJ0VXBsb2FkKHRoaXMuX3JlZi5zdG9yYWdlLCB0aGlzLl9yZWYuX2xvY2F0aW9uLCB0aGlzLl9tYXBwaW5ncywgdGhpcy5fYmxvYiwgdGhpcy5fbWV0YWRhdGEpO1xuICAgICAgICAgICAgY29uc3QgbXVsdGlwYXJ0UmVxdWVzdCA9IHRoaXMuX3JlZi5zdG9yYWdlLl9tYWtlUmVxdWVzdChyZXF1ZXN0SW5mbywgbmV3VGV4dENvbm5lY3Rpb24sIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbik7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gbXVsdGlwYXJ0UmVxdWVzdDtcbiAgICAgICAgICAgIG11bHRpcGFydFJlcXVlc3QuZ2V0UHJvbWlzZSgpLnRoZW4obWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQcm9ncmVzcyh0aGlzLl9ibG9iLnNpemUoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcInN1Y2Nlc3NcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5TVUNDRVNTICovKTtcbiAgICAgICAgICAgIH0sIHRoaXMuX2Vycm9ySGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfdXBkYXRlUHJvZ3Jlc3ModHJhbnNmZXJyZWQpIHtcbiAgICAgICAgY29uc3Qgb2xkID0gdGhpcy5fdHJhbnNmZXJyZWQ7XG4gICAgICAgIHRoaXMuX3RyYW5zZmVycmVkID0gdHJhbnNmZXJyZWQ7XG4gICAgICAgIC8vIEEgcHJvZ3Jlc3MgdXBkYXRlIGNhbiBtYWtlIHRoZSBcInRyYW5zZmVycmVkXCIgdmFsdWUgc21hbGxlciAoZS5nLiBhXG4gICAgICAgIC8vIHBhcnRpYWwgdXBsb2FkIG5vdCBjb21wbGV0ZWQgYnkgc2VydmVyLCBhZnRlciB3aGljaCB0aGUgXCJ0cmFuc2ZlcnJlZFwiXG4gICAgICAgIC8vIHZhbHVlIG1heSByZXNldCB0byB0aGUgdmFsdWUgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVxdWVzdCkuXG4gICAgICAgIGlmICh0aGlzLl90cmFuc2ZlcnJlZCAhPT0gb2xkKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlPYnNlcnZlcnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfdHJhbnNpdGlvbihzdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBcImNhbmNlbGluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLkNBTkNFTElORyAqLzpcbiAgICAgICAgICAgIGNhc2UgXCJwYXVzaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyAqLzpcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTpcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQodGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgfHxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgdGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlbmRpbmdUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBlbmRpbmdUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZVRyYW5zaXRpb25zXygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJydW5uaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyAqLzpcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTpcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQodGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlBBVVNFRCB8fFxuICAgICAgICAgICAgICAgIC8vICAgICAgICB0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FzUGF1c2VkID0gdGhpcy5fc3RhdGUgPT09IFwicGF1c2VkXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEICovO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHdhc1BhdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub3RpZnlPYnNlcnZlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicGF1c2VkXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEICovOlxuICAgICAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOlxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCh0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3RpZnlPYnNlcnZlcnMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjYW5jZWxlZFwiIC8qIEludGVybmFsVGFza1N0YXRlLkNBTkNFTEVEICovOlxuICAgICAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOlxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCh0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gY2FuY2VsZWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMuX25vdGlmeU9ic2VydmVycygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuRVJST1IgKi86XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6XG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5T2JzZXJ2ZXJzKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiIC8qIEludGVybmFsVGFza1N0YXRlLlNVQ0NFU1MgKi86XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6XG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5T2JzZXJ2ZXJzKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcGxldGVUcmFuc2l0aW9uc18oKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJwYXVzaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwicGF1c2VkXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEICovKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjYW5jZWxpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcImNhbmNlbGVkXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMRUQgKi8pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJ1bm5pbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HICovOlxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzbmFwc2hvdCBvZiB0aGUgY3VycmVudCB0YXNrIHN0YXRlLlxuICAgICAqL1xuICAgIGdldCBzbmFwc2hvdCgpIHtcbiAgICAgICAgY29uc3QgZXh0ZXJuYWxTdGF0ZSA9IHRhc2tTdGF0ZUZyb21JbnRlcm5hbFRhc2tTdGF0ZSh0aGlzLl9zdGF0ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBieXRlc1RyYW5zZmVycmVkOiB0aGlzLl90cmFuc2ZlcnJlZCxcbiAgICAgICAgICAgIHRvdGFsQnl0ZXM6IHRoaXMuX2Jsb2Iuc2l6ZSgpLFxuICAgICAgICAgICAgc3RhdGU6IGV4dGVybmFsU3RhdGUsXG4gICAgICAgICAgICBtZXRhZGF0YTogdGhpcy5fbWV0YWRhdGEsXG4gICAgICAgICAgICB0YXNrOiB0aGlzLFxuICAgICAgICAgICAgcmVmOiB0aGlzLl9yZWZcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNhbGxiYWNrIGZvciBhbiBldmVudC5cbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIGV2ZW50IHRvIGxpc3RlbiBmb3IuXG4gICAgICogQHBhcmFtIG5leHRPck9ic2VydmVyIC1cbiAgICAgKiAgICAgVGhlIGBuZXh0YCBmdW5jdGlvbiwgd2hpY2ggZ2V0cyBjYWxsZWQgZm9yIGVhY2ggaXRlbSBpblxuICAgICAqICAgICB0aGUgZXZlbnQgc3RyZWFtLCBvciBhbiBvYnNlcnZlciBvYmplY3Qgd2l0aCBzb21lIG9yIGFsbCBvZiB0aGVzZSB0aHJlZVxuICAgICAqICAgICBwcm9wZXJ0aWVzIChgbmV4dGAsIGBlcnJvcmAsIGBjb21wbGV0ZWApLlxuICAgICAqIEBwYXJhbSBlcnJvciAtIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCB3aXRoIGEgYFN0b3JhZ2VFcnJvcmBcbiAgICAgKiAgICAgaWYgdGhlIGV2ZW50IHN0cmVhbSBlbmRzIGR1ZSB0byBhbiBlcnJvci5cbiAgICAgKiBAcGFyYW0gY29tcGxldGVkIC0gQSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGlmIHRoZVxuICAgICAqICAgICBldmVudCBzdHJlYW0gZW5kcyBub3JtYWxseS5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqICAgICBJZiBvbmx5IHRoZSBldmVudCBhcmd1bWVudCBpcyBwYXNzZWQsIHJldHVybnMgYSBmdW5jdGlvbiB5b3UgY2FuIHVzZSB0b1xuICAgICAqICAgICBhZGQgY2FsbGJhY2tzIChzZWUgdGhlIGV4YW1wbGVzIGFib3ZlKS4gSWYgbW9yZSB0aGFuIGp1c3QgdGhlIGV2ZW50XG4gICAgICogICAgIGFyZ3VtZW50IGlzIHBhc3NlZCwgcmV0dXJucyBhIGZ1bmN0aW9uIHlvdSBjYW4gY2FsbCB0byB1bnJlZ2lzdGVyIHRoZVxuICAgICAqICAgICBjYWxsYmFja3MuXG4gICAgICovXG4gICAgb24odHlwZSwgbmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpIHtcbiAgICAgICAgLy8gTm90ZTogYHR5cGVgIGlzbid0IGJlaW5nIHVzZWQuIEl0cyB0eXBlIGlzIGFsc28gaW5jb3JyZWN0LiBUYXNrRXZlbnQgc2hvdWxkIG5vdCBiZSBhIHN0cmluZy5cbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXIobmV4dE9yT2JzZXJ2ZXIgfHwgdW5kZWZpbmVkLCBlcnJvciB8fCB1bmRlZmluZWQsIGNvbXBsZXRlZCB8fCB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLl9hZGRPYnNlcnZlcihvYnNlcnZlcik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVPYnNlcnZlcihvYnNlcnZlcik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgb2JqZWN0IGJlaGF2ZXMgbGlrZSBhIFByb21pc2UsIGFuZCByZXNvbHZlcyB3aXRoIGl0cyBzbmFwc2hvdCBkYXRhXG4gICAgICogd2hlbiB0aGUgdXBsb2FkIGNvbXBsZXRlcy5cbiAgICAgKiBAcGFyYW0gb25GdWxmaWxsZWQgLSBUaGUgZnVsZmlsbG1lbnQgY2FsbGJhY2suIFByb21pc2UgY2hhaW5pbmcgd29ya3MgYXMgbm9ybWFsLlxuICAgICAqIEBwYXJhbSBvblJlamVjdGVkIC0gVGhlIHJlamVjdGlvbiBjYWxsYmFjay5cbiAgICAgKi9cbiAgICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIC8vIFRoZXNlIGNhc3RzIGFyZSBuZWVkZWQgc28gdGhhdCBUeXBlU2NyaXB0IGNhbiBpbmZlciB0aGUgdHlwZXMgb2YgdGhlXG4gICAgICAgIC8vIHJlc3VsdGluZyBQcm9taXNlLlxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBjYWxsaW5nIGB0aGVuKG51bGwsIG9uUmVqZWN0ZWQpYC5cbiAgICAgKi9cbiAgICBjYXRjaChvblJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIG9ic2VydmVyLlxuICAgICAqL1xuICAgIF9hZGRPYnNlcnZlcihvYnNlcnZlcikge1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICAgIHRoaXMuX25vdGlmeU9ic2VydmVyKG9ic2VydmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gb2JzZXJ2ZXIuXG4gICAgICovXG4gICAgX3JlbW92ZU9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLl9vYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7XG4gICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfbm90aWZ5T2JzZXJ2ZXJzKCkge1xuICAgICAgICB0aGlzLl9maW5pc2hQcm9taXNlKCk7XG4gICAgICAgIGNvbnN0IG9ic2VydmVycyA9IHRoaXMuX29ic2VydmVycy5zbGljZSgpO1xuICAgICAgICBvYnNlcnZlcnMuZm9yRWFjaChvYnNlcnZlciA9PiB7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlPYnNlcnZlcihvYnNlcnZlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZmluaXNoUHJvbWlzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhc2tTdGF0ZUZyb21JbnRlcm5hbFRhc2tTdGF0ZSh0aGlzLl9zdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRhc2tTdGF0ZS5TVUNDRVNTOlxuICAgICAgICAgICAgICAgICAgICBhc3luYyh0aGlzLl9yZXNvbHZlLmJpbmQobnVsbCwgdGhpcy5zbmFwc2hvdCkpKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVGFza1N0YXRlLkNBTkNFTEVEOlxuICAgICAgICAgICAgICAgIGNhc2UgVGFza1N0YXRlLkVSUk9SOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b0NhbGwgPSB0aGlzLl9yZWplY3Q7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jKHRvQ2FsbC5iaW5kKG51bGwsIHRoaXMuX2Vycm9yKSkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyaWdnZXJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9ub3RpZnlPYnNlcnZlcihvYnNlcnZlcikge1xuICAgICAgICBjb25zdCBleHRlcm5hbFN0YXRlID0gdGFza1N0YXRlRnJvbUludGVybmFsVGFza1N0YXRlKHRoaXMuX3N0YXRlKTtcbiAgICAgICAgc3dpdGNoIChleHRlcm5hbFN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFRhc2tTdGF0ZS5SVU5OSU5HOlxuICAgICAgICAgICAgY2FzZSBUYXNrU3RhdGUuUEFVU0VEOlxuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jKG9ic2VydmVyLm5leHQuYmluZChvYnNlcnZlciwgdGhpcy5zbmFwc2hvdCkpKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUYXNrU3RhdGUuU1VDQ0VTUzpcbiAgICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMob2JzZXJ2ZXIuY29tcGxldGUuYmluZChvYnNlcnZlcikpKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUYXNrU3RhdGUuQ0FOQ0VMRUQ6XG4gICAgICAgICAgICBjYXNlIFRhc2tTdGF0ZS5FUlJPUjpcbiAgICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMob2JzZXJ2ZXIuZXJyb3IuYmluZChvYnNlcnZlciwgdGhpcy5fZXJyb3IpKSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6IGFzc2VydChmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKG9ic2VydmVyLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jKG9ic2VydmVyLmVycm9yLmJpbmQob2JzZXJ2ZXIsIHRoaXMuX2Vycm9yKSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdW1lcyBhIHBhdXNlZCB0YXNrLiBIYXMgbm8gZWZmZWN0IG9uIGEgY3VycmVudGx5IHJ1bm5pbmcgb3IgZmFpbGVkIHRhc2suXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgb3BlcmF0aW9uIHRvb2sgZWZmZWN0LCBmYWxzZSBpZiBpZ25vcmVkLlxuICAgICAqL1xuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLl9zdGF0ZSA9PT0gXCJwYXVzZWRcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQgKi8gfHxcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID09PSBcInBhdXNpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HICovO1xuICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJydW5uaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgYSBjdXJyZW50bHkgcnVubmluZyB0YXNrLiBIYXMgbm8gZWZmZWN0IG9uIGEgcGF1c2VkIG9yIGZhaWxlZCB0YXNrLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG9wZXJhdGlvbiB0b29rIGVmZmVjdCwgZmFsc2UgaWYgaWdub3JlZC5cbiAgICAgKi9cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLl9zdGF0ZSA9PT0gXCJydW5uaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyAqLztcbiAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwicGF1c2luZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhIGN1cnJlbnRseSBydW5uaW5nIG9yIHBhdXNlZCB0YXNrLiBIYXMgbm8gZWZmZWN0IG9uIGEgY29tcGxldGUgb3JcbiAgICAgKiBmYWlsZWQgdGFzay5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBvcGVyYXRpb24gdG9vayBlZmZlY3QsIGZhbHNlIGlmIGlnbm9yZWQuXG4gICAgICovXG4gICAgY2FuY2VsKCkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IHRoaXMuX3N0YXRlID09PSBcInJ1bm5pbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HICovIHx8XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9PT0gXCJwYXVzaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyAqLztcbiAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwiY2FuY2VsaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMSU5HICovKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlcyBtZXRob2RzIHRvIGludGVyYWN0IHdpdGggYSBidWNrZXQgaW4gdGhlIEZpcmViYXNlIFN0b3JhZ2Ugc2VydmljZS5cbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIF9sb2NhdGlvbiAtIEFuIGZicy5sb2NhdGlvbiwgb3IgdGhlIFVSTCBhdFxuICogICAgIHdoaWNoIHRvIGJhc2UgdGhpcyBvYmplY3QsIGluIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZvcm1zOlxuICogICAgICAgICBnczovLzxidWNrZXQ+LzxvYmplY3QtcGF0aD5cbiAqICAgICAgICAgaHR0cFtzXTovL2ZpcmViYXNlc3RvcmFnZS5nb29nbGVhcGlzLmNvbS9cbiAqICAgICAgICAgICAgICAgICAgICAgPGFwaS12ZXJzaW9uPi9iLzxidWNrZXQ+L28vPG9iamVjdC1wYXRoPlxuICogICAgIEFueSBxdWVyeSBvciBmcmFnbWVudCBzdHJpbmdzIHdpbGwgYmUgaWdub3JlZCBpbiB0aGUgaHR0cFtzXVxuICogICAgIGZvcm1hdC4gSWYgbm8gdmFsdWUgaXMgcGFzc2VkLCB0aGUgc3RvcmFnZSBvYmplY3Qgd2lsbCB1c2UgYSBVUkwgYmFzZWQgb25cbiAqICAgICB0aGUgcHJvamVjdCBJRCBvZiB0aGUgYmFzZSBmaXJlYmFzZS5BcHAgaW5zdGFuY2UuXG4gKi9cbmNsYXNzIFJlZmVyZW5jZSB7XG4gICAgY29uc3RydWN0b3IoX3NlcnZpY2UsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuX3NlcnZpY2UgPSBfc2VydmljZTtcbiAgICAgICAgaWYgKGxvY2F0aW9uIGluc3RhbmNlb2YgTG9jYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhdGlvbiA9IExvY2F0aW9uLm1ha2VGcm9tVXJsKGxvY2F0aW9uLCBfc2VydmljZS5ob3N0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBVUkwgZm9yIHRoZSBidWNrZXQgYW5kIHBhdGggdGhpcyBvYmplY3QgcmVmZXJlbmNlcyxcbiAgICAgKiAgICAgaW4gdGhlIGZvcm0gZ3M6Ly88YnVja2V0Pi88b2JqZWN0LXBhdGg+XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnZ3M6Ly8nICsgdGhpcy5fbG9jYXRpb24uYnVja2V0ICsgJy8nICsgdGhpcy5fbG9jYXRpb24ucGF0aDtcbiAgICB9XG4gICAgX25ld1JlZihzZXJ2aWNlLCBsb2NhdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFJlZmVyZW5jZShzZXJ2aWNlLCBsb2NhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSByb290IG9mIHRoaXMgb2JqZWN0J3MgYnVja2V0LlxuICAgICAqL1xuICAgIGdldCByb290KCkge1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IG5ldyBMb2NhdGlvbih0aGlzLl9sb2NhdGlvbi5idWNrZXQsICcnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld1JlZih0aGlzLl9zZXJ2aWNlLCBsb2NhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBidWNrZXQgY29udGFpbmluZyB0aGlzIHJlZmVyZW5jZSdzIG9iamVjdC5cbiAgICAgKi9cbiAgICBnZXQgYnVja2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYXRpb24uYnVja2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZnVsbCBwYXRoIG9mIHRoaXMgb2JqZWN0LlxuICAgICAqL1xuICAgIGdldCBmdWxsUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uLnBhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzaG9ydCBuYW1lIG9mIHRoaXMgb2JqZWN0LCB3aGljaCBpcyB0aGUgbGFzdCBjb21wb25lbnQgb2YgdGhlIGZ1bGwgcGF0aC5cbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgZnVsbFBhdGggaXMgJ2Z1bGwvcGF0aC9pbWFnZS5wbmcnLCBuYW1lIGlzICdpbWFnZS5wbmcnLlxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gbGFzdENvbXBvbmVudCh0aGlzLl9sb2NhdGlvbi5wYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGBTdG9yYWdlU2VydmljZWAgaW5zdGFuY2UgdGhpcyBgU3RvcmFnZVJlZmVyZW5jZWAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgICAqL1xuICAgIGdldCBzdG9yYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VydmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBgU3RvcmFnZVJlZmVyZW5jZWAgcG9pbnRpbmcgdG8gdGhlIHBhcmVudCBsb2NhdGlvbiBvZiB0aGlzIGBTdG9yYWdlUmVmZXJlbmNlYCwgb3IgbnVsbCBpZlxuICAgICAqIHRoaXMgcmVmZXJlbmNlIGlzIHRoZSByb290LlxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIGNvbnN0IG5ld1BhdGggPSBwYXJlbnQodGhpcy5fbG9jYXRpb24ucGF0aCk7XG4gICAgICAgIGlmIChuZXdQYXRoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IG5ldyBMb2NhdGlvbih0aGlzLl9sb2NhdGlvbi5idWNrZXQsIG5ld1BhdGgpO1xuICAgICAgICByZXR1cm4gbmV3IFJlZmVyZW5jZSh0aGlzLl9zZXJ2aWNlLCBsb2NhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gdGhyb3cgYW4gZXJyb3IgaW4gbWV0aG9kcyB0aGF0IGRvIG5vdCBhY2NlcHQgYSByb290IHJlZmVyZW5jZS5cbiAgICAgKi9cbiAgICBfdGhyb3dJZlJvb3QobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5fbG9jYXRpb24ucGF0aCA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IGludmFsaWRSb290T3BlcmF0aW9uKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBEb3dubG9hZCB0aGUgYnl0ZXMgYXQgdGhlIG9iamVjdCdzIGxvY2F0aW9uLlxuICogQHJldHVybnMgQSBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIGRvd25sb2FkZWQgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldEJ5dGVzSW50ZXJuYWwocmVmLCBtYXhEb3dubG9hZFNpemVCeXRlcykge1xuICAgIHJlZi5fdGhyb3dJZlJvb3QoJ2dldEJ5dGVzJyk7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBnZXRCeXRlcyQxKHJlZi5zdG9yYWdlLCByZWYuX2xvY2F0aW9uLCBtYXhEb3dubG9hZFNpemVCeXRlcyk7XG4gICAgcmV0dXJuIHJlZi5zdG9yYWdlXG4gICAgICAgIC5tYWtlUmVxdWVzdFdpdGhUb2tlbnMocmVxdWVzdEluZm8sIG5ld0J5dGVzQ29ubmVjdGlvbilcbiAgICAgICAgLnRoZW4oYnl0ZXMgPT4gbWF4RG93bmxvYWRTaXplQnl0ZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IC8vIEdDUyBtYXkgbm90IGhvbm9yIHRoZSBSYW5nZSBoZWFkZXIgZm9yIHNtYWxsIGZpbGVzXG4gICAgICAgICAgICBieXRlcy5zbGljZSgwLCBtYXhEb3dubG9hZFNpemVCeXRlcylcbiAgICAgICAgOiBieXRlcyk7XG59XG4vKipcbiAqIERvd25sb2FkIHRoZSBieXRlcyBhdCB0aGUgb2JqZWN0J3MgbG9jYXRpb24uXG4gKiBAcmV0dXJucyBBIFByb21pc2UgY29udGFpbmluZyB0aGUgZG93bmxvYWRlZCBibG9iLlxuICovXG5mdW5jdGlvbiBnZXRCbG9iSW50ZXJuYWwocmVmLCBtYXhEb3dubG9hZFNpemVCeXRlcykge1xuICAgIHJlZi5fdGhyb3dJZlJvb3QoJ2dldEJsb2InKTtcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IGdldEJ5dGVzJDEocmVmLnN0b3JhZ2UsIHJlZi5fbG9jYXRpb24sIG1heERvd25sb2FkU2l6ZUJ5dGVzKTtcbiAgICByZXR1cm4gcmVmLnN0b3JhZ2VcbiAgICAgICAgLm1ha2VSZXF1ZXN0V2l0aFRva2VucyhyZXF1ZXN0SW5mbywgbmV3QmxvYkNvbm5lY3Rpb24pXG4gICAgICAgIC50aGVuKGJsb2IgPT4gbWF4RG93bmxvYWRTaXplQnl0ZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IC8vIEdDUyBtYXkgbm90IGhvbm9yIHRoZSBSYW5nZSBoZWFkZXIgZm9yIHNtYWxsIGZpbGVzXG4gICAgICAgICAgICBibG9iLnNsaWNlKDAsIG1heERvd25sb2FkU2l6ZUJ5dGVzKVxuICAgICAgICA6IGJsb2IpO1xufVxuLyoqXG4gKiBVcGxvYWRzIGRhdGEgdG8gdGhpcyBvYmplY3QncyBsb2NhdGlvbi5cbiAqIFRoZSB1cGxvYWQgaXMgbm90IHJlc3VtYWJsZS5cbiAqXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB3aGVyZSBkYXRhIHNob3VsZCBiZSB1cGxvYWRlZC5cbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXBsb2FkLlxuICogQHBhcmFtIG1ldGFkYXRhIC0gTWV0YWRhdGEgZm9yIHRoZSBuZXdseSB1cGxvYWRlZCBkYXRhLlxuICogQHJldHVybnMgQSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gVXBsb2FkUmVzdWx0XG4gKi9cbmZ1bmN0aW9uIHVwbG9hZEJ5dGVzJDEocmVmLCBkYXRhLCBtZXRhZGF0YSkge1xuICAgIHJlZi5fdGhyb3dJZlJvb3QoJ3VwbG9hZEJ5dGVzJyk7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBtdWx0aXBhcnRVcGxvYWQocmVmLnN0b3JhZ2UsIHJlZi5fbG9jYXRpb24sIGdldE1hcHBpbmdzKCksIG5ldyBGYnNCbG9iKGRhdGEsIHRydWUpLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIHJlZi5zdG9yYWdlXG4gICAgICAgIC5tYWtlUmVxdWVzdFdpdGhUb2tlbnMocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uKVxuICAgICAgICAudGhlbihmaW5hbE1ldGFkYXRhID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiBmaW5hbE1ldGFkYXRhLFxuICAgICAgICAgICAgcmVmXG4gICAgICAgIH07XG4gICAgfSk7XG59XG4vKipcbiAqIFVwbG9hZHMgZGF0YSB0byB0aGlzIG9iamVjdCdzIGxvY2F0aW9uLlxuICogVGhlIHVwbG9hZCBjYW4gYmUgcGF1c2VkIGFuZCByZXN1bWVkLCBhbmQgZXhwb3NlcyBwcm9ncmVzcyB1cGRhdGVzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2Ugd2hlcmUgZGF0YSBzaG91bGQgYmUgdXBsb2FkZWQuXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVwbG9hZC5cbiAqIEBwYXJhbSBtZXRhZGF0YSAtIE1ldGFkYXRhIGZvciB0aGUgbmV3bHkgdXBsb2FkZWQgZGF0YS5cbiAqIEByZXR1cm5zIEFuIFVwbG9hZFRhc2tcbiAqL1xuZnVuY3Rpb24gdXBsb2FkQnl0ZXNSZXN1bWFibGUkMShyZWYsIGRhdGEsIG1ldGFkYXRhKSB7XG4gICAgcmVmLl90aHJvd0lmUm9vdCgndXBsb2FkQnl0ZXNSZXN1bWFibGUnKTtcbiAgICByZXR1cm4gbmV3IFVwbG9hZFRhc2socmVmLCBuZXcgRmJzQmxvYihkYXRhKSwgbWV0YWRhdGEpO1xufVxuLyoqXG4gKiBVcGxvYWRzIGEgc3RyaW5nIHRvIHRoaXMgb2JqZWN0J3MgbG9jYXRpb24uXG4gKiBUaGUgdXBsb2FkIGlzIG5vdCByZXN1bWFibGUuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB3aGVyZSBzdHJpbmcgc2hvdWxkIGJlIHVwbG9hZGVkLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byB1cGxvYWQuXG4gKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBvZiB0aGUgc3RyaW5nIHRvIHVwbG9hZC5cbiAqIEBwYXJhbSBtZXRhZGF0YSAtIE1ldGFkYXRhIGZvciB0aGUgbmV3bHkgdXBsb2FkZWQgc3RyaW5nLlxuICogQHJldHVybnMgQSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gVXBsb2FkUmVzdWx0XG4gKi9cbmZ1bmN0aW9uIHVwbG9hZFN0cmluZyQxKHJlZiwgdmFsdWUsIGZvcm1hdCA9IFN0cmluZ0Zvcm1hdC5SQVcsIG1ldGFkYXRhKSB7XG4gICAgcmVmLl90aHJvd0lmUm9vdCgndXBsb2FkU3RyaW5nJyk7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFGcm9tU3RyaW5nKGZvcm1hdCwgdmFsdWUpO1xuICAgIGNvbnN0IG1ldGFkYXRhQ2xvbmUgPSB7IC4uLm1ldGFkYXRhIH07XG4gICAgaWYgKG1ldGFkYXRhQ2xvbmVbJ2NvbnRlbnRUeXBlJ10gPT0gbnVsbCAmJiBkYXRhLmNvbnRlbnRUeXBlICE9IG51bGwpIHtcbiAgICAgICAgbWV0YWRhdGFDbG9uZVsnY29udGVudFR5cGUnXSA9IGRhdGEuY29udGVudFR5cGU7XG4gICAgfVxuICAgIHJldHVybiB1cGxvYWRCeXRlcyQxKHJlZiwgZGF0YS5kYXRhLCBtZXRhZGF0YUNsb25lKTtcbn1cbi8qKlxuICogTGlzdCBhbGwgaXRlbXMgKGZpbGVzKSBhbmQgcHJlZml4ZXMgKGZvbGRlcnMpIHVuZGVyIHRoaXMgc3RvcmFnZSByZWZlcmVuY2UuXG4gKlxuICogVGhpcyBpcyBhIGhlbHBlciBtZXRob2QgZm9yIGNhbGxpbmcgbGlzdCgpIHJlcGVhdGVkbHkgdW50aWwgdGhlcmUgYXJlXG4gKiBubyBtb3JlIHJlc3VsdHMuIFRoZSBkZWZhdWx0IHBhZ2luYXRpb24gc2l6ZSBpcyAxMDAwLlxuICpcbiAqIE5vdGU6IFRoZSByZXN1bHRzIG1heSBub3QgYmUgY29uc2lzdGVudCBpZiBvYmplY3RzIGFyZSBjaGFuZ2VkIHdoaWxlIHRoaXNcbiAqIG9wZXJhdGlvbiBpcyBydW5uaW5nLlxuICpcbiAqIFdhcm5pbmc6IGxpc3RBbGwgbWF5IHBvdGVudGlhbGx5IGNvbnN1bWUgdG9vIG1hbnkgcmVzb3VyY2VzIGlmIHRoZXJlIGFyZVxuICogdG9vIG1hbnkgcmVzdWx0cy5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHRvIGdldCBsaXN0IGZyb20uXG4gKlxuICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbGwgdGhlIGl0ZW1zIGFuZCBwcmVmaXhlcyB1bmRlclxuICogICAgICB0aGUgY3VycmVudCBzdG9yYWdlIHJlZmVyZW5jZS4gYHByZWZpeGVzYCBjb250YWlucyByZWZlcmVuY2VzIHRvXG4gKiAgICAgIHN1Yi1kaXJlY3RvcmllcyBhbmQgYGl0ZW1zYCBjb250YWlucyByZWZlcmVuY2VzIHRvIG9iamVjdHMgaW4gdGhpc1xuICogICAgICBmb2xkZXIuIGBuZXh0UGFnZVRva2VuYCBpcyBuZXZlciByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gbGlzdEFsbCQxKHJlZikge1xuICAgIGNvbnN0IGFjY3VtdWxhdG9yID0ge1xuICAgICAgICBwcmVmaXhlczogW10sXG4gICAgICAgIGl0ZW1zOiBbXVxuICAgIH07XG4gICAgcmV0dXJuIGxpc3RBbGxIZWxwZXIocmVmLCBhY2N1bXVsYXRvcikudGhlbigoKSA9PiBhY2N1bXVsYXRvcik7XG59XG4vKipcbiAqIFNlcGFyYXRlZCBmcm9tIGxpc3RBbGwgYmVjYXVzZSBhc3luYyBmdW5jdGlvbnMgY2FuJ3QgdXNlIFwiYXJndW1lbnRzXCIuXG4gKiBAcGFyYW0gcmVmXG4gKiBAcGFyYW0gYWNjdW11bGF0b3JcbiAqIEBwYXJhbSBwYWdlVG9rZW5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbGlzdEFsbEhlbHBlcihyZWYsIGFjY3VtdWxhdG9yLCBwYWdlVG9rZW4pIHtcbiAgICBjb25zdCBvcHQgPSB7XG4gICAgICAgIC8vIG1heFJlc3VsdHMgaXMgMTAwMCBieSBkZWZhdWx0LlxuICAgICAgICBwYWdlVG9rZW5cbiAgICB9O1xuICAgIGNvbnN0IG5leHRQYWdlID0gYXdhaXQgbGlzdCQxKHJlZiwgb3B0KTtcbiAgICBhY2N1bXVsYXRvci5wcmVmaXhlcy5wdXNoKC4uLm5leHRQYWdlLnByZWZpeGVzKTtcbiAgICBhY2N1bXVsYXRvci5pdGVtcy5wdXNoKC4uLm5leHRQYWdlLml0ZW1zKTtcbiAgICBpZiAobmV4dFBhZ2UubmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIGF3YWl0IGxpc3RBbGxIZWxwZXIocmVmLCBhY2N1bXVsYXRvciwgbmV4dFBhZ2UubmV4dFBhZ2VUb2tlbik7XG4gICAgfVxufVxuLyoqXG4gKiBMaXN0IGl0ZW1zIChmaWxlcykgYW5kIHByZWZpeGVzIChmb2xkZXJzKSB1bmRlciB0aGlzIHN0b3JhZ2UgcmVmZXJlbmNlLlxuICpcbiAqIExpc3QgQVBJIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBGaXJlYmFzZSBSdWxlcyBWZXJzaW9uIDIuXG4gKlxuICogR0NTIGlzIGEga2V5LWJsb2Igc3RvcmUuIEZpcmViYXNlIFN0b3JhZ2UgaW1wb3NlcyB0aGUgc2VtYW50aWMgb2YgJy8nXG4gKiBkZWxpbWl0ZWQgZm9sZGVyIHN0cnVjdHVyZS5cbiAqIFJlZmVyIHRvIEdDUydzIExpc3QgQVBJIGlmIHlvdSB3YW50IHRvIGxlYXJuIG1vcmUuXG4gKlxuICogVG8gYWRoZXJlIHRvIEZpcmViYXNlIFJ1bGVzJ3MgU2VtYW50aWNzLCBGaXJlYmFzZSBTdG9yYWdlIGRvZXMgbm90XG4gKiBzdXBwb3J0IG9iamVjdHMgd2hvc2UgcGF0aHMgZW5kIHdpdGggXCIvXCIgb3IgY29udGFpbiB0d28gY29uc2VjdXRpdmVcbiAqIFwiL1wicy4gRmlyZWJhc2UgU3RvcmFnZSBMaXN0IEFQSSB3aWxsIGZpbHRlciB0aGVzZSB1bnN1cHBvcnRlZCBvYmplY3RzLlxuICogbGlzdCgpIG1heSBmYWlsIGlmIHRoZXJlIGFyZSB0b28gbWFueSB1bnN1cHBvcnRlZCBvYmplY3RzIGluIHRoZSBidWNrZXQuXG4gKiBAcHVibGljXG4gKlxuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2UgdG8gZ2V0IGxpc3QgZnJvbS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gU2VlIExpc3RPcHRpb25zIGZvciBkZXRhaWxzLlxuICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgaXRlbXMgYW5kIHByZWZpeGVzLlxuICogICAgICBgcHJlZml4ZXNgIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG8gc3ViLWZvbGRlcnMgYW5kIGBpdGVtc2BcbiAqICAgICAgY29udGFpbnMgcmVmZXJlbmNlcyB0byBvYmplY3RzIGluIHRoaXMgZm9sZGVyLiBgbmV4dFBhZ2VUb2tlbmBcbiAqICAgICAgY2FuIGJlIHVzZWQgdG8gZ2V0IHRoZSByZXN0IG9mIHRoZSByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBsaXN0JDEocmVmLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubWF4UmVzdWx0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlTnVtYmVyKCdvcHRpb25zLm1heFJlc3VsdHMnLCBcbiAgICAgICAgICAgIC8qIG1pblZhbHVlPSAqLyAxLCBcbiAgICAgICAgICAgIC8qIG1heFZhbHVlPSAqLyAxMDAwLCBvcHRpb25zLm1heFJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG9wID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IGxpc3QkMihyZWYuc3RvcmFnZSwgcmVmLl9sb2NhdGlvbiwgXG4gICAgLypkZWxpbWl0ZXI9ICovICcvJywgb3AucGFnZVRva2VuLCBvcC5tYXhSZXN1bHRzKTtcbiAgICByZXR1cm4gcmVmLnN0b3JhZ2UubWFrZVJlcXVlc3RXaXRoVG9rZW5zKHJlcXVlc3RJbmZvLCBuZXdUZXh0Q29ubmVjdGlvbik7XG59XG4vKipcbiAqIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbWV0YWRhdGEgZm9yIHRoaXMgb2JqZWN0LiBJZiB0aGlzXG4gKiBvYmplY3QgZG9lc24ndCBleGlzdCBvciBtZXRhZGF0YSBjYW5ub3QgYmUgcmV0cmlldmVkLCB0aGUgcHJvbWlzZSBpc1xuICogcmVqZWN0ZWQuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB0byBnZXQgbWV0YWRhdGEgZnJvbS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWV0YWRhdGEkMShyZWYpIHtcbiAgICByZWYuX3Rocm93SWZSb290KCdnZXRNZXRhZGF0YScpO1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gZ2V0TWV0YWRhdGEkMihyZWYuc3RvcmFnZSwgcmVmLl9sb2NhdGlvbiwgZ2V0TWFwcGluZ3MoKSk7XG4gICAgcmV0dXJuIHJlZi5zdG9yYWdlLm1ha2VSZXF1ZXN0V2l0aFRva2VucyhyZXF1ZXN0SW5mbywgbmV3VGV4dENvbm5lY3Rpb24pO1xufVxuLyoqXG4gKiBVcGRhdGVzIHRoZSBtZXRhZGF0YSBmb3IgdGhpcyBvYmplY3QuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB0byB1cGRhdGUgbWV0YWRhdGEgZm9yLlxuICogQHBhcmFtIG1ldGFkYXRhIC0gVGhlIG5ldyBtZXRhZGF0YSBmb3IgdGhlIG9iamVjdC5cbiAqICAgICBPbmx5IHZhbHVlcyB0aGF0IGhhdmUgYmVlbiBleHBsaWNpdGx5IHNldCB3aWxsIGJlIGNoYW5nZWQuIEV4cGxpY2l0bHlcbiAqICAgICBzZXR0aW5nIGEgdmFsdWUgdG8gbnVsbCB3aWxsIHJlbW92ZSB0aGUgbWV0YWRhdGEuXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzXG4gKiAgICAgd2l0aCB0aGUgbmV3IG1ldGFkYXRhIGZvciB0aGlzIG9iamVjdC5cbiAqICAgICBTZWUgYGZpcmViYXNlU3RvcmFnZS5SZWZlcmVuY2UucHJvdG90eXBlLmdldE1ldGFkYXRhYFxuICovXG5mdW5jdGlvbiB1cGRhdGVNZXRhZGF0YSQxKHJlZiwgbWV0YWRhdGEpIHtcbiAgICByZWYuX3Rocm93SWZSb290KCd1cGRhdGVNZXRhZGF0YScpO1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gdXBkYXRlTWV0YWRhdGEkMihyZWYuc3RvcmFnZSwgcmVmLl9sb2NhdGlvbiwgbWV0YWRhdGEsIGdldE1hcHBpbmdzKCkpO1xuICAgIHJldHVybiByZWYuc3RvcmFnZS5tYWtlUmVxdWVzdFdpdGhUb2tlbnMocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZG93bmxvYWQgVVJMIGZvciB0aGUgZ2l2ZW4gUmVmZXJlbmNlLlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBkb3dubG9hZFxuICogICAgIFVSTCBmb3IgdGhpcyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGdldERvd25sb2FkVVJMJDEocmVmKSB7XG4gICAgcmVmLl90aHJvd0lmUm9vdCgnZ2V0RG93bmxvYWRVUkwnKTtcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IGdldERvd25sb2FkVXJsKHJlZi5zdG9yYWdlLCByZWYuX2xvY2F0aW9uLCBnZXRNYXBwaW5ncygpKTtcbiAgICByZXR1cm4gcmVmLnN0b3JhZ2VcbiAgICAgICAgLm1ha2VSZXF1ZXN0V2l0aFRva2VucyhyZXF1ZXN0SW5mbywgbmV3VGV4dENvbm5lY3Rpb24pXG4gICAgICAgIC50aGVuKHVybCA9PiB7XG4gICAgICAgIGlmICh1cmwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5vRG93bmxvYWRVUkwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH0pO1xufVxuLyoqXG4gKiBEZWxldGVzIHRoZSBvYmplY3QgYXQgdGhpcyBsb2NhdGlvbi5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIGZvciBvYmplY3QgdG8gZGVsZXRlLlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyBpZiB0aGUgZGVsZXRpb24gc3VjY2VlZHMuXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZU9iamVjdCQxKHJlZikge1xuICAgIHJlZi5fdGhyb3dJZlJvb3QoJ2RlbGV0ZU9iamVjdCcpO1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gZGVsZXRlT2JqZWN0JDIocmVmLnN0b3JhZ2UsIHJlZi5fbG9jYXRpb24pO1xuICAgIHJldHVybiByZWYuc3RvcmFnZS5tYWtlUmVxdWVzdFdpdGhUb2tlbnMocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uKTtcbn1cbi8qKlxuICogUmV0dXJucyByZWZlcmVuY2UgZm9yIG9iamVjdCBvYnRhaW5lZCBieSBhcHBlbmRpbmcgYGNoaWxkUGF0aGAgdG8gYHJlZmAuXG4gKlxuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2UgdG8gZ2V0IGNoaWxkIG9mLlxuICogQHBhcmFtIGNoaWxkUGF0aCAtIENoaWxkIHBhdGggZnJvbSBwcm92aWRlZCByZWYuXG4gKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGUgb2JqZWN0IG9idGFpbmVkIGJ5XG4gKiBhcHBlbmRpbmcgY2hpbGRQYXRoLCByZW1vdmluZyBhbnkgZHVwbGljYXRlLCBiZWdpbm5pbmcsIG9yIHRyYWlsaW5nXG4gKiBzbGFzaGVzLlxuICpcbiAqL1xuZnVuY3Rpb24gX2dldENoaWxkJDEocmVmLCBjaGlsZFBhdGgpIHtcbiAgICBjb25zdCBuZXdQYXRoID0gY2hpbGQocmVmLl9sb2NhdGlvbi5wYXRoLCBjaGlsZFBhdGgpO1xuICAgIGNvbnN0IGxvY2F0aW9uID0gbmV3IExvY2F0aW9uKHJlZi5fbG9jYXRpb24uYnVja2V0LCBuZXdQYXRoKTtcbiAgICByZXR1cm4gbmV3IFJlZmVyZW5jZShyZWYuc3RvcmFnZSwgbG9jYXRpb24pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gaXNVcmwocGF0aCkge1xuICAgIHJldHVybiAvXltBLVphLXpdKzpcXC9cXC8vLnRlc3QocGF0aCk7XG59XG4vKipcbiAqIFJldHVybnMgYSBmaXJlYmFzZVN0b3JhZ2UuUmVmZXJlbmNlIGZvciB0aGUgZ2l2ZW4gdXJsLlxuICovXG5mdW5jdGlvbiByZWZGcm9tVVJMKHNlcnZpY2UsIHVybCkge1xuICAgIHJldHVybiBuZXcgUmVmZXJlbmNlKHNlcnZpY2UsIHVybCk7XG59XG4vKipcbiAqIFJldHVybnMgYSBmaXJlYmFzZVN0b3JhZ2UuUmVmZXJlbmNlIGZvciB0aGUgZ2l2ZW4gcGF0aCBpbiB0aGUgZGVmYXVsdFxuICogYnVja2V0LlxuICovXG5mdW5jdGlvbiByZWZGcm9tUGF0aChyZWYsIHBhdGgpIHtcbiAgICBpZiAocmVmIGluc3RhbmNlb2YgRmlyZWJhc2VTdG9yYWdlSW1wbCkge1xuICAgICAgICBjb25zdCBzZXJ2aWNlID0gcmVmO1xuICAgICAgICBpZiAoc2VydmljZS5fYnVja2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5vRGVmYXVsdEJ1Y2tldCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZSA9IG5ldyBSZWZlcmVuY2Uoc2VydmljZSwgc2VydmljZS5fYnVja2V0KTtcbiAgICAgICAgaWYgKHBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZkZyb21QYXRoKHJlZmVyZW5jZSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmZXJlbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyByZWYgaXMgYSBSZWZlcmVuY2VcbiAgICAgICAgaWYgKHBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9nZXRDaGlsZCQxKHJlZiwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcmVmJDEoc2VydmljZU9yUmVmLCBwYXRoT3JVcmwpIHtcbiAgICBpZiAocGF0aE9yVXJsICYmIGlzVXJsKHBhdGhPclVybCkpIHtcbiAgICAgICAgaWYgKHNlcnZpY2VPclJlZiBpbnN0YW5jZW9mIEZpcmViYXNlU3RvcmFnZUltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZWZGcm9tVVJMKHNlcnZpY2VPclJlZiwgcGF0aE9yVXJsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGludmFsaWRBcmd1bWVudCgnVG8gdXNlIHJlZihzZXJ2aWNlLCB1cmwpLCB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIFN0b3JhZ2UgaW5zdGFuY2UuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZWZGcm9tUGF0aChzZXJ2aWNlT3JSZWYsIHBhdGhPclVybCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXh0cmFjdEJ1Y2tldChob3N0LCBjb25maWcpIHtcbiAgICBjb25zdCBidWNrZXRTdHJpbmcgPSBjb25maWc/LltDT05GSUdfU1RPUkFHRV9CVUNLRVRfS0VZXTtcbiAgICBpZiAoYnVja2V0U3RyaW5nID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBMb2NhdGlvbi5tYWtlRnJvbUJ1Y2tldFNwZWMoYnVja2V0U3RyaW5nLCBob3N0KTtcbn1cbmZ1bmN0aW9uIGNvbm5lY3RTdG9yYWdlRW11bGF0b3IkMShzdG9yYWdlLCBob3N0LCBwb3J0LCBvcHRpb25zID0ge30pIHtcbiAgICBzdG9yYWdlLmhvc3QgPSBgJHtob3N0fToke3BvcnR9YDtcbiAgICBjb25zdCB1c2VTc2wgPSBpc0Nsb3VkV29ya3N0YXRpb24oaG9zdCk7XG4gICAgLy8gV29ya2Fyb3VuZCB0byBnZXQgY29va2llcyBpbiBGaXJlYmFzZSBTdHVkaW9cbiAgICBpZiAodXNlU3NsKSB7XG4gICAgICAgIHZvaWQgcGluZ1NlcnZlcihgaHR0cHM6Ly8ke3N0b3JhZ2UuaG9zdH0vYmApO1xuICAgICAgICB1cGRhdGVFbXVsYXRvckJhbm5lcignU3RvcmFnZScsIHRydWUpO1xuICAgIH1cbiAgICBzdG9yYWdlLl9pc1VzaW5nRW11bGF0b3IgPSB0cnVlO1xuICAgIHN0b3JhZ2UuX3Byb3RvY29sID0gdXNlU3NsID8gJ2h0dHBzJyA6ICdodHRwJztcbiAgICBjb25zdCB7IG1vY2tVc2VyVG9rZW4gfSA9IG9wdGlvbnM7XG4gICAgaWYgKG1vY2tVc2VyVG9rZW4pIHtcbiAgICAgICAgc3RvcmFnZS5fb3ZlcnJpZGVBdXRoVG9rZW4gPVxuICAgICAgICAgICAgdHlwZW9mIG1vY2tVc2VyVG9rZW4gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBtb2NrVXNlclRva2VuXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVNb2NrVXNlclRva2VuKG1vY2tVc2VyVG9rZW4sIHN0b3JhZ2UuYXBwLm9wdGlvbnMucHJvamVjdElkKTtcbiAgICB9XG59XG4vKipcbiAqIEEgc2VydmljZSB0aGF0IHByb3ZpZGVzIEZpcmViYXNlIFN0b3JhZ2UgUmVmZXJlbmNlIGluc3RhbmNlcy5cbiAqIEBwYXJhbSBvcHRfdXJsIC0gZ3M6Ly8gdXJsIHRvIGEgY3VzdG9tIFN0b3JhZ2UgQnVja2V0XG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIEZpcmViYXNlU3RvcmFnZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIEZpcmViYXNlQXBwIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFN0b3JhZ2VTZXJ2aWNlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFwcCwgX2F1dGhQcm92aWRlciwgXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2FwcENoZWNrUHJvdmlkZXIsIFxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF91cmwsIF9maXJlYmFzZVZlcnNpb24sIF9pc1VzaW5nRW11bGF0b3IgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5fYXV0aFByb3ZpZGVyID0gX2F1dGhQcm92aWRlcjtcbiAgICAgICAgdGhpcy5fYXBwQ2hlY2tQcm92aWRlciA9IF9hcHBDaGVja1Byb3ZpZGVyO1xuICAgICAgICB0aGlzLl91cmwgPSBfdXJsO1xuICAgICAgICB0aGlzLl9maXJlYmFzZVZlcnNpb24gPSBfZmlyZWJhc2VWZXJzaW9uO1xuICAgICAgICB0aGlzLl9pc1VzaW5nRW11bGF0b3IgPSBfaXNVc2luZ0VtdWxhdG9yO1xuICAgICAgICB0aGlzLl9idWNrZXQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBzdHJpbmcgY2FuIGJlIGluIHRoZSBmb3JtYXRzOlxuICAgICAgICAgKiAtIGhvc3RcbiAgICAgICAgICogLSBob3N0OnBvcnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hvc3QgPSBERUZBVUxUX0hPU1Q7XG4gICAgICAgIHRoaXMuX3Byb3RvY29sID0gJ2h0dHBzJztcbiAgICAgICAgdGhpcy5fYXBwSWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9kZWxldGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21heE9wZXJhdGlvblJldHJ5VGltZSA9IERFRkFVTFRfTUFYX09QRVJBVElPTl9SRVRSWV9USU1FO1xuICAgICAgICB0aGlzLl9tYXhVcGxvYWRSZXRyeVRpbWUgPSBERUZBVUxUX01BWF9VUExPQURfUkVUUllfVElNRTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmIChfdXJsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1Y2tldCA9IExvY2F0aW9uLm1ha2VGcm9tQnVja2V0U3BlYyhfdXJsLCB0aGlzLl9ob3N0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2J1Y2tldCA9IGV4dHJhY3RCdWNrZXQodGhpcy5faG9zdCwgdGhpcy5hcHAub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGhvc3Qgc3RyaW5nIGZvciB0aGlzIHNlcnZpY2UsIGluIHRoZSBmb3JtIG9mIGBob3N0YCBvclxuICAgICAqIGBob3N0OnBvcnRgLlxuICAgICAqL1xuICAgIGdldCBob3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faG9zdDtcbiAgICB9XG4gICAgc2V0IGhvc3QoaG9zdCkge1xuICAgICAgICB0aGlzLl9ob3N0ID0gaG9zdDtcbiAgICAgICAgaWYgKHRoaXMuX3VybCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9idWNrZXQgPSBMb2NhdGlvbi5tYWtlRnJvbUJ1Y2tldFNwZWModGhpcy5fdXJsLCBob3N0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2J1Y2tldCA9IGV4dHJhY3RCdWNrZXQoaG9zdCwgdGhpcy5hcHAub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gdGltZSB0byByZXRyeSB1cGxvYWRzIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBnZXQgbWF4VXBsb2FkUmV0cnlUaW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4VXBsb2FkUmV0cnlUaW1lO1xuICAgIH1cbiAgICBzZXQgbWF4VXBsb2FkUmV0cnlUaW1lKHRpbWUpIHtcbiAgICAgICAgdmFsaWRhdGVOdW1iZXIoJ3RpbWUnLCBcbiAgICAgICAgLyogbWluVmFsdWU9Ki8gMCwgXG4gICAgICAgIC8qIG1heFZhbHVlPSAqLyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHRpbWUpO1xuICAgICAgICB0aGlzLl9tYXhVcGxvYWRSZXRyeVRpbWUgPSB0aW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSB0aW1lIHRvIHJldHJ5IG9wZXJhdGlvbnMgb3RoZXIgdGhhbiB1cGxvYWRzIG9yIGRvd25sb2FkcyBpblxuICAgICAqIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBnZXQgbWF4T3BlcmF0aW9uUmV0cnlUaW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4T3BlcmF0aW9uUmV0cnlUaW1lO1xuICAgIH1cbiAgICBzZXQgbWF4T3BlcmF0aW9uUmV0cnlUaW1lKHRpbWUpIHtcbiAgICAgICAgdmFsaWRhdGVOdW1iZXIoJ3RpbWUnLCBcbiAgICAgICAgLyogbWluVmFsdWU9Ki8gMCwgXG4gICAgICAgIC8qIG1heFZhbHVlPSAqLyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHRpbWUpO1xuICAgICAgICB0aGlzLl9tYXhPcGVyYXRpb25SZXRyeVRpbWUgPSB0aW1lO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0QXV0aFRva2VuKCkge1xuICAgICAgICBpZiAodGhpcy5fb3ZlcnJpZGVBdXRoVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vdmVycmlkZUF1dGhUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdXRoID0gdGhpcy5fYXV0aFByb3ZpZGVyLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pO1xuICAgICAgICBpZiAoYXV0aCkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5EYXRhID0gYXdhaXQgYXV0aC5nZXRUb2tlbigpO1xuICAgICAgICAgICAgaWYgKHRva2VuRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkRhdGEuYWNjZXNzVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRBcHBDaGVja1Rva2VuKCkge1xuICAgICAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAodGhpcy5hcHApICYmIHRoaXMuYXBwLnNldHRpbmdzLmFwcENoZWNrVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcC5zZXR0aW5ncy5hcHBDaGVja1Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcENoZWNrID0gdGhpcy5fYXBwQ2hlY2tQcm92aWRlci5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKGFwcENoZWNrKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhcHBDaGVjay5nZXRUb2tlbigpO1xuICAgICAgICAgICAgLy8gVE9ETzogV2hhdCBkbyB3ZSB3YW50IHRvIGRvIGlmIHRoZXJlIGlzIGFuIGVycm9yIGdldHRpbmcgdGhlIHRva2VuP1xuICAgICAgICAgICAgLy8gQ29udGV4dDogYXBwQ2hlY2suZ2V0VG9rZW4oKSB3aWxsIG5ldmVyIHRocm93IGV2ZW4gaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEluIHRoZSBlcnJvciBjYXNlLCBhIGR1bW15IHRva2VuIHdpbGwgYmVcbiAgICAgICAgICAgIC8vIHJldHVybmVkIGFsb25nIHdpdGggYW4gZXJyb3IgZmllbGQgZGVzY3JpYmluZyB0aGUgZXJyb3IuIEluIGdlbmVyYWwsIHdlIHNob3VsZG4ndCBjYXJlIGFib3V0IHRoZSBlcnJvciBjb25kaXRpb24gYW5kIGp1c3QgdXNlXG4gICAgICAgICAgICAvLyB0aGUgdG9rZW4gKGFjdHVhbCBvciBkdW1teSkgdG8gc2VuZCByZXF1ZXN0cy5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgcnVubmluZyByZXF1ZXN0cyBhbmQgcHJldmVudCBtb3JlIGZyb20gYmVpbmcgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBfZGVsZXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2RlbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHMuZm9yRWFjaChyZXF1ZXN0ID0+IHJlcXVlc3QuY2FuY2VsKCkpO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgZmlyZWJhc2VTdG9yYWdlLlJlZmVyZW5jZSBvYmplY3QgcmVmZXJlbmNpbmcgdGhpcyBTdG9yYWdlU2VydmljZVxuICAgICAqIGF0IHRoZSBnaXZlbiBMb2NhdGlvbi5cbiAgICAgKi9cbiAgICBfbWFrZVN0b3JhZ2VSZWZlcmVuY2UobG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVmZXJlbmNlKHRoaXMsIGxvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSByZXF1ZXN0SW5mbyAtIEhUVFAgUmVxdWVzdEluZm8gb2JqZWN0XG4gICAgICogQHBhcmFtIGF1dGhUb2tlbiAtIEZpcmViYXNlIGF1dGggdG9rZW5cbiAgICAgKi9cbiAgICBfbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIHJlcXVlc3RGYWN0b3J5LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIHJldHJ5ID0gdHJ1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2RlbGV0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBtYWtlUmVxdWVzdChyZXF1ZXN0SW5mbywgdGhpcy5fYXBwSWQsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgcmVxdWVzdEZhY3RvcnksIHRoaXMuX2ZpcmViYXNlVmVyc2lvbiwgcmV0cnksIHRoaXMuX2lzVXNpbmdFbXVsYXRvcik7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0cy5hZGQocmVxdWVzdCk7XG4gICAgICAgICAgICAvLyBSZXF1ZXN0IHJlbW92ZXMgaXRzZWxmIGZyb20gc2V0IHdoZW4gY29tcGxldGUuXG4gICAgICAgICAgICByZXF1ZXN0LmdldFByb21pc2UoKS50aGVuKCgpID0+IHRoaXMuX3JlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0KSwgKCkgPT4gdGhpcy5fcmVxdWVzdHMuZGVsZXRlKHJlcXVlc3QpKTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWlsUmVxdWVzdChhcHBEZWxldGVkKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG1ha2VSZXF1ZXN0V2l0aFRva2VucyhyZXF1ZXN0SW5mbywgcmVxdWVzdEZhY3RvcnkpIHtcbiAgICAgICAgY29uc3QgW2F1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbl0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLl9nZXRBdXRoVG9rZW4oKSxcbiAgICAgICAgICAgIHRoaXMuX2dldEFwcENoZWNrVG9rZW4oKVxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCByZXF1ZXN0RmFjdG9yeSwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKS5nZXRQcm9taXNlKCk7XG4gICAgfVxufVxuXG5jb25zdCBuYW1lID0gXCJAZmlyZWJhc2Uvc3RvcmFnZVwiO1xuY29uc3QgdmVyc2lvbiA9IFwiMC4xNC4wXCI7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFR5cGUgY29uc3RhbnQgZm9yIEZpcmViYXNlIFN0b3JhZ2UuXG4gKi9cbmNvbnN0IFNUT1JBR0VfVFlQRSA9ICdzdG9yYWdlJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRG93bmxvYWRzIHRoZSBkYXRhIGF0IHRoZSBvYmplY3QncyBsb2NhdGlvbi4gUmV0dXJucyBhbiBlcnJvciBpZiB0aGUgb2JqZWN0XG4gKiBpcyBub3QgZm91bmQuXG4gKlxuICogVG8gdXNlIHRoaXMgZnVuY3Rpb25hbGl0eSwgeW91IGhhdmUgdG8gd2hpdGVsaXN0IHlvdXIgYXBwJ3Mgb3JpZ2luIGluIHlvdXJcbiAqIENsb3VkIFN0b3JhZ2UgYnVja2V0LiBTZWUgYWxzb1xuICogaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3N0b3JhZ2UvZG9jcy9jb25maWd1cmluZy1jb3JzXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2Ugd2hlcmUgZGF0YSBzaG91bGQgYmUgZG93bmxvYWRlZC5cbiAqIEBwYXJhbSBtYXhEb3dubG9hZFNpemVCeXRlcyAtIElmIHNldCwgdGhlIG1heGltdW0gYWxsb3dlZCBzaXplIGluIGJ5dGVzIHRvXG4gKiByZXRyaWV2ZS5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSBjb250YWluaW5nIHRoZSBvYmplY3QncyBieXRlc1xuICovXG5mdW5jdGlvbiBnZXRCeXRlcyhyZWYsIG1heERvd25sb2FkU2l6ZUJ5dGVzKSB7XG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XG4gICAgcmV0dXJuIGdldEJ5dGVzSW50ZXJuYWwocmVmLCBtYXhEb3dubG9hZFNpemVCeXRlcyk7XG59XG4vKipcbiAqIFVwbG9hZHMgZGF0YSB0byB0aGlzIG9iamVjdCdzIGxvY2F0aW9uLlxuICogVGhlIHVwbG9hZCBpcyBub3QgcmVzdW1hYmxlLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHJlZiAtIHtAbGluayBTdG9yYWdlUmVmZXJlbmNlfSB3aGVyZSBkYXRhIHNob3VsZCBiZSB1cGxvYWRlZC5cbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXBsb2FkLlxuICogQHBhcmFtIG1ldGFkYXRhIC0gTWV0YWRhdGEgZm9yIHRoZSBkYXRhIHRvIHVwbG9hZC5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSBjb250YWluaW5nIGFuIFVwbG9hZFJlc3VsdFxuICovXG5mdW5jdGlvbiB1cGxvYWRCeXRlcyhyZWYsIGRhdGEsIG1ldGFkYXRhKSB7XG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XG4gICAgcmV0dXJuIHVwbG9hZEJ5dGVzJDEocmVmLCBkYXRhLCBtZXRhZGF0YSk7XG59XG4vKipcbiAqIFVwbG9hZHMgYSBzdHJpbmcgdG8gdGhpcyBvYmplY3QncyBsb2NhdGlvbi5cbiAqIFRoZSB1cGxvYWQgaXMgbm90IHJlc3VtYWJsZS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSByZWYgLSB7QGxpbmsgU3RvcmFnZVJlZmVyZW5jZX0gd2hlcmUgc3RyaW5nIHNob3VsZCBiZSB1cGxvYWRlZC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gdXBsb2FkLlxuICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgb2YgdGhlIHN0cmluZyB0byB1cGxvYWQuXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBNZXRhZGF0YSBmb3IgdGhlIHN0cmluZyB0byB1cGxvYWQuXG4gKiBAcmV0dXJucyBBIFByb21pc2UgY29udGFpbmluZyBhbiBVcGxvYWRSZXN1bHRcbiAqL1xuZnVuY3Rpb24gdXBsb2FkU3RyaW5nKHJlZiwgdmFsdWUsIGZvcm1hdCwgbWV0YWRhdGEpIHtcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcbiAgICByZXR1cm4gdXBsb2FkU3RyaW5nJDEocmVmLCB2YWx1ZSwgZm9ybWF0LCBtZXRhZGF0YSk7XG59XG4vKipcbiAqIFVwbG9hZHMgZGF0YSB0byB0aGlzIG9iamVjdCdzIGxvY2F0aW9uLlxuICogVGhlIHVwbG9hZCBjYW4gYmUgcGF1c2VkIGFuZCByZXN1bWVkLCBhbmQgZXhwb3NlcyBwcm9ncmVzcyB1cGRhdGVzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHJlZiAtIHtAbGluayBTdG9yYWdlUmVmZXJlbmNlfSB3aGVyZSBkYXRhIHNob3VsZCBiZSB1cGxvYWRlZC5cbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXBsb2FkLlxuICogQHBhcmFtIG1ldGFkYXRhIC0gTWV0YWRhdGEgZm9yIHRoZSBkYXRhIHRvIHVwbG9hZC5cbiAqIEByZXR1cm5zIEFuIFVwbG9hZFRhc2tcbiAqL1xuZnVuY3Rpb24gdXBsb2FkQnl0ZXNSZXN1bWFibGUocmVmLCBkYXRhLCBtZXRhZGF0YSkge1xuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xuICAgIHJldHVybiB1cGxvYWRCeXRlc1Jlc3VtYWJsZSQxKHJlZiwgZGF0YSwgbWV0YWRhdGEpO1xufVxuLyoqXG4gKiBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG1ldGFkYXRhIGZvciB0aGlzIG9iamVjdC4gSWYgdGhpc1xuICogb2JqZWN0IGRvZXNuJ3QgZXhpc3Qgb3IgbWV0YWRhdGEgY2Fubm90IGJlIHJldHJpZXZlZCwgdGhlIHByb21pc2UgaXNcbiAqIHJlamVjdGVkLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHJlZiAtIHtAbGluayBTdG9yYWdlUmVmZXJlbmNlfSB0byBnZXQgbWV0YWRhdGEgZnJvbS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWV0YWRhdGEocmVmKSB7XG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XG4gICAgcmV0dXJuIGdldE1ldGFkYXRhJDEocmVmKTtcbn1cbi8qKlxuICogVXBkYXRlcyB0aGUgbWV0YWRhdGEgZm9yIHRoaXMgb2JqZWN0LlxuICogQHB1YmxpY1xuICogQHBhcmFtIHJlZiAtIHtAbGluayBTdG9yYWdlUmVmZXJlbmNlfSB0byB1cGRhdGUgbWV0YWRhdGEgZm9yLlxuICogQHBhcmFtIG1ldGFkYXRhIC0gVGhlIG5ldyBtZXRhZGF0YSBmb3IgdGhlIG9iamVjdC5cbiAqICAgICBPbmx5IHZhbHVlcyB0aGF0IGhhdmUgYmVlbiBleHBsaWNpdGx5IHNldCB3aWxsIGJlIGNoYW5nZWQuIEV4cGxpY2l0bHlcbiAqICAgICBzZXR0aW5nIGEgdmFsdWUgdG8gbnVsbCB3aWxsIHJlbW92ZSB0aGUgbWV0YWRhdGEuXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG5ldyBtZXRhZGF0YSBmb3IgdGhpcyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZU1ldGFkYXRhKHJlZiwgbWV0YWRhdGEpIHtcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcbiAgICByZXR1cm4gdXBkYXRlTWV0YWRhdGEkMShyZWYsIG1ldGFkYXRhKTtcbn1cbi8qKlxuICogTGlzdCBpdGVtcyAoZmlsZXMpIGFuZCBwcmVmaXhlcyAoZm9sZGVycykgdW5kZXIgdGhpcyBzdG9yYWdlIHJlZmVyZW5jZS5cbiAqXG4gKiBMaXN0IEFQSSBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgRmlyZWJhc2UgUnVsZXMgVmVyc2lvbiAyLlxuICpcbiAqIEdDUyBpcyBhIGtleS1ibG9iIHN0b3JlLiBGaXJlYmFzZSBTdG9yYWdlIGltcG9zZXMgdGhlIHNlbWFudGljIG9mICcvJ1xuICogZGVsaW1pdGVkIGZvbGRlciBzdHJ1Y3R1cmUuXG4gKiBSZWZlciB0byBHQ1MncyBMaXN0IEFQSSBpZiB5b3Ugd2FudCB0byBsZWFybiBtb3JlLlxuICpcbiAqIFRvIGFkaGVyZSB0byBGaXJlYmFzZSBSdWxlcydzIFNlbWFudGljcywgRmlyZWJhc2UgU3RvcmFnZSBkb2VzIG5vdFxuICogc3VwcG9ydCBvYmplY3RzIHdob3NlIHBhdGhzIGVuZCB3aXRoIFwiL1wiIG9yIGNvbnRhaW4gdHdvIGNvbnNlY3V0aXZlXG4gKiBcIi9cInMuIEZpcmViYXNlIFN0b3JhZ2UgTGlzdCBBUEkgd2lsbCBmaWx0ZXIgdGhlc2UgdW5zdXBwb3J0ZWQgb2JqZWN0cy5cbiAqIGxpc3QoKSBtYXkgZmFpbCBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgdW5zdXBwb3J0ZWQgb2JqZWN0cyBpbiB0aGUgYnVja2V0LlxuICogQHB1YmxpY1xuICpcbiAqIEBwYXJhbSByZWYgLSB7QGxpbmsgU3RvcmFnZVJlZmVyZW5jZX0gdG8gZ2V0IGxpc3QgZnJvbS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gU2VlIHtAbGluayBMaXN0T3B0aW9uc30gZm9yIGRldGFpbHMuXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGl0ZW1zIGFuZCBwcmVmaXhlcy5cbiAqICAgICAgYHByZWZpeGVzYCBjb250YWlucyByZWZlcmVuY2VzIHRvIHN1Yi1mb2xkZXJzIGFuZCBgaXRlbXNgXG4gKiAgICAgIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG8gb2JqZWN0cyBpbiB0aGlzIGZvbGRlci4gYG5leHRQYWdlVG9rZW5gXG4gKiAgICAgIGNhbiBiZSB1c2VkIHRvIGdldCB0aGUgcmVzdCBvZiB0aGUgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbGlzdChyZWYsIG9wdGlvbnMpIHtcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcbiAgICByZXR1cm4gbGlzdCQxKHJlZiwgb3B0aW9ucyk7XG59XG4vKipcbiAqIExpc3QgYWxsIGl0ZW1zIChmaWxlcykgYW5kIHByZWZpeGVzIChmb2xkZXJzKSB1bmRlciB0aGlzIHN0b3JhZ2UgcmVmZXJlbmNlLlxuICpcbiAqIFRoaXMgaXMgYSBoZWxwZXIgbWV0aG9kIGZvciBjYWxsaW5nIGxpc3QoKSByZXBlYXRlZGx5IHVudGlsIHRoZXJlIGFyZVxuICogbm8gbW9yZSByZXN1bHRzLiBUaGUgZGVmYXVsdCBwYWdpbmF0aW9uIHNpemUgaXMgMTAwMC5cbiAqXG4gKiBOb3RlOiBUaGUgcmVzdWx0cyBtYXkgbm90IGJlIGNvbnNpc3RlbnQgaWYgb2JqZWN0cyBhcmUgY2hhbmdlZCB3aGlsZSB0aGlzXG4gKiBvcGVyYXRpb24gaXMgcnVubmluZy5cbiAqXG4gKiBXYXJuaW5nOiBgbGlzdEFsbGAgbWF5IHBvdGVudGlhbGx5IGNvbnN1bWUgdG9vIG1hbnkgcmVzb3VyY2VzIGlmIHRoZXJlIGFyZVxuICogdG9vIG1hbnkgcmVzdWx0cy5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSByZWYgLSB7QGxpbmsgU3RvcmFnZVJlZmVyZW5jZX0gdG8gZ2V0IGxpc3QgZnJvbS5cbiAqXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHdpdGggYWxsIHRoZSBpdGVtcyBhbmQgcHJlZml4ZXMgdW5kZXJcbiAqICAgICAgdGhlIGN1cnJlbnQgc3RvcmFnZSByZWZlcmVuY2UuIGBwcmVmaXhlc2AgY29udGFpbnMgcmVmZXJlbmNlcyB0b1xuICogICAgICBzdWItZGlyZWN0b3JpZXMgYW5kIGBpdGVtc2AgY29udGFpbnMgcmVmZXJlbmNlcyB0byBvYmplY3RzIGluIHRoaXNcbiAqICAgICAgZm9sZGVyLiBgbmV4dFBhZ2VUb2tlbmAgaXMgbmV2ZXIgcmV0dXJuZWQuXG4gKi9cbmZ1bmN0aW9uIGxpc3RBbGwocmVmKSB7XG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XG4gICAgcmV0dXJuIGxpc3RBbGwkMShyZWYpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkb3dubG9hZCBVUkwgZm9yIHRoZSBnaXZlbiB7QGxpbmsgU3RvcmFnZVJlZmVyZW5jZX0uXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcmVmIC0ge0BsaW5rIFN0b3JhZ2VSZWZlcmVuY2V9IHRvIGdldCB0aGUgZG93bmxvYWQgVVJMIGZvci5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZG93bmxvYWRcbiAqICAgICBVUkwgZm9yIHRoaXMgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZXREb3dubG9hZFVSTChyZWYpIHtcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcbiAgICByZXR1cm4gZ2V0RG93bmxvYWRVUkwkMShyZWYpO1xufVxuLyoqXG4gKiBEZWxldGVzIHRoZSBvYmplY3QgYXQgdGhpcyBsb2NhdGlvbi5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSByZWYgLSB7QGxpbmsgU3RvcmFnZVJlZmVyZW5jZX0gZm9yIG9iamVjdCB0byBkZWxldGUuXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIGlmIHRoZSBkZWxldGlvbiBzdWNjZWVkcy5cbiAqL1xuZnVuY3Rpb24gZGVsZXRlT2JqZWN0KHJlZikge1xuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xuICAgIHJldHVybiBkZWxldGVPYmplY3QkMShyZWYpO1xufVxuZnVuY3Rpb24gcmVmKHNlcnZpY2VPclJlZiwgcGF0aE9yVXJsKSB7XG4gICAgc2VydmljZU9yUmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHNlcnZpY2VPclJlZik7XG4gICAgcmV0dXJuIHJlZiQxKHNlcnZpY2VPclJlZiwgcGF0aE9yVXJsKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9nZXRDaGlsZChyZWYsIGNoaWxkUGF0aCkge1xuICAgIHJldHVybiBfZ2V0Q2hpbGQkMShyZWYsIGNoaWxkUGF0aCk7XG59XG4vKipcbiAqIEdldHMgYSB7QGxpbmsgRmlyZWJhc2VTdG9yYWdlfSBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIEZpcmViYXNlIGFwcC5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBhcHAgLSBGaXJlYmFzZSBhcHAgdG8gZ2V0IHtAbGluayBGaXJlYmFzZVN0b3JhZ2V9IGluc3RhbmNlIGZvci5cbiAqIEBwYXJhbSBidWNrZXRVcmwgLSBUaGUgZ3M6Ly8gdXJsIHRvIHlvdXIgRmlyZWJhc2UgU3RvcmFnZSBCdWNrZXQuXG4gKiBJZiBub3QgcGFzc2VkLCB1c2VzIHRoZSBhcHAncyBkZWZhdWx0IFN0b3JhZ2UgQnVja2V0LlxuICogQHJldHVybnMgQSB7QGxpbmsgRmlyZWJhc2VTdG9yYWdlfSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RvcmFnZShhcHAgPSBnZXRBcHAoKSwgYnVja2V0VXJsKSB7XG4gICAgYXBwID0gZ2V0TW9kdWxhckluc3RhbmNlKGFwcCk7XG4gICAgY29uc3Qgc3RvcmFnZVByb3ZpZGVyID0gX2dldFByb3ZpZGVyKGFwcCwgU1RPUkFHRV9UWVBFKTtcbiAgICBjb25zdCBzdG9yYWdlSW5zdGFuY2UgPSBzdG9yYWdlUHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHtcbiAgICAgICAgaWRlbnRpZmllcjogYnVja2V0VXJsXG4gICAgfSk7XG4gICAgY29uc3QgZW11bGF0b3IgPSBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQoJ3N0b3JhZ2UnKTtcbiAgICBpZiAoZW11bGF0b3IpIHtcbiAgICAgICAgY29ubmVjdFN0b3JhZ2VFbXVsYXRvcihzdG9yYWdlSW5zdGFuY2UsIC4uLmVtdWxhdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3JhZ2VJbnN0YW5jZTtcbn1cbi8qKlxuICogTW9kaWZ5IHRoaXMge0BsaW5rIEZpcmViYXNlU3RvcmFnZX0gaW5zdGFuY2UgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgQ2xvdWQgU3RvcmFnZSBlbXVsYXRvci5cbiAqXG4gKiBAcGFyYW0gc3RvcmFnZSAtIFRoZSB7QGxpbmsgRmlyZWJhc2VTdG9yYWdlfSBpbnN0YW5jZVxuICogQHBhcmFtIGhvc3QgLSBUaGUgZW11bGF0b3IgaG9zdCAoZXg6IGxvY2FsaG9zdClcbiAqIEBwYXJhbSBwb3J0IC0gVGhlIGVtdWxhdG9yIHBvcnQgKGV4OiA1MDAxKVxuICogQHBhcmFtIG9wdGlvbnMgLSBFbXVsYXRvciBvcHRpb25zLiBgb3B0aW9ucy5tb2NrVXNlclRva2VuYCBpcyB0aGUgbW9jayBhdXRoXG4gKiB0b2tlbiB0byB1c2UgZm9yIHVuaXQgdGVzdGluZyBTZWN1cml0eSBSdWxlcy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY29ubmVjdFN0b3JhZ2VFbXVsYXRvcihzdG9yYWdlLCBob3N0LCBwb3J0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25uZWN0U3RvcmFnZUVtdWxhdG9yJDEoc3RvcmFnZSwgaG9zdCwgcG9ydCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIERvd25sb2FkcyB0aGUgZGF0YSBhdCB0aGUgb2JqZWN0J3MgbG9jYXRpb24uIFJldHVybnMgYW4gZXJyb3IgaWYgdGhlIG9iamVjdFxuICogaXMgbm90IGZvdW5kLlxuICpcbiAqIFRvIHVzZSB0aGlzIGZ1bmN0aW9uYWxpdHksIHlvdSBoYXZlIHRvIHdoaXRlbGlzdCB5b3VyIGFwcCdzIG9yaWdpbiBpbiB5b3VyXG4gKiBDbG91ZCBTdG9yYWdlIGJ1Y2tldC4gU2VlIGFsc29cbiAqIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9zdG9yYWdlL2RvY3MvY29uZmlndXJpbmctY29yc1xuICpcbiAqIFRoaXMgQVBJIGlzIG5vdCBhdmFpbGFibGUgaW4gTm9kZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB3aGVyZSBkYXRhIHNob3VsZCBiZSBkb3dubG9hZGVkLlxuICogQHBhcmFtIG1heERvd25sb2FkU2l6ZUJ5dGVzIC0gSWYgc2V0LCB0aGUgbWF4aW11bSBhbGxvd2VkIHNpemUgaW4gYnl0ZXMgdG9cbiAqIHJldHJpZXZlLlxuICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIEJsb2IgY29udGFpbmluZyB0aGUgb2JqZWN0J3MgYnl0ZXNcbiAqL1xuZnVuY3Rpb24gZ2V0QmxvYihyZWYsIG1heERvd25sb2FkU2l6ZUJ5dGVzKSB7XG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XG4gICAgcmV0dXJuIGdldEJsb2JJbnRlcm5hbChyZWYsIG1heERvd25sb2FkU2l6ZUJ5dGVzKTtcbn1cbi8qKlxuICogRG93bmxvYWRzIHRoZSBkYXRhIGF0IHRoZSBvYmplY3QncyBsb2NhdGlvbi4gUmFpc2VzIGFuIGVycm9yIGV2ZW50IGlmIHRoZVxuICogb2JqZWN0IGlzIG5vdCBmb3VuZC5cbiAqXG4gKiBUaGlzIEFQSSBpcyBvbmx5IGF2YWlsYWJsZSBpbiBOb2RlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHdoZXJlIGRhdGEgc2hvdWxkIGJlIGRvd25sb2FkZWQuXG4gKiBAcGFyYW0gbWF4RG93bmxvYWRTaXplQnl0ZXMgLSBJZiBzZXQsIHRoZSBtYXhpbXVtIGFsbG93ZWQgc2l6ZSBpbiBieXRlcyB0b1xuICogcmV0cmlldmUuXG4gKiBAcmV0dXJucyBBIHN0cmVhbSB3aXRoIHRoZSBvYmplY3QncyBkYXRhIGFzIGJ5dGVzXG4gKi9cbmZ1bmN0aW9uIGdldFN0cmVhbShyZWYsIG1heERvd25sb2FkU2l6ZUJ5dGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnZXRTdHJlYW0oKSBpcyBvbmx5IHN1cHBvcnRlZCBieSBOb2RlSlMgYnVpbGRzJyk7XG59XG5cbi8qKlxuICogQ2xvdWQgU3RvcmFnZSBmb3IgRmlyZWJhc2VcbiAqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuZnVuY3Rpb24gZmFjdG9yeShjb250YWluZXIsIHsgaW5zdGFuY2VJZGVudGlmaWVyOiB1cmwgfSkge1xuICAgIGNvbnN0IGFwcCA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XG4gICAgY29uc3QgYXV0aFByb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhdXRoLWludGVybmFsJyk7XG4gICAgY29uc3QgYXBwQ2hlY2tQcm92aWRlciA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwLWNoZWNrLWludGVybmFsJyk7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VJbXBsKGFwcCwgYXV0aFByb3ZpZGVyLCBhcHBDaGVja1Byb3ZpZGVyLCB1cmwsIFNES19WRVJTSU9OKTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyU3RvcmFnZSgpIHtcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudChTVE9SQUdFX1RZUEUsIGZhY3RvcnksIFwiUFVCTElDXCIgLyogQ29tcG9uZW50VHlwZS5QVUJMSUMgKi8pLnNldE11bHRpcGxlSW5zdGFuY2VzKHRydWUpKTtcbiAgICAvL1JVTlRJTUVfRU5WIHdpbGwgYmUgcmVwbGFjZWQgZHVyaW5nIHRoZSBjb21waWxhdGlvbiB0byBcIm5vZGVcIiBmb3Igbm9kZWpzIGFuZCBhbiBlbXB0eSBzdHJpbmcgZm9yIGJyb3dzZXJcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgJycpO1xuICAgIC8vIEJVSUxEX1RBUkdFVCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHZhbHVlcyBsaWtlIGVzbSwgY2pzLCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uLCAnZXNtMjAyMCcpO1xufVxucmVnaXN0ZXJTdG9yYWdlKCk7XG5cbmV4cG9ydCB7IFN0b3JhZ2VFcnJvciwgU3RvcmFnZUVycm9yQ29kZSwgU3RyaW5nRm9ybWF0LCBGYnNCbG9iIGFzIF9GYnNCbG9iLCBMb2NhdGlvbiBhcyBfTG9jYXRpb24sIFRhc2tFdmVudCBhcyBfVGFza0V2ZW50LCBUYXNrU3RhdGUgYXMgX1Rhc2tTdGF0ZSwgVXBsb2FkVGFzayBhcyBfVXBsb2FkVGFzaywgZGF0YUZyb21TdHJpbmcgYXMgX2RhdGFGcm9tU3RyaW5nLCBfZ2V0Q2hpbGQsIGludmFsaWRBcmd1bWVudCBhcyBfaW52YWxpZEFyZ3VtZW50LCBpbnZhbGlkUm9vdE9wZXJhdGlvbiBhcyBfaW52YWxpZFJvb3RPcGVyYXRpb24sIGNvbm5lY3RTdG9yYWdlRW11bGF0b3IsIGRlbGV0ZU9iamVjdCwgZ2V0QmxvYiwgZ2V0Qnl0ZXMsIGdldERvd25sb2FkVVJMLCBnZXRNZXRhZGF0YSwgZ2V0U3RvcmFnZSwgZ2V0U3RyZWFtLCBsaXN0LCBsaXN0QWxsLCByZWYsIHVwZGF0ZU1ldGFkYXRhLCB1cGxvYWRCeXRlcywgdXBsb2FkQnl0ZXNSZXN1bWFibGUsIHVwbG9hZFN0cmluZyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@firebase/storage/dist/index.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/firebase/storage/dist/esm/index.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/firebase/storage/dist/esm/index.esm.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageError: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.StorageError),\n/* harmony export */   StorageErrorCode: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.StorageErrorCode),\n/* harmony export */   StringFormat: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.StringFormat),\n/* harmony export */   _FbsBlob: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__._FbsBlob),\n/* harmony export */   _Location: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__._Location),\n/* harmony export */   _TaskEvent: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__._TaskEvent),\n/* harmony export */   _TaskState: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__._TaskState),\n/* harmony export */   _UploadTask: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__._UploadTask),\n/* harmony export */   _dataFromString: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__._dataFromString),\n/* harmony export */   _getChild: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__._getChild),\n/* harmony export */   _invalidArgument: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__._invalidArgument),\n/* harmony export */   _invalidRootOperation: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__._invalidRootOperation),\n/* harmony export */   connectStorageEmulator: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.connectStorageEmulator),\n/* harmony export */   deleteObject: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.deleteObject),\n/* harmony export */   getBlob: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.getBlob),\n/* harmony export */   getBytes: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.getBytes),\n/* harmony export */   getDownloadURL: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.getDownloadURL),\n/* harmony export */   getMetadata: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.getMetadata),\n/* harmony export */   getStorage: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.getStorage),\n/* harmony export */   getStream: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.getStream),\n/* harmony export */   list: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.list),\n/* harmony export */   listAll: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.listAll),\n/* harmony export */   ref: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.ref),\n/* harmony export */   updateMetadata: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.updateMetadata),\n/* harmony export */   uploadBytes: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.uploadBytes),\n/* harmony export */   uploadBytesResumable: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.uploadBytesResumable),\n/* harmony export */   uploadString: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.uploadString)\n/* harmony export */ });\n/* harmony import */ var _firebase_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/storage */ \"(app-pages-browser)/./node_modules/@firebase/storage/dist/index.esm.js\");\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ2xDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGhvbGVjZWtqXFxEZXNrdG9wXFxrcm91LWt5LWhiLW1haW5cXG5vZGVfbW9kdWxlc1xcZmlyZWJhc2VcXHN0b3JhZ2VcXGRpc3RcXGVzbVxcaW5kZXguZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJ0BmaXJlYmFzZS9zdG9yYWdlJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/firebase/storage/dist/esm/index.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/index.css":
/*!***********************!*\
  !*** ./src/index.css ***!
  \***********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"25031bc96a44\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbmRleC5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGhvbGVjZWtqXFxEZXNrdG9wXFxrcm91LWt5LWhiLW1haW5cXHNyY1xcaW5kZXguY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiMjUwMzFiYzk2YTQ0XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/index.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/firebase.ts":
/*!*****************************!*\
  !*** ./src/lib/firebase.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   auth: () => (/* binding */ auth),\n/* harmony export */   db: () => (/* binding */ db),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   storage: () => (/* binding */ storage)\n/* harmony export */ });\n/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/app */ \"(app-pages-browser)/./node_modules/firebase/app/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/auth */ \"(app-pages-browser)/./node_modules/firebase/auth/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! firebase/storage */ \"(app-pages-browser)/./node_modules/firebase/storage/dist/esm/index.esm.js\");\n\n\n\n\n// Firebase config - nahraďte svými údaji z Firebase Console\n// https://console.firebase.google.com/\nconst firebaseConfig = {\n    apiKey: \"AIzaSyBXZ5xOtzRcg7iwn6hiA-EUmamejECEazA\",\n    authDomain: \"ict-projekt2.firebaseapp.com\",\n    projectId: \"ict-projekt2\",\n    storageBucket: \"ict-projekt2.firebasestorage.app\",\n    messagingSenderId: \"987048208484\",\n    appId: \"1:987048208484:web:4dfc4cf25ad503a2ef9771\"\n};\n// Check if Firebase is properly configured\nconst isFirebaseConfigured = firebaseConfig.apiKey && firebaseConfig.projectId && firebaseConfig.apiKey !== 'demo-api-key';\n// Initialize Firebase only if properly configured\nlet app;\nlet auth = null;\nlet db = null;\nlet storage = null;\nif (isFirebaseConfigured) {\n    try {\n        app = (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(firebaseConfig);\n        auth = (0,firebase_auth__WEBPACK_IMPORTED_MODULE_1__.getAuth)(app);\n        db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getFirestore)(app);\n        storage = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_3__.getStorage)(app);\n        console.log('✅ Firebase initialized successfully');\n    } catch (error) {\n        console.error('❌ Firebase initialization error:', error);\n    }\n} else {\n    console.warn('⚠️ Firebase not configured. Set environment variables in .env.local');\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (app);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZmlyZWJhc2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBNkM7QUFDQztBQUNlO0FBQ0U7QUFFL0QsNERBQTREO0FBQzVELHVDQUF1QztBQUN2QyxNQUFNSSxpQkFBaUI7SUFDckJDLFFBQVFDLHlDQUF3QztJQUNoREcsWUFBWUgsOEJBQTRDO0lBQ3hESyxXQUFXTCxjQUEyQztJQUN0RE8sZUFBZVAsa0NBQStDO0lBQzlEUyxtQkFBbUJULGNBQW9EO0lBQ3ZFVyxPQUFPWCwyQ0FBdUM7QUFDaEQ7QUFFQSwyQ0FBMkM7QUFDM0MsTUFBTWEsdUJBQXVCZixlQUFlQyxNQUFNLElBQ2hERCxlQUFlTyxTQUFTLElBQ3hCUCxlQUFlQyxNQUFNLEtBQUs7QUFFNUIsa0RBQWtEO0FBQ2xELElBQUllO0FBQ0osSUFBSUMsT0FBb0I7QUFDeEIsSUFBSUMsS0FBdUI7QUFDM0IsSUFBSUMsVUFBa0M7QUFFdEMsSUFBSUosc0JBQXNCO0lBQ3hCLElBQUk7UUFDRkMsTUFBTXBCLDJEQUFhQSxDQUFDSTtRQUNwQmlCLE9BQU9wQixzREFBT0EsQ0FBQ21CO1FBQ2ZFLEtBQUtwQixnRUFBWUEsQ0FBQ2tCO1FBQ2xCRyxVQUFVcEIsNERBQVVBLENBQUNpQjtRQUNyQkksUUFBUUMsR0FBRyxDQUFDO0lBQ2QsRUFBRSxPQUFPQyxPQUFPO1FBQ2RGLFFBQVFFLEtBQUssQ0FBQyxvQ0FBb0NBO0lBQ3BEO0FBQ0YsT0FBTztJQUNMRixRQUFRRyxJQUFJLENBQUM7QUFDZjtBQUU2QjtBQUM3QixpRUFBZVAsR0FBR0EsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxob2xlY2VralxcRGVza3RvcFxca3JvdS1reS1oYi1tYWluXFxzcmNcXGxpYlxcZmlyZWJhc2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW5pdGlhbGl6ZUFwcCB9IGZyb20gJ2ZpcmViYXNlL2FwcCc7XHJcbmltcG9ydCB7IGdldEF1dGgsIEF1dGggfSBmcm9tICdmaXJlYmFzZS9hdXRoJztcclxuaW1wb3J0IHsgZ2V0RmlyZXN0b3JlLCBGaXJlc3RvcmUgfSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xyXG5pbXBvcnQgeyBnZXRTdG9yYWdlLCBGaXJlYmFzZVN0b3JhZ2UgfSBmcm9tICdmaXJlYmFzZS9zdG9yYWdlJztcclxuXHJcbi8vIEZpcmViYXNlIGNvbmZpZyAtIG5haHJhxI90ZSBzdsO9bWkgw7pkYWppIHogRmlyZWJhc2UgQ29uc29sZVxyXG4vLyBodHRwczovL2NvbnNvbGUuZmlyZWJhc2UuZ29vZ2xlLmNvbS9cclxuY29uc3QgZmlyZWJhc2VDb25maWcgPSB7XHJcbiAgYXBpS2V5OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9BUElfS0VZLFxyXG4gIGF1dGhEb21haW46IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FVVEhfRE9NQUlOLFxyXG4gIHByb2plY3RJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRCxcclxuICBzdG9yYWdlQnVja2V0OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9TVE9SQUdFX0JVQ0tFVCxcclxuICBtZXNzYWdpbmdTZW5kZXJJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfTUVTU0FHSU5HX1NFTkRFUl9JRCxcclxuICBhcHBJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBQX0lELFxyXG59O1xyXG5cclxuLy8gQ2hlY2sgaWYgRmlyZWJhc2UgaXMgcHJvcGVybHkgY29uZmlndXJlZFxyXG5jb25zdCBpc0ZpcmViYXNlQ29uZmlndXJlZCA9IGZpcmViYXNlQ29uZmlnLmFwaUtleSAmJiBcclxuICBmaXJlYmFzZUNvbmZpZy5wcm9qZWN0SWQgJiYgXHJcbiAgZmlyZWJhc2VDb25maWcuYXBpS2V5ICE9PSAnZGVtby1hcGkta2V5JztcclxuXHJcbi8vIEluaXRpYWxpemUgRmlyZWJhc2Ugb25seSBpZiBwcm9wZXJseSBjb25maWd1cmVkXHJcbmxldCBhcHA7XHJcbmxldCBhdXRoOiBBdXRoIHwgbnVsbCA9IG51bGw7XHJcbmxldCBkYjogRmlyZXN0b3JlIHwgbnVsbCA9IG51bGw7XHJcbmxldCBzdG9yYWdlOiBGaXJlYmFzZVN0b3JhZ2UgfCBudWxsID0gbnVsbDtcclxuXHJcbmlmIChpc0ZpcmViYXNlQ29uZmlndXJlZCkge1xyXG4gIHRyeSB7XHJcbiAgICBhcHAgPSBpbml0aWFsaXplQXBwKGZpcmViYXNlQ29uZmlnKTtcclxuICAgIGF1dGggPSBnZXRBdXRoKGFwcCk7XHJcbiAgICBkYiA9IGdldEZpcmVzdG9yZShhcHApO1xyXG4gICAgc3RvcmFnZSA9IGdldFN0b3JhZ2UoYXBwKTtcclxuICAgIGNvbnNvbGUubG9nKCfinIUgRmlyZWJhc2UgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGaXJlYmFzZSBpbml0aWFsaXphdGlvbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgfVxyXG59IGVsc2Uge1xyXG4gIGNvbnNvbGUud2Fybign4pqg77iPIEZpcmViYXNlIG5vdCBjb25maWd1cmVkLiBTZXQgZW52aXJvbm1lbnQgdmFyaWFibGVzIGluIC5lbnYubG9jYWwnKTtcclxufVxyXG5cclxuZXhwb3J0IHsgYXV0aCwgZGIsIHN0b3JhZ2UgfTtcclxuZXhwb3J0IGRlZmF1bHQgYXBwO1xyXG4iXSwibmFtZXMiOlsiaW5pdGlhbGl6ZUFwcCIsImdldEF1dGgiLCJnZXRGaXJlc3RvcmUiLCJnZXRTdG9yYWdlIiwiZmlyZWJhc2VDb25maWciLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBJX0tFWSIsImF1dGhEb21haW4iLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9BVVRIX0RPTUFJTiIsInByb2plY3RJZCIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX1BST0pFQ1RfSUQiLCJzdG9yYWdlQnVja2V0IiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfU1RPUkFHRV9CVUNLRVQiLCJtZXNzYWdpbmdTZW5kZXJJZCIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX01FU1NBR0lOR19TRU5ERVJfSUQiLCJhcHBJZCIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FQUF9JRCIsImlzRmlyZWJhc2VDb25maWd1cmVkIiwiYXBwIiwiYXV0aCIsImRiIiwic3RvcmFnZSIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsIndhcm4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/firebase.ts\n"));

/***/ })

});